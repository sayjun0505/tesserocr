/* Generated by Cython 0.23.4 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03020000)
    #error Cython requires Python 2.6+ or Python 3.2+.
#else
#define CYTHON_ABI "0_23_4"
#include <stddef.h>
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
#define CYTHON_COMPILING_IN_PYPY 1
#define CYTHON_COMPILING_IN_CPYTHON 0
#else
#define CYTHON_COMPILING_IN_PYPY 0
#define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if !defined(CYTHON_USE_PYLONG_INTERNALS) && CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x02070000
#define CYTHON_USE_PYLONG_INTERNALS 1
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
#define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if PY_VERSION_HEX >= 0x030500B1
#define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
#define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
#elif CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
typedef struct {
    unaryfunc am_await;
    unaryfunc am_aiter;
    unaryfunc am_anext;
} __Pyx_PyAsyncMethodsStruct;
#define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
#else
#define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)

#ifndef __cplusplus
  #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
#endif
#ifndef CYTHON_INLINE
  #define CYTHON_INLINE inline
#endif
template<typename T>
void __Pyx_call_destructor(T& x) {
    x.~T();
}
template<typename T>
class __Pyx_FakeReference {
  public:
    __Pyx_FakeReference() : ptr(NULL) { }
    __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
    T *operator->() { return ptr; }
    operator T&() { return *ptr; }
  private:
    T *ptr;
};

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__tesserocr
#define __PYX_HAVE_API__tesserocr
#include "leptonica/allheaders.h"
#include "tesseract/publictypes.h"
#include "tesseract/unichar.h"
#include "tesseract/genericvector.h"
#include "tesseract/strngs.h"
#include "tesseract/ocrclass.h"
#include "ios"
#include "new"
#include "stdexcept"
#include "typeinfo"
#include "tesseract/pageiterator.h"
#include "tesseract/ltrresultiterator.h"
#include "tesseract/resultiterator.h"
#include "tesseract/renderer.h"
#include "tesseract/baseapi.h"
#include "string.h"
#include "stdlib.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING "utf8"
#define __Pyx_PyObject_FromString __Pyx_PyUnicode_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER) && defined (_M_X64)
    #define __Pyx_sst_abs(value) _abs64(value)
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "tesserocr.pyx",
};

/* "tesseract.pxd":2
 * from libcpp cimport bool
 * ctypedef const char cchar_t             # <<<<<<<<<<<<<<
 * ctypedef const unsigned char cuchar_t
 * 
 */
typedef char const __pyx_t_9tesseract_cchar_t;

/* "tesseract.pxd":3
 * from libcpp cimport bool
 * ctypedef const char cchar_t
 * ctypedef const unsigned char cuchar_t             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "leptonica/allheaders.h" nogil:
 */
typedef unsigned char const __pyx_t_9tesseract_cuchar_t;

/*--- Type declarations ---*/
struct __pyx_obj_9tesserocr__Enum;
struct __pyx_obj_9tesserocr_OEM;
struct __pyx_obj_9tesserocr_PSM;
struct __pyx_obj_9tesserocr_RIL;
struct __pyx_obj_9tesserocr_PT;
struct __pyx_obj_9tesserocr_Orientation;
struct __pyx_obj_9tesserocr_WritingDirection;
struct __pyx_obj_9tesserocr_TextlineOrder;
struct __pyx_obj_9tesserocr_Justification;
struct __pyx_obj_9tesserocr_DIR;
struct __pyx_obj_9tesserocr_PyPageIterator;
struct __pyx_obj_9tesserocr_PyLTRResultIterator;
struct __pyx_obj_9tesserocr_PyResultIterator;
struct __pyx_obj_9tesserocr_PyChoiceIterator;
struct __pyx_obj_9tesserocr_PyTessBaseAPI;
struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list;
struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr;
struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon;
struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr;
struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr;
struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices;
struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level;

/* "tesserocr.pyx":50
 * 
 * 
 * cdef class _Enum:             # <<<<<<<<<<<<<<
 * 
 *     def __init__(self):
 */
struct __pyx_obj_9tesserocr__Enum {
  PyObject_HEAD
};


/* "tesserocr.pyx":55
 *         raise TypeError('{} is an enum and cannot be instantiated'.fromat(type(self).__name__))
 * 
 * cdef class OEM(_Enum):             # <<<<<<<<<<<<<<
 *     """An enum that defines avaialble OCR engine modes."""
 * 
 */
struct __pyx_obj_9tesserocr_OEM {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":64
 * 
 * 
 * cdef class PSM(_Enum):             # <<<<<<<<<<<<<<
 *     """An enum that defines all available page segmentation modes.
 * 
 */
struct __pyx_obj_9tesserocr_PSM {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":131
 * 
 * 
 * cdef class RIL(_Enum):             # <<<<<<<<<<<<<<
 *     """An enum that defines available Page Iterator levels.
 * 
 */
struct __pyx_obj_9tesserocr_RIL {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":158
 * 
 * 
 * cdef class PT(_Enum):             # <<<<<<<<<<<<<<
 *     """An enum the defines avaialbe Poly Block types.
 * 
 */
struct __pyx_obj_9tesserocr_PT {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":228
 * 
 * 
 * cdef class Orientation(_Enum):             # <<<<<<<<<<<<<<
 *     """Enum for orientation options."""
 * 
 */
struct __pyx_obj_9tesserocr_Orientation {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":237
 * 
 * 
 * cdef class WritingDirection(_Enum):             # <<<<<<<<<<<<<<
 *     """Enum for writing direction options."""
 * 
 */
struct __pyx_obj_9tesserocr_WritingDirection {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":245
 * 
 * 
 * cdef class TextlineOrder(_Enum):             # <<<<<<<<<<<<<<
 *     """Enum for text line order options."""
 * 
 */
struct __pyx_obj_9tesserocr_TextlineOrder {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":253
 * 
 * 
 * cdef class Justification(_Enum):             # <<<<<<<<<<<<<<
 *     """Enum for justification options."""
 * 
 */
struct __pyx_obj_9tesserocr_Justification {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":262
 * 
 * 
 * cdef class DIR(_Enum):             # <<<<<<<<<<<<<<
 *     """Enum for strong text direction values.
 * 
 */
struct __pyx_obj_9tesserocr_DIR {
  struct __pyx_obj_9tesserocr__Enum __pyx_base;
};


/* "tesserocr.pyx":326
 * 
 * 
 * cdef class PyPageIterator:             # <<<<<<<<<<<<<<
 *     """Wrapper around Tesseract's ``PageIterator`` class.
 *     Returned by :meth:`PyTessBaseAPI.AnalyseLayout`.
 */
struct __pyx_obj_9tesserocr_PyPageIterator {
  PyObject_HEAD
  struct __pyx_vtabstruct_9tesserocr_PyPageIterator *__pyx_vtab;
  tesseract::PageIterator *_piter;
};


/* "tesserocr.pyx":726
 * 
 * 
 * cdef class PyLTRResultIterator(PyPageIterator):             # <<<<<<<<<<<<<<
 * 
 *     cdef LTRResultIterator *_ltrriter
 */
struct __pyx_obj_9tesserocr_PyLTRResultIterator {
  struct __pyx_obj_9tesserocr_PyPageIterator __pyx_base;
  tesseract::LTRResultIterator *_ltrriter;
};


/* "tesserocr.pyx":918
 * 
 * 
 * cdef class PyResultIterator(PyLTRResultIterator):             # <<<<<<<<<<<<<<
 *     """Wrapper around Tesseract's ``ResultIterator`` class.
 * 
 */
struct __pyx_obj_9tesserocr_PyResultIterator {
  struct __pyx_obj_9tesserocr_PyLTRResultIterator __pyx_base;
  tesseract::ResultIterator *_riter;
};


/* "tesserocr.pyx":960
 * 
 * 
 * cdef class PyChoiceIterator:             # <<<<<<<<<<<<<<
 * 
 *     cdef ChoiceIterator *_citer
 */
struct __pyx_obj_9tesserocr_PyChoiceIterator {
  PyObject_HEAD
  struct __pyx_vtabstruct_9tesserocr_PyChoiceIterator *__pyx_vtab;
  tesseract::ChoiceIterator *_citer;
};


/* "tesserocr.pyx":1020
 * 
 * 
 * cdef class PyTessBaseAPI:             # <<<<<<<<<<<<<<
 *     """Cython wrapper class around the C++ TessBaseAPI class.
 * 
 */
struct __pyx_obj_9tesserocr_PyTessBaseAPI {
  PyObject_HEAD
  struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *__pyx_vtab;
  tesseract::TessBaseAPI _baseapi;
  struct Pix *_pix;
};


/* "tesserocr.pyx":321
 * 
 * 
 * cdef pixa_to_list(Pixa *pixa):             # <<<<<<<<<<<<<<
 *     """Convert Pixa (Array of pixes and boxes) to list of pix, box tuples."""
 *     return zip((_pix_to_image(pix) for pix in pixa.pix[:pixa.n]), boxa_to_list(pixa.boxa))
 */
struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list {
  PyObject_HEAD
  struct Pixa *__pyx_v_pixa;
};


/* "tesserocr.pyx":323
 * cdef pixa_to_list(Pixa *pixa):
 *     """Convert Pixa (Array of pixes and boxes) to list of pix, box tuples."""
 *     return zip((_pix_to_image(pix) for pix in pixa.pix[:pixa.n]), boxa_to_list(pixa.boxa))             # <<<<<<<<<<<<<<
 * 
 * 
 */
struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list *__pyx_outer_scope;
  struct Pix *__pyx_v_pix;
  struct Pix **__pyx_t_0;
  struct Pix **__pyx_t_1;
  struct Pix **__pyx_t_2;
};


/* "tesserocr.pyx":558
 *         return self._piter.BlockType()
 * 
 *     def BlockPolygon(self):             # <<<<<<<<<<<<<<
 *         """Return the polygon outline of the current block.
 * 
 */
struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon {
  PyObject_HEAD
  struct Pta *__pyx_v_pta;
};


/* "tesserocr.pyx":573
 *             return None
 *         try:
 *             return zip((x for x in pta.x[:pta.n]), (y for y in pta.y[:pta.n]))             # <<<<<<<<<<<<<<
 *         finally:
 *             free(pta)
 */
struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *__pyx_outer_scope;
  PyObject *__pyx_v_x;
  float *__pyx_t_0;
  float *__pyx_t_1;
  float *__pyx_t_2;
};

struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *__pyx_outer_scope;
  PyObject *__pyx_v_y;
  float *__pyx_t_0;
  float *__pyx_t_1;
  float *__pyx_t_2;
};


/* "tesserocr.pyx":1004
 * 
 * 
 * def iterate_choices(citerator):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate :class:`PyChoiceIterator`."""
 *     yield citerator
 */
struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices {
  PyObject_HEAD
  PyObject *__pyx_v_citerator;
};


/* "tesserocr.pyx":1011
 * 
 * 
 * def iterate_level(iterator, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate a :class:`PyPageIterator`
 *     level.
 */
struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level {
  PyObject_HEAD
  PyObject *__pyx_v_iterator;
  enum tesseract::PageIteratorLevel __pyx_v_level;
};



/* "tesserocr.pyx":326
 * 
 * 
 * cdef class PyPageIterator:             # <<<<<<<<<<<<<<
 *     """Wrapper around Tesseract's ``PageIterator`` class.
 *     Returned by :meth:`PyTessBaseAPI.AnalyseLayout`.
 */

struct __pyx_vtabstruct_9tesserocr_PyPageIterator {
  struct __pyx_obj_9tesserocr_PyPageIterator *(*createPageIterator)(tesseract::PageIterator *);
};
static struct __pyx_vtabstruct_9tesserocr_PyPageIterator *__pyx_vtabptr_9tesserocr_PyPageIterator;


/* "tesserocr.pyx":726
 * 
 * 
 * cdef class PyLTRResultIterator(PyPageIterator):             # <<<<<<<<<<<<<<
 * 
 *     cdef LTRResultIterator *_ltrriter
 */

struct __pyx_vtabstruct_9tesserocr_PyLTRResultIterator {
  struct __pyx_vtabstruct_9tesserocr_PyPageIterator __pyx_base;
};
static struct __pyx_vtabstruct_9tesserocr_PyLTRResultIterator *__pyx_vtabptr_9tesserocr_PyLTRResultIterator;


/* "tesserocr.pyx":918
 * 
 * 
 * cdef class PyResultIterator(PyLTRResultIterator):             # <<<<<<<<<<<<<<
 *     """Wrapper around Tesseract's ``ResultIterator`` class.
 * 
 */

struct __pyx_vtabstruct_9tesserocr_PyResultIterator {
  struct __pyx_vtabstruct_9tesserocr_PyLTRResultIterator __pyx_base;
  struct __pyx_obj_9tesserocr_PyResultIterator *(*createResultIterator)(tesseract::ResultIterator *);
};
static struct __pyx_vtabstruct_9tesserocr_PyResultIterator *__pyx_vtabptr_9tesserocr_PyResultIterator;


/* "tesserocr.pyx":960
 * 
 * 
 * cdef class PyChoiceIterator:             # <<<<<<<<<<<<<<
 * 
 *     cdef ChoiceIterator *_citer
 */

struct __pyx_vtabstruct_9tesserocr_PyChoiceIterator {
  struct __pyx_obj_9tesserocr_PyChoiceIterator *(*create)(tesseract::ChoiceIterator *);
};
static struct __pyx_vtabstruct_9tesserocr_PyChoiceIterator *__pyx_vtabptr_9tesserocr_PyChoiceIterator;


/* "tesserocr.pyx":1020
 * 
 * 
 * cdef class PyTessBaseAPI:             # <<<<<<<<<<<<<<
 *     """Cython wrapper class around the C++ TessBaseAPI class.
 * 
 */

struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI {
  int (*_init_api)(struct __pyx_obj_9tesserocr_PyTessBaseAPI *, __pyx_t_9tesseract_cchar_t *, __pyx_t_9tesseract_cchar_t *, enum tesseract::OcrEngineMode, char **, int, GenericVector<STRING>  const *, GenericVector<STRING>  const *, bool, enum tesseract::PageSegMode);
  void (*_end_api)(struct __pyx_obj_9tesserocr_PyTessBaseAPI *);
  void (*_destroy_pix)(struct __pyx_obj_9tesserocr_PyTessBaseAPI *);
  tesseract::TessResultRenderer *(*_get_renderer)(struct __pyx_obj_9tesserocr_PyTessBaseAPI *, __pyx_t_9tesseract_cchar_t *);
};
static struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *__pyx_vtabptr_9tesserocr_PyTessBaseAPI;

/* --- Runtime support code (head) --- */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name);

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb);

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);

static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);

static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb);
static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb);

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x02070000
static CYTHON_INLINE PyObject* __Pyx_PyObject_LookupSpecial(PyObject* obj, PyObject* attr_name) {
    PyObject *res;
    PyTypeObject *tp = Py_TYPE(obj);
#if PY_MAJOR_VERSION < 3
    if (unlikely(PyInstance_Check(obj)))
        return __Pyx_PyObject_GetAttrStr(obj, attr_name);
#endif
    res = _PyType_Lookup(tp, attr_name);
    if (likely(res)) {
        descrgetfunc f = Py_TYPE(res)->tp_descr_get;
        if (!f) {
            Py_INCREF(res);
        } else {
            res = f(res, obj, (PyObject *)tp);
        }
    } else {
        PyErr_SetObject(PyExc_AttributeError, attr_name);
    }
    return res;
}
#else
#define __Pyx_PyObject_LookupSpecial(o,n) __Pyx_PyObject_GetAttrStr(o,n)
#endif

static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact);

static CYTHON_INLINE int __Pyx_IterFinish(void);

static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);

static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);

static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);

static CYTHON_INLINE int __Pyx_unpack_tuple2(PyObject* tuple, PyObject** value1, PyObject** value2,
                                             int is_tuple, int has_known_size, int decref_tuple);

static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
                                                   Py_ssize_t* p_orig_length, int* p_is_dict);
static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
                                              PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);

#ifndef __PYX_FORCE_INIT_THREADS
  #define __PYX_FORCE_INIT_THREADS 0
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace)\
    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
#endif

static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback, int nogil);

#include <string.h>

static int __Pyx_SetVtable(PyObject *dict, void *vtable);

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name);

typedef struct {
    int code_line;
    PyCodeObject* code_object;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

#include <new>

#ifndef __Pyx_CppExn2PyErr
#include <new>
#include <typeinfo>
#include <stdexcept>
#include <ios>
static void __Pyx_CppExn2PyErr() {
  try {
    if (PyErr_Occurred())
      ; // let the latest Python exn pass through and ignore the current one
    else
      throw;
  } catch (const std::bad_alloc& exn) {
    PyErr_SetString(PyExc_MemoryError, exn.what());
  } catch (const std::bad_cast& exn) {
    PyErr_SetString(PyExc_TypeError, exn.what());
  } catch (const std::domain_error& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::invalid_argument& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::ios_base::failure& exn) {
    PyErr_SetString(PyExc_IOError, exn.what());
  } catch (const std::out_of_range& exn) {
    PyErr_SetString(PyExc_IndexError, exn.what());
  } catch (const std::overflow_error& exn) {
    PyErr_SetString(PyExc_OverflowError, exn.what());
  } catch (const std::range_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::underflow_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::exception& exn) {
    PyErr_SetString(PyExc_RuntimeError, exn.what());
  }
  catch (...)
  {
    PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
  }
}
#endif

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_OcrEngineMode(enum tesseract::OcrEngineMode value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(enum tesseract::PageSegMode value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_PageIteratorLevel(enum tesseract::PageIteratorLevel value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__PolyBlockType(enum PolyBlockType value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_Orientation(enum tesseract::Orientation value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_WritingDirection(enum tesseract::WritingDirection value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_TextlineOrder(enum tesseract::TextlineOrder value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_ParagraphJustification(enum tesseract::ParagraphJustification value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__StrongScriptDirection(enum StrongScriptDirection value);

static CYTHON_INLINE enum tesseract::PageIteratorLevel __Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

static CYTHON_INLINE enum tesseract::PageSegMode __Pyx_PyInt_As_enum__tesseract_3a__3a_PageSegMode(PyObject *);

static CYTHON_INLINE enum tesseract::OcrEngineMode __Pyx_PyInt_As_enum__tesseract_3a__3a_OcrEngineMode(PyObject *);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

static PyObject* __pyx_convert__to_py_Box(struct Box s);
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);

static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);

typedef PyObject *(*__pyx_coroutine_body_t)(PyObject *, PyObject *);
typedef struct {
    PyObject_HEAD
    __pyx_coroutine_body_t body;
    PyObject *closure;
    PyObject *exc_type;
    PyObject *exc_value;
    PyObject *exc_traceback;
    PyObject *gi_weakreflist;
    PyObject *classobj;
    PyObject *yieldfrom;
    PyObject *gi_name;
    PyObject *gi_qualname;
    int resume_label;
    char is_running;
} __pyx_CoroutineObject;
static __pyx_CoroutineObject *__Pyx__Coroutine_New(PyTypeObject *type, __pyx_coroutine_body_t body,
                                                   PyObject *closure, PyObject *name, PyObject *qualname);
static int __Pyx_Coroutine_clear(PyObject *self);
#if 1 || PY_VERSION_HEX < 0x030300B0
static int __Pyx_PyGen_FetchStopIterationValue(PyObject **pvalue);
#else
#define __Pyx_PyGen_FetchStopIterationValue(pvalue) PyGen_FetchStopIterationValue(pvalue)
#endif

static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code);

static int __Pyx_patch_abc(void);

#define __Pyx_Generator_USED
static PyTypeObject *__pyx_GeneratorType = 0;
#define __Pyx_Generator_CheckExact(obj) (Py_TYPE(obj) == __pyx_GeneratorType)
#define __Pyx_Generator_New(body, closure, name, qualname)\
    __Pyx__Coroutine_New(__pyx_GeneratorType, body, closure, name, qualname)
static PyObject *__Pyx_Generator_Next(PyObject *self);
static int __pyx_Generator_init(void);

static int __Pyx_check_binary_version(void);

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);

static struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_f_9tesserocr_14PyPageIterator_createPageIterator(tesseract::PageIterator *__pyx_v_piter); /* proto*/
static struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_f_9tesserocr_16PyResultIterator_createResultIterator(tesseract::ResultIterator *__pyx_v_riter); /* proto*/
static struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_f_9tesserocr_16PyChoiceIterator_create(tesseract::ChoiceIterator *__pyx_v_citer); /* proto*/
static int __pyx_f_9tesserocr_13PyTessBaseAPI__init_api(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::OcrEngineMode __pyx_v_oem, char **__pyx_v_configs, int __pyx_v_configs_size, GenericVector<STRING>  const *__pyx_v_vars_vec, GenericVector<STRING>  const *__pyx_v_vars_vals, bool __pyx_v_set_only_non_debug_params, enum tesseract::PageSegMode __pyx_v_psm); /* proto*/
static void __pyx_f_9tesserocr_13PyTessBaseAPI__end_api(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto*/
static void __pyx_f_9tesserocr_13PyTessBaseAPI__destroy_pix(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto*/
static tesseract::TessResultRenderer *__pyx_f_9tesserocr_13PyTessBaseAPI__get_renderer(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_outputbase); /* proto*/

/* Module declarations from 'libcpp' */

/* Module declarations from 'tesseract' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libc.stdlib' */

/* Module declarations from 'tesserocr' */
static PyTypeObject *__pyx_ptype_9tesserocr__Enum = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_OEM = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_PSM = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_RIL = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_PT = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_Orientation = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_WritingDirection = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_TextlineOrder = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_Justification = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_DIR = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_PyPageIterator = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_PyLTRResultIterator = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_PyResultIterator = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_PyChoiceIterator = 0;
static PyTypeObject *__pyx_ptype_9tesserocr_PyTessBaseAPI = 0;
static PyTypeObject *__pyx_ptype_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list = 0;
static PyTypeObject *__pyx_ptype_9tesserocr___pyx_scope_struct_1_genexpr = 0;
static PyTypeObject *__pyx_ptype_9tesserocr___pyx_scope_struct_2_BlockPolygon = 0;
static PyTypeObject *__pyx_ptype_9tesserocr___pyx_scope_struct_3_genexpr = 0;
static PyTypeObject *__pyx_ptype_9tesserocr___pyx_scope_struct_4_genexpr = 0;
static PyTypeObject *__pyx_ptype_9tesserocr___pyx_scope_struct_5_iterate_choices = 0;
static PyTypeObject *__pyx_ptype_9tesserocr___pyx_scope_struct_6_iterate_level = 0;
static tesseract::TessBaseAPI __pyx_v_9tesserocr__api;
static PyObject *__pyx_v_9tesserocr__abs_path = 0;
static PyObject *__pyx_v_9tesserocr__lang_s = 0;
static __pyx_t_9tesseract_cchar_t *__pyx_v_9tesserocr__DEFAULT_PATH;
static __pyx_t_9tesseract_cchar_t *__pyx_v_9tesserocr__DEFAULT_LANG;
static PyObject *__pyx_f_9tesserocr__free_str(char *); /*proto*/
static PyObject *__pyx_f_9tesserocr__image_buffer(PyObject *); /*proto*/
static PyObject *__pyx_f_9tesserocr__pix_to_image(struct Pix *); /*proto*/
static PyObject *__pyx_f_9tesserocr_boxa_to_list(struct Boxa *); /*proto*/
static PyObject *__pyx_f_9tesserocr_pixa_to_list(struct Pixa *); /*proto*/
static char *__pyx_f_9tesserocr__image_to_text(struct Pix *, __pyx_t_9tesseract_cchar_t *, enum tesseract::PageSegMode const , __pyx_t_9tesseract_cchar_t *); /*proto*/
#define __Pyx_MODULE_NAME "tesserocr"
int __pyx_module_is_main_tesserocr = 0;

/* Implementation of 'tesserocr' */
static PyObject *__pyx_builtin_ImportError;
static PyObject *__pyx_builtin_staticmethod;
static PyObject *__pyx_builtin_TypeError;
static PyObject *__pyx_builtin_zip;
static PyObject *__pyx_builtin_RuntimeError;
static PyObject *__pyx_builtin_enumerate;
static PyObject *__pyx_builtin_xrange;
static char __pyx_k_h[] = "h";
static char __pyx_k_i[] = "i";
static char __pyx_k_v[] = "v";
static char __pyx_k_w[] = "w";
static char __pyx_k_x[] = "x";
static char __pyx_k_y[] = "y";
static char __pyx_k_os[] = "os";
static char __pyx_k_BMP[] = "BMP";
static char __pyx_k_MIX[] = "MIX";
static char __pyx_k_PIL[] = "PIL";
static char __pyx_k__29[] = " ";
static char __pyx_k_oem[] = "oem";
static char __pyx_k_pix[] = "pix";
static char __pyx_k_psm[] = "psm";
static char __pyx_k_raw[] = "raw";
static char __pyx_k_sep[] = "sep";
static char __pyx_k_top[] = "top";
static char __pyx_k_val[] = "val";
static char __pyx_k_zip[] = "zip";
static char __pyx_k_AUTO[] = "AUTO";
static char __pyx_k_LEFT[] = "LEFT";
static char __pyx_k_Next[] = "Next";
static char __pyx_k_PARA[] = "PARA";
static char __pyx_k_WORD[] = "WORD";
static char __pyx_k_args[] = "args";
static char __pyx_k_bold[] = "bold";
static char __pyx_k_buff[] = "buff";
static char __pyx_k_exit[] = "__exit__";
static char __pyx_k_init[] = "init";
static char __pyx_k_join[] = "join";
static char __pyx_k_lang[] = "lang";
static char __pyx_k_left[] = "left";
static char __pyx_k_load[] = "load";
static char __pyx_k_main[] = "__main__";
static char __pyx_k_name[] = "__name__";
static char __pyx_k_open[] = "open";
static char __pyx_k_path[] = "path";
static char __pyx_k_save[] = "save";
static char __pyx_k_send[] = "send";
static char __pyx_k_size[] = "size";
static char __pyx_k_test[] = "__test__";
static char __pyx_k_text[] = "text";
static char __pyx_k_word[] = "word";
static char __pyx_k_2_0_0[] = "2.0.0";
static char __pyx_k_BLOCK[] = "BLOCK";
static char __pyx_k_COUNT[] = "COUNT";
static char __pyx_k_Image[] = "Image";
static char __pyx_k_NOISE[] = "NOISE";
static char __pyx_k_RIGHT[] = "RIGHT";
static char __pyx_k_TABLE[] = "TABLE";
static char __pyx_k_close[] = "close";
static char __pyx_k_enter[] = "__enter__";
static char __pyx_k_image[] = "image";
static char __pyx_k_langs[] = "langs";
static char __pyx_k_level[] = "level";
static char __pyx_k_range[] = "range";
static char __pyx_k_serif[] = "serif";
static char __pyx_k_split[] = "split";
static char __pyx_k_throw[] = "throw";
static char __pyx_k_width[] = "width";
static char __pyx_k_CENTER[] = "CENTER";
static char __pyx_k_SYMBOL[] = "SYMBOL";
static char __pyx_k_exc_tb[] = "exc_tb";
static char __pyx_k_exc_tp[] = "exc_tp";
static char __pyx_k_format[] = "format";
static char __pyx_k_fromat[] = "fromat";
static char __pyx_k_height[] = "height";
static char __pyx_k_import[] = "__import__";
static char __pyx_k_italic[] = "italic";
static char __pyx_k_lept_v[] = "lept_v";
static char __pyx_k_libs_v[] = "libs_v";
static char __pyx_k_name_2[] = "name";
static char __pyx_k_pardir[] = "pardir";
static char __pyx_k_tess_v[] = "tess_v";
static char __pyx_k_xrange[] = "xrange";
static char __pyx_k_DEFAULT[] = "DEFAULT";
static char __pyx_k_NEUTRAL[] = "NEUTRAL";
static char __pyx_k_PAGE_UP[] = "PAGE_UP";
static char __pyx_k_UNKNOWN[] = "UNKNOWN";
static char __pyx_k_Version[] = "Version";
static char __pyx_k_abspath[] = "abspath";
static char __pyx_k_baseapi[] = "baseapi";
static char __pyx_k_closing[] = "closing";
static char __pyx_k_configs[] = "configs";
static char __pyx_k_element[] = "element";
static char __pyx_k_exc_val[] = "exc_val";
static char __pyx_k_font_id[] = "font_id";
static char __pyx_k_genexpr[] = "genexpr";
static char __pyx_k_os_path[] = "os.path";
static char __pyx_k_padding[] = "padding";
static char __pyx_k_paraids[] = "paraids";
static char __pyx_k_timeout[] = "timeout";
static char __pyx_k_version[] = "__version__";
static char __pyx_k_AUTO_OSD[] = "AUTO_OSD";
static char __pyx_k_EQUATION[] = "EQUATION";
static char __pyx_k_OSD_ONLY[] = "OSD_ONLY";
static char __pyx_k_RAW_LINE[] = "RAW_LINE";
static char __pyx_k_StringIO[] = "StringIO";
static char __pyx_k_TEXTLINE[] = "TEXTLINE";
static char __pyx_k_blockids[] = "blockids";
static char __pyx_k_dev_null[] = "/dev/null";
static char __pyx_k_filename[] = "filename";
static char __pyx_k_getvalue[] = "getvalue";
static char __pyx_k_iterator[] = "iterator";
static char __pyx_k_AUTO_ONLY[] = "AUTO_ONLY";
static char __pyx_k_CUBE_ONLY[] = "CUBE_ONLY";
static char __pyx_k_HORZ_LINE[] = "HORZ_LINE";
static char __pyx_k_PAGE_DOWN[] = "PAGE_DOWN";
static char __pyx_k_PAGE_LEFT[] = "PAGE_LEFT";
static char __pyx_k_TypeError[] = "TypeError";
static char __pyx_k_VERT_LINE[] = "VERT_LINE";
static char __pyx_k_cStringIO[] = "cStringIO";
static char __pyx_k_citerator[] = "citerator";
static char __pyx_k_enumerate[] = "enumerate";
static char __pyx_k_font_name[] = "font_name";
static char __pyx_k_imagedata[] = "imagedata";
static char __pyx_k_iteritems[] = "iteritems";
static char __pyx_k_monospace[] = "monospace";
static char __pyx_k_pointsize[] = "pointsize";
static char __pyx_k_raw_image[] = "raw_image";
static char __pyx_k_smallcaps[] = "smallcaps";
static char __pyx_k_tesseract[] = "tesseract {}\n {}\n  {}";
static char __pyx_k_tesserocr[] = "tesserocr";
static char __pyx_k_text_only[] = "text_only";
static char __pyx_k_variables[] = "variables";
static char __pyx_k_PAGE_RIGHT[] = "PAGE_RIGHT";
static char __pyx_k_contextlib[] = "contextlib";
static char __pyx_k_debug_file[] = "debug_file";
static char __pyx_k_outputbase[] = "outputbase";
static char __pyx_k_page_index[] = "page_index";
static char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
static char __pyx_k_underlined[] = "underlined";
static char __pyx_k_CIRCLE_WORD[] = "CIRCLE_WORD";
static char __pyx_k_GetUTF8Text[] = "GetUTF8Text";
static char __pyx_k_ImportError[] = "ImportError";
static char __pyx_k_SINGLE_CHAR[] = "SINGLE_CHAR";
static char __pyx_k_SINGLE_LINE[] = "SINGLE_LINE";
static char __pyx_k_SINGLE_WORD[] = "SINGLE_WORD";
static char __pyx_k_SPARSE_TEXT[] = "SPARSE_TEXT";
static char __pyx_k_raw_padding[] = "raw_padding";
static char __pyx_k_version_str[] = "version_str";
static char __pyx_k_CAPTION_TEXT[] = "CAPTION_TEXT";
static char __pyx_k_FLOWING_TEXT[] = "FLOWING_TEXT";
static char __pyx_k_HEADING_TEXT[] = "HEADING_TEXT";
static char __pyx_k_PULLOUT_TEXT[] = "PULLOUT_TEXT";
static char __pyx_k_RuntimeError[] = "RuntimeError";
static char __pyx_k_SINGLE_BLOCK[] = "SINGLE_BLOCK";
static char __pyx_k_file_to_text[] = "file_to_text";
static char __pyx_k_ltr_iterator[] = "ltr_iterator";
static char __pyx_k_retry_config[] = "retry_config";
static char __pyx_k_staticmethod[] = "staticmethod";
static char __pyx_k_FLOWING_IMAGE[] = "FLOWING_IMAGE";
static char __pyx_k_HEADING_IMAGE[] = "HEADING_IMAGE";
static char __pyx_k_LEFT_TO_RIGHT[] = "LEFT_TO_RIGHT";
static char __pyx_k_PULLOUT_IMAGE[] = "PULLOUT_IMAGE";
static char __pyx_k_RIGHT_TO_LEFT[] = "RIGHT_TO_LEFT";
static char __pyx_k_SINGLE_COLUMN[] = "SINGLE_COLUMN";
static char __pyx_k_TOP_TO_BOTTOM[] = "TOP_TO_BOTTOM";
static char __pyx_k_VERTICAL_TEXT[] = "VERTICAL_TEXT";
static char __pyx_k_get_languages[] = "get_languages";
static char __pyx_k_image_to_text[] = "image_to_text";
static char __pyx_k_iterate_level[] = "iterate_level";
static char __pyx_k_TESSERACT_ONLY[] = "TESSERACT_ONLY";
static char __pyx_k_bytes_per_line[] = "bytes_per_line";
static char __pyx_k_hocr_font_info[] = "hocr_font_info";
static char __pyx_k_original_image[] = "original_image";
static char __pyx_k_INLINE_EQUATION[] = "INLINE_EQUATION";
static char __pyx_k_SPARSE_TEXT_OSD[] = "SPARSE_TEXT_OSD";
static char __pyx_k_bytes_per_pixel[] = "bytes_per_pixel";
static char __pyx_k_iterate_choices[] = "iterate_choices";
static char __pyx_k_No_text_returned[] = "No text returned";
static char __pyx_k_tesseract_version[] = "tesseract_version";
static char __pyx_k_AllWordConfidences[] = "AllWordConfidences";
static char __pyx_k_include_lower_dots[] = "include_lower_dots";
static char __pyx_k_include_upper_dots[] = "include_upper_dots";
static char __pyx_k_Error_reading_image[] = "Error reading image";
static char __pyx_k_merge_similar_words[] = "merge_similar_words";
static char __pyx_k_tessedit_create_pdf[] = "tessedit_create_pdf";
static char __pyx_k_tessedit_create_txt[] = "tessedit_create_txt";
static char __pyx_k_tessedit_write_unlv[] = "tessedit_write_unlv";
static char __pyx_k_ClearPersistentCache[] = "ClearPersistentCache";
static char __pyx_k_Failed_to_read_image[] = "Failed to read image";
static char __pyx_k_No_renderers_enabled[] = "No renderers enabled";
static char __pyx_k_tessedit_create_hocr[] = "tessedit_create_hocr";
static char __pyx_k_Failed_to_read_picture[] = "Failed to read picture";
static char __pyx_k_SINGLE_BLOCK_VERT_TEXT[] = "SINGLE_BLOCK_VERT_TEXT";
static char __pyx_k_TESSERACT_CUBE_COMBINED[] = "TESSERACT_CUBE_COMBINED";
static char __pyx_k_tessedit_create_boxfile[] = "tessedit_create_boxfile";
static char __pyx_k_Failed_recognize_picture[] = "Failed recognize picture";
static char __pyx_k_Failed_to_initialize_API[] = "Failed to initialize API";
static char __pyx_k_Failed_to_recognize_image[] = "Failed to recognize image";
static char __pyx_k_set_only_non_debug_params[] = "set_only_non_debug_params";
static char __pyx_k_BlockPolygon_locals_genexpr[] = "BlockPolygon.<locals>.genexpr";
static char __pyx_k_pixa_to_list_locals_genexpr[] = "pixa_to_list.<locals>.genexpr";
static char __pyx_k_cannot_be_instantiated_from_Pyt[] = "{} cannot be instantiated from Python";
static char __pyx_k_home_fz_workspace_tesserocr_tes[] = "/home/fz/workspace/tesserocr/tesserocr.pyx";
static char __pyx_k_is_an_enum_and_cannot_be_instan[] = "{} is an enum and cannot be instantiated";
static char __pyx_k_ChoiceIterator_cannot_be_instant[] = "ChoiceIterator cannot be instantiated from Python";
static char __pyx_k_Failed_to_recognize_No_image_set[] = "Failed to recognize. No image set?";
static char __pyx_k_Python_wrapper_around_the_Tesser[] = "Python wrapper around the Tesseract-OCR 3.02+ C++ API\n\nThis module provides a wrapper class :class:`PyTessBaseAPI` to call\nTesseract API methods. See :class:`PyTessBaseAPI` for details.\n\nIn addition, helper functions are provided for ocr operations:\n\n>>> text = image_to_text(Image.open('./image.jpg').convert('L'), lang='eng')\n>>> text = file_to_text('./image.jpg', psm=PSM.AUTO)\n>>> print tesseract_version()\ntesseract 3.04.00\n    leptonica-1.72\n    libjpeg 8d (libjpeg-turbo 1.3.0) : libpng 1.2.51 : libtiff 4.0.3 : zlib 1.2.8\n>>> get_languages()\n('/usr/share/tesseract-ocr/tessdata/',\n ['eng', 'osd', 'equ'])\n";
static PyObject *__pyx_kp_s_2_0_0;
static PyObject *__pyx_n_s_AUTO;
static PyObject *__pyx_n_s_AUTO_ONLY;
static PyObject *__pyx_n_s_AUTO_OSD;
static PyObject *__pyx_n_s_AllWordConfidences;
static PyObject *__pyx_n_s_BLOCK;
static PyObject *__pyx_n_s_BMP;
static PyObject *__pyx_n_s_BlockPolygon_locals_genexpr;
static PyObject *__pyx_n_s_CAPTION_TEXT;
static PyObject *__pyx_n_s_CENTER;
static PyObject *__pyx_n_s_CIRCLE_WORD;
static PyObject *__pyx_n_s_COUNT;
static PyObject *__pyx_n_s_CUBE_ONLY;
static PyObject *__pyx_kp_s_ChoiceIterator_cannot_be_instant;
static PyObject *__pyx_n_s_ClearPersistentCache;
static PyObject *__pyx_n_s_DEFAULT;
static PyObject *__pyx_n_s_EQUATION;
static PyObject *__pyx_kp_s_Error_reading_image;
static PyObject *__pyx_n_s_FLOWING_IMAGE;
static PyObject *__pyx_n_s_FLOWING_TEXT;
static PyObject *__pyx_kp_s_Failed_recognize_picture;
static PyObject *__pyx_kp_s_Failed_to_initialize_API;
static PyObject *__pyx_kp_s_Failed_to_read_image;
static PyObject *__pyx_kp_s_Failed_to_read_picture;
static PyObject *__pyx_kp_s_Failed_to_recognize_No_image_set;
static PyObject *__pyx_kp_s_Failed_to_recognize_image;
static PyObject *__pyx_n_s_GetUTF8Text;
static PyObject *__pyx_n_s_HEADING_IMAGE;
static PyObject *__pyx_n_s_HEADING_TEXT;
static PyObject *__pyx_n_s_HORZ_LINE;
static PyObject *__pyx_n_s_INLINE_EQUATION;
static PyObject *__pyx_n_s_Image;
static PyObject *__pyx_n_s_ImportError;
static PyObject *__pyx_n_s_LEFT;
static PyObject *__pyx_n_s_LEFT_TO_RIGHT;
static PyObject *__pyx_n_s_MIX;
static PyObject *__pyx_n_s_NEUTRAL;
static PyObject *__pyx_n_s_NOISE;
static PyObject *__pyx_n_s_Next;
static PyObject *__pyx_kp_s_No_renderers_enabled;
static PyObject *__pyx_kp_s_No_text_returned;
static PyObject *__pyx_n_s_OSD_ONLY;
static PyObject *__pyx_n_s_PAGE_DOWN;
static PyObject *__pyx_n_s_PAGE_LEFT;
static PyObject *__pyx_n_s_PAGE_RIGHT;
static PyObject *__pyx_n_s_PAGE_UP;
static PyObject *__pyx_n_s_PARA;
static PyObject *__pyx_n_s_PIL;
static PyObject *__pyx_n_s_PULLOUT_IMAGE;
static PyObject *__pyx_n_s_PULLOUT_TEXT;
static PyObject *__pyx_n_s_RAW_LINE;
static PyObject *__pyx_n_s_RIGHT;
static PyObject *__pyx_n_s_RIGHT_TO_LEFT;
static PyObject *__pyx_n_s_RuntimeError;
static PyObject *__pyx_n_s_SINGLE_BLOCK;
static PyObject *__pyx_n_s_SINGLE_BLOCK_VERT_TEXT;
static PyObject *__pyx_n_s_SINGLE_CHAR;
static PyObject *__pyx_n_s_SINGLE_COLUMN;
static PyObject *__pyx_n_s_SINGLE_LINE;
static PyObject *__pyx_n_s_SINGLE_WORD;
static PyObject *__pyx_n_s_SPARSE_TEXT;
static PyObject *__pyx_n_s_SPARSE_TEXT_OSD;
static PyObject *__pyx_n_s_SYMBOL;
static PyObject *__pyx_n_s_StringIO;
static PyObject *__pyx_n_s_TABLE;
static PyObject *__pyx_n_s_TESSERACT_CUBE_COMBINED;
static PyObject *__pyx_n_s_TESSERACT_ONLY;
static PyObject *__pyx_n_s_TEXTLINE;
static PyObject *__pyx_n_s_TOP_TO_BOTTOM;
static PyObject *__pyx_n_s_TypeError;
static PyObject *__pyx_n_s_UNKNOWN;
static PyObject *__pyx_n_s_VERTICAL_TEXT;
static PyObject *__pyx_n_s_VERT_LINE;
static PyObject *__pyx_n_s_Version;
static PyObject *__pyx_n_s_WORD;
static PyObject *__pyx_kp_s__29;
static PyObject *__pyx_n_s_abspath;
static PyObject *__pyx_n_s_args;
static PyObject *__pyx_n_s_baseapi;
static PyObject *__pyx_n_s_blockids;
static PyObject *__pyx_n_s_bold;
static PyObject *__pyx_n_s_buff;
static PyObject *__pyx_n_s_bytes_per_line;
static PyObject *__pyx_n_s_bytes_per_pixel;
static PyObject *__pyx_n_s_cStringIO;
static PyObject *__pyx_kp_s_cannot_be_instantiated_from_Pyt;
static PyObject *__pyx_n_s_citerator;
static PyObject *__pyx_n_s_close;
static PyObject *__pyx_n_s_closing;
static PyObject *__pyx_n_s_configs;
static PyObject *__pyx_n_s_contextlib;
static PyObject *__pyx_n_s_element;
static PyObject *__pyx_n_s_enter;
static PyObject *__pyx_n_s_enumerate;
static PyObject *__pyx_n_s_exc_tb;
static PyObject *__pyx_n_s_exc_tp;
static PyObject *__pyx_n_s_exc_val;
static PyObject *__pyx_n_s_exit;
static PyObject *__pyx_n_s_file_to_text;
static PyObject *__pyx_n_s_filename;
static PyObject *__pyx_n_s_font_id;
static PyObject *__pyx_n_s_font_name;
static PyObject *__pyx_n_s_format;
static PyObject *__pyx_n_s_fromat;
static PyObject *__pyx_n_s_genexpr;
static PyObject *__pyx_n_s_get_languages;
static PyObject *__pyx_n_s_getvalue;
static PyObject *__pyx_n_s_h;
static PyObject *__pyx_n_s_height;
static PyObject *__pyx_kp_s_home_fz_workspace_tesserocr_tes;
static PyObject *__pyx_n_s_i;
static PyObject *__pyx_n_s_image;
static PyObject *__pyx_n_s_image_to_text;
static PyObject *__pyx_n_s_imagedata;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_include_lower_dots;
static PyObject *__pyx_n_s_include_upper_dots;
static PyObject *__pyx_n_s_init;
static PyObject *__pyx_kp_s_is_an_enum_and_cannot_be_instan;
static PyObject *__pyx_n_s_italic;
static PyObject *__pyx_n_s_iterate_choices;
static PyObject *__pyx_n_s_iterate_level;
static PyObject *__pyx_n_s_iterator;
static PyObject *__pyx_n_s_iteritems;
static PyObject *__pyx_n_s_join;
static PyObject *__pyx_n_s_lang;
static PyObject *__pyx_n_s_langs;
static PyObject *__pyx_n_s_left;
static PyObject *__pyx_n_s_lept_v;
static PyObject *__pyx_n_s_level;
static PyObject *__pyx_n_s_libs_v;
static PyObject *__pyx_n_s_load;
static PyObject *__pyx_n_s_ltr_iterator;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_merge_similar_words;
static PyObject *__pyx_n_s_monospace;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_name_2;
static PyObject *__pyx_n_s_oem;
static PyObject *__pyx_n_s_open;
static PyObject *__pyx_n_s_original_image;
static PyObject *__pyx_n_s_os;
static PyObject *__pyx_n_s_os_path;
static PyObject *__pyx_n_s_outputbase;
static PyObject *__pyx_n_s_padding;
static PyObject *__pyx_n_s_page_index;
static PyObject *__pyx_n_s_paraids;
static PyObject *__pyx_n_s_pardir;
static PyObject *__pyx_n_s_path;
static PyObject *__pyx_n_s_pix;
static PyObject *__pyx_n_s_pixa_to_list_locals_genexpr;
static PyObject *__pyx_n_s_pointsize;
static PyObject *__pyx_n_s_psm;
static PyObject *__pyx_n_s_pyx_vtable;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_raw;
static PyObject *__pyx_n_s_raw_image;
static PyObject *__pyx_n_s_raw_padding;
static PyObject *__pyx_n_s_retry_config;
static PyObject *__pyx_n_s_save;
static PyObject *__pyx_n_s_send;
static PyObject *__pyx_n_s_sep;
static PyObject *__pyx_n_s_serif;
static PyObject *__pyx_n_s_set_only_non_debug_params;
static PyObject *__pyx_n_s_size;
static PyObject *__pyx_n_s_smallcaps;
static PyObject *__pyx_n_s_split;
static PyObject *__pyx_n_s_staticmethod;
static PyObject *__pyx_n_s_tess_v;
static PyObject *__pyx_kp_u_tesseract;
static PyObject *__pyx_n_s_tesseract_version;
static PyObject *__pyx_n_s_tesserocr;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_text;
static PyObject *__pyx_n_s_text_only;
static PyObject *__pyx_n_s_throw;
static PyObject *__pyx_n_s_timeout;
static PyObject *__pyx_n_s_top;
static PyObject *__pyx_n_s_underlined;
static PyObject *__pyx_n_s_v;
static PyObject *__pyx_n_s_val;
static PyObject *__pyx_n_s_variables;
static PyObject *__pyx_n_s_version;
static PyObject *__pyx_n_s_version_str;
static PyObject *__pyx_n_s_w;
static PyObject *__pyx_n_s_width;
static PyObject *__pyx_n_s_word;
static PyObject *__pyx_n_s_x;
static PyObject *__pyx_n_s_xrange;
static PyObject *__pyx_n_s_y;
static PyObject *__pyx_n_s_zip;
static int __pyx_pf_9tesserocr_5_Enum___init__(struct __pyx_obj_9tesserocr__Enum *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_12pixa_to_list_genexpr(PyObject *__pyx_self); /* proto */
static int __pyx_pf_9tesserocr_14PyPageIterator___cinit__(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static void __pyx_pf_9tesserocr_14PyPageIterator_2__dealloc__(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static int __pyx_pf_9tesserocr_14PyPageIterator_4__init__(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_6Begin(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_8RestartParagraph(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_10IsWithinFirstTextlineOfParagraph(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_12RestartRow(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_14Next(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_16IsAtBeginningOf(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_18IsAtFinalElement(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level, enum tesseract::PageIteratorLevel __pyx_v_element); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_20SetBoundingBoxComponents(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, bool __pyx_v_include_upper_dots, bool __pyx_v_include_lower_dots); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_22BoundingBox(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level, int __pyx_v_padding); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_24BoundingBoxInternal(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_26Empty(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_28BlockType(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_12BlockPolygon_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_12BlockPolygon_3genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_30BlockPolygon(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_32GetBinaryImage(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_34GetImage(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level, int __pyx_v_padding, PyObject *__pyx_v_original_image); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_36Baseline(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_38Orientation(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_40ParagraphInfo(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self); /* proto */
static int __pyx_pf_9tesserocr_19PyLTRResultIterator___cinit__(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static void __pyx_pf_9tesserocr_19PyLTRResultIterator_2__dealloc__(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_4GetChoiceIterator(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_6GetUTF8Text(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_8SetLineSeparator(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_separator); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_10SetParagraphSeparator(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_separator); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_12Confidence(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_14WordFontAttributes(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_16WordRecognitionLanguage(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_18WordDirection(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_20WordIsFromDictionary(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_22WordIsNumeric(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_24HasBlamerInfo(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_26GetBlamerDebug(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_28GetBlamerMisadaptionDebug(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_30HasTruthString(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_32EquivalentToTruth(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_text); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_34WordTruthUTF8Text(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_36WordNormedUTF8Text(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_38WordLattice(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_40SymbolIsSuperscript(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_42SymbolIsSubscript(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_44SymbolIsDropcap(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self); /* proto */
static int __pyx_pf_9tesserocr_16PyResultIterator___cinit__(struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_self); /* proto */
static void __pyx_pf_9tesserocr_16PyResultIterator_2__dealloc__(struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_16PyResultIterator_4IsAtBeginningOf(struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_16PyResultIterator_6ParagraphIsLtr(struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_self); /* proto */
static int __pyx_pf_9tesserocr_16PyChoiceIterator___cinit__(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self); /* proto */
static void __pyx_pf_9tesserocr_16PyChoiceIterator_2__dealloc__(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self); /* proto */
static int __pyx_pf_9tesserocr_16PyChoiceIterator_4__init__(CYTHON_UNUSED struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_ltr_iterator); /* proto */
static PyObject *__pyx_pf_9tesserocr_16PyChoiceIterator_6__iter__(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_16PyChoiceIterator_8Next(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_16PyChoiceIterator_10GetUTF8Text(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_16PyChoiceIterator_12Confidence(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_iterate_choices(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_citerator); /* proto */
static PyObject *__pyx_pf_9tesserocr_3iterate_level(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_iterator, enum tesseract::PageIteratorLevel __pyx_v_level); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_Version(); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_2ClearPersistentCache(); /* proto */
static int __pyx_pf_9tesserocr_13PyTessBaseAPI_4__cinit__(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::PageSegMode __pyx_v_psm, bool __pyx_v_init); /* proto */
static void __pyx_pf_9tesserocr_13PyTessBaseAPI_6__dealloc__(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_8GetDatapath(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_10SetOutputName(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_12SetVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name, __pyx_t_9tesseract_cchar_t *__pyx_v_val); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_14SetDebugVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name, __pyx_t_9tesseract_cchar_t *__pyx_v_val); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_16GetIntVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_18GetBoolVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_20GetDoubleVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_22GetStringVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_24GetVariableAsString(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_26InitFull(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::OcrEngineMode __pyx_v_oem, PyObject *__pyx_v_configs, PyObject *__pyx_v_variables, bool __pyx_v_set_only_non_debug_params); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_28Init(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::OcrEngineMode __pyx_v_oem); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_30GetInitLanguagesAsString(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_32GetLoadedLanguages(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_34GetAvailableLanguages(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_36InitForAnalysePage(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_38ReadConfigFile(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_filename); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_40SetPageSegMode(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, enum tesseract::PageSegMode __pyx_v_psm); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_42GetPageSegMode(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_44TesseractRect(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cuchar_t *__pyx_v_imagedata, int __pyx_v_bytes_per_pixel, int __pyx_v_bytes_per_line, int __pyx_v_left, int __pyx_v_top, int __pyx_v_width, int __pyx_v_height); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_46ClearAdaptiveClassifier(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_48SetImageBytes(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cuchar_t *__pyx_v_imagedata, int __pyx_v_width, int __pyx_v_height, int __pyx_v_bytes_per_pixel, int __pyx_v_bytes_per_line); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_50SetImage(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, PyObject *__pyx_v_image); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_52SetImageFile(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_filename); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_54SetSourceResolution(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_ppi); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_56SetRectangle(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_left, int __pyx_v_top, int __pyx_v_width, int __pyx_v_height); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_58GetThresholdedImage(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_60GetRegions(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_62GetTextlines(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, bool __pyx_v_raw_image, int __pyx_v_raw_padding, bool __pyx_v_blockids, bool __pyx_v_paraids); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_64GetStrips(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, PyObject *__pyx_v_blockids); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_66GetWords(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_68GetConnectedComponents(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_70GetComponentImages(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level, bool __pyx_v_text_only, bool __pyx_v_raw_image, int __pyx_v_raw_padding, bool __pyx_v_blockids, bool __pyx_v_paraids); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_72GetThresholdedImageScaleFactor(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_74AnalyseLayout(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, bool __pyx_v_merge_similar_words); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_76Recognize(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_78RecognizeForChopTest(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_80ProcessPages(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_outputbase, __pyx_t_9tesseract_cchar_t *__pyx_v_filename, __pyx_t_9tesseract_cchar_t *__pyx_v_retry_config, int __pyx_v_timeout); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_82ProcessPage(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_outputbase, PyObject *__pyx_v_image, int __pyx_v_page_index, __pyx_t_9tesseract_cchar_t *__pyx_v_filename, __pyx_t_9tesseract_cchar_t *__pyx_v_retry_config, int __pyx_v_timeout); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_84GetIterator(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_86GetUTF8Text(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_88GetHOCRText(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_page_number); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_90GetBoxText(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_page_number); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_92GetUNLVText(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_94MeanTextConf(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_96AllWordConfidences(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_98MapWordConfidences(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_100AdaptToWordStr(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, enum tesseract::PageSegMode __pyx_v_psm, __pyx_t_9tesseract_cchar_t *__pyx_v_word); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_102Clear(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_104End(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_106IsValidCharacter(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_character); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_108GetTextDirection(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_110GetUnichar(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_unichar_id); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_112oem(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_114set_min_orientation_margin(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, double __pyx_v_margin); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_116__enter__(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_118__exit__(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_exc_tp, CYTHON_UNUSED PyObject *__pyx_v_exc_val, CYTHON_UNUSED PyObject *__pyx_v_exc_tb); /* proto */
static PyObject *__pyx_pf_9tesserocr_6image_to_text(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_image, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::PageSegMode __pyx_v_psm, __pyx_t_9tesseract_cchar_t *__pyx_v_path); /* proto */
static PyObject *__pyx_pf_9tesserocr_8file_to_text(CYTHON_UNUSED PyObject *__pyx_self, __pyx_t_9tesseract_cchar_t *__pyx_v_filename, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::PageSegMode __pyx_v_psm, __pyx_t_9tesseract_cchar_t *__pyx_v_path); /* proto */
static PyObject *__pyx_pf_9tesserocr_10tesseract_version(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9tesserocr_12get_languages(CYTHON_UNUSED PyObject *__pyx_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path); /* proto */
static PyObject *__pyx_tp_new_9tesserocr__Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_OEM(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_PSM(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_RIL(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_PT(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_Orientation(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_WritingDirection(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_TextlineOrder(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_Justification(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_DIR(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_PyPageIterator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_PyLTRResultIterator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_PyResultIterator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_PyChoiceIterator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr_PyTessBaseAPI(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_1_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_2_BlockPolygon(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_3_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_4_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_5_iterate_choices(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_6_iterate_level(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static __pyx_t_9tesseract_cchar_t *__pyx_k__6;
static __pyx_t_9tesseract_cchar_t *__pyx_k__7;
static enum tesseract::PageSegMode __pyx_k__8;
static PyObject *__pyx_k__9;
static PyObject *__pyx_k__10;
static __pyx_t_9tesseract_cchar_t *__pyx_k__11;
static __pyx_t_9tesseract_cchar_t *__pyx_k__12;
static enum tesseract::OcrEngineMode __pyx_k__13;
static __pyx_t_9tesseract_cchar_t *__pyx_k__15;
static __pyx_t_9tesseract_cchar_t *__pyx_k__16;
static enum tesseract::OcrEngineMode __pyx_k__17;
static __pyx_t_9tesseract_cchar_t *__pyx_k__31;
static enum tesseract::PageSegMode __pyx_k__32;
static __pyx_t_9tesseract_cchar_t *__pyx_k__33;
static __pyx_t_9tesseract_cchar_t *__pyx_k__36;
static enum tesseract::PageSegMode __pyx_k__37;
static __pyx_t_9tesseract_cchar_t *__pyx_k__38;
static __pyx_t_9tesseract_cchar_t *__pyx_k__41;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__14;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__19;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__21;
static PyObject *__pyx_tuple__22;
static PyObject *__pyx_tuple__23;
static PyObject *__pyx_tuple__24;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__26;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__30;
static PyObject *__pyx_tuple__34;
static PyObject *__pyx_tuple__35;
static PyObject *__pyx_tuple__39;
static PyObject *__pyx_tuple__40;
static PyObject *__pyx_tuple__42;
static PyObject *__pyx_tuple__44;
static PyObject *__pyx_tuple__48;
static PyObject *__pyx_tuple__50;
static PyObject *__pyx_tuple__52;
static PyObject *__pyx_tuple__54;
static PyObject *__pyx_codeobj__43;
static PyObject *__pyx_codeobj__45;
static PyObject *__pyx_codeobj__46;
static PyObject *__pyx_codeobj__47;
static PyObject *__pyx_codeobj__49;
static PyObject *__pyx_codeobj__51;
static PyObject *__pyx_codeobj__53;
static PyObject *__pyx_codeobj__55;

/* "tesserocr.pyx":52
 * cdef class _Enum:
 * 
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         raise TypeError('{} is an enum and cannot be instantiated'.fromat(type(self).__name__))
 * 
 */

/* Python wrapper */
static int __pyx_pw_9tesserocr_5_Enum_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_9tesserocr_5_Enum_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__init__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__init__", 0))) return -1;
  __pyx_r = __pyx_pf_9tesserocr_5_Enum___init__(((struct __pyx_obj_9tesserocr__Enum *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9tesserocr_5_Enum___init__(struct __pyx_obj_9tesserocr__Enum *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "tesserocr.pyx":53
 * 
 *     def __init__(self):
 *         raise TypeError('{} is an enum and cannot be instantiated'.fromat(type(self).__name__))             # <<<<<<<<<<<<<<
 * 
 * cdef class OEM(_Enum):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_is_an_enum_and_cannot_be_instan, __pyx_n_s_fromat); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":52
 * cdef class _Enum:
 * 
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         raise TypeError('{} is an enum and cannot be instantiated'.fromat(type(self).__name__))
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("tesserocr._Enum.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":283
 * 
 * 
 * cdef unicode _free_str(char *text):             # <<<<<<<<<<<<<<
 *     """Return unicode string and free the c pointer"""
 *     try:
 */

static PyObject *__pyx_f_9tesserocr__free_str(char *__pyx_v_text) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  char const *__pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_free_str", 0);

  /* "tesserocr.pyx":285
 * cdef unicode _free_str(char *text):
 *     """Return unicode string and free the c pointer"""
 *     try:             # <<<<<<<<<<<<<<
 *         return text
 *     finally:
 */
  /*try:*/ {

    /* "tesserocr.pyx":286
 *     """Return unicode string and free the c pointer"""
 *     try:
 *         return text             # <<<<<<<<<<<<<<
 *     finally:
 *         free(text)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_text); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 286; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = ((PyObject*)__pyx_t_1);
    __pyx_t_1 = 0;
    goto __pyx_L3_return;
  }

  /* "tesserocr.pyx":288
 *         return text
 *     finally:
 *         free(text)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L4_error:;
      __pyx_t_5 = 0; __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0)) __Pyx_ErrFetch(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_5);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __pyx_t_2 = __pyx_lineno; __pyx_t_3 = __pyx_clineno; __pyx_t_4 = __pyx_filename;
      {
        free(__pyx_v_text);
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      }
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_ErrRestore(__pyx_t_5, __pyx_t_6, __pyx_t_7);
      __pyx_t_5 = 0; __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0;
      __pyx_lineno = __pyx_t_2; __pyx_clineno = __pyx_t_3; __pyx_filename = __pyx_t_4;
      goto __pyx_L1_error;
    }
    __pyx_L3_return: {
      __pyx_t_11 = __pyx_r;
      __pyx_r = 0;
      free(__pyx_v_text);
      __pyx_r = __pyx_t_11;
      __pyx_t_11 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":283
 * 
 * 
 * cdef unicode _free_str(char *text):             # <<<<<<<<<<<<<<
 *     """Return unicode string and free the c pointer"""
 *     try:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr._free_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":291
 * 
 * 
 * cdef str _image_buffer(image):             # <<<<<<<<<<<<<<
 *     """Return raw bytes of a PIL Image"""
 *     with closing(StringIO()) as f:
 */

static PyObject *__pyx_f_9tesserocr__image_buffer(PyObject *__pyx_v_image) {
  PyObject *__pyx_v_f = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  Py_ssize_t __pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  int __pyx_t_13;
  PyObject *__pyx_t_14 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_image_buffer", 0);

  /* "tesserocr.pyx":293
 * cdef str _image_buffer(image):
 *     """Return raw bytes of a PIL Image"""
 *     with closing(StringIO()) as f:             # <<<<<<<<<<<<<<
 *         image.save(f, 'BMP')
 *         return f.getvalue()
 */
  /*with:*/ {
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_closing); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_StringIO); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (__pyx_t_5) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else {
      __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    if (!__pyx_t_4) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
      __pyx_t_3 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_6 = __Pyx_PyObject_LookupSpecial(__pyx_t_1, __pyx_n_s_exit); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = __Pyx_PyObject_LookupSpecial(__pyx_t_1, __pyx_n_s_enter); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (__pyx_t_3) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __pyx_t_2;
    __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    /*try:*/ {
      {
        __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
        __Pyx_XGOTREF(__pyx_t_7);
        __Pyx_XGOTREF(__pyx_t_8);
        __Pyx_XGOTREF(__pyx_t_9);
        /*try:*/ {
          __pyx_v_f = __pyx_t_5;
          __pyx_t_5 = 0;

          /* "tesserocr.pyx":294
 *     """Return raw bytes of a PIL Image"""
 *     with closing(StringIO()) as f:
 *         image.save(f, 'BMP')             # <<<<<<<<<<<<<<
 *         return f.getvalue()
 * 
 */
          __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_image, __pyx_n_s_save); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_2 = NULL;
          __pyx_t_10 = 0;
          if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
            __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
            if (likely(__pyx_t_2)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
              __Pyx_INCREF(__pyx_t_2);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_1, function);
              __pyx_t_10 = 1;
            }
          }
          __pyx_t_3 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          __Pyx_GOTREF(__pyx_t_3);
          if (__pyx_t_2) {
            __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2); __pyx_t_2 = NULL;
          }
          __Pyx_INCREF(__pyx_v_f);
          __Pyx_GIVEREF(__pyx_v_f);
          PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_10, __pyx_v_f);
          __Pyx_INCREF(__pyx_n_s_BMP);
          __Pyx_GIVEREF(__pyx_n_s_BMP);
          PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_10, __pyx_n_s_BMP);
          __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

          /* "tesserocr.pyx":295
 *     with closing(StringIO()) as f:
 *         image.save(f, 'BMP')
 *         return f.getvalue()             # <<<<<<<<<<<<<<
 * 
 * 
 */
          __Pyx_XDECREF(__pyx_r);
          __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_f, __pyx_n_s_getvalue); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_3 = NULL;
          if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
            __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
            if (likely(__pyx_t_3)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
              __Pyx_INCREF(__pyx_t_3);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_1, function);
            }
          }
          if (__pyx_t_3) {
            __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          } else {
            __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          }
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          if (!(likely(PyString_CheckExact(__pyx_t_5))||((__pyx_t_5) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_5)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          __pyx_r = ((PyObject*)__pyx_t_5);
          __pyx_t_5 = 0;
          goto __pyx_L11_try_return;

          /* "tesserocr.pyx":293
 * cdef str _image_buffer(image):
 *     """Return raw bytes of a PIL Image"""
 *     with closing(StringIO()) as f:             # <<<<<<<<<<<<<<
 *         image.save(f, 'BMP')
 *         return f.getvalue()
 */
        }
        __pyx_L7_error:;
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        /*except:*/ {
          __Pyx_AddTraceback("tesserocr._image_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
          if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_1, &__pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_2 = PyTuple_Pack(3, __pyx_t_5, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          __Pyx_GOTREF(__pyx_t_2);
          __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_2, NULL);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          __Pyx_GOTREF(__pyx_t_11);
          __pyx_t_12 = __Pyx_PyObject_IsTrue(__pyx_t_11);
          __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
          if (__pyx_t_12 < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          __pyx_t_13 = ((!(__pyx_t_12 != 0)) != 0);
          if (__pyx_t_13) {
            __Pyx_GIVEREF(__pyx_t_5);
            __Pyx_GIVEREF(__pyx_t_1);
            __Pyx_XGIVEREF(__pyx_t_3);
            __Pyx_ErrRestore(__pyx_t_5, __pyx_t_1, __pyx_t_3);
            __pyx_t_5 = 0; __pyx_t_1 = 0; __pyx_t_3 = 0; 
            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          }
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          goto __pyx_L8_exception_handled;
        }
        __pyx_L9_except_error:;
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
        goto __pyx_L1_error;
        __pyx_L11_try_return:;
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
        goto __pyx_L4_return;
        __pyx_L8_exception_handled:;
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
      }
    }
    /*finally:*/ {
      /*normal exit:*/{
        if (__pyx_t_6) {
          __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_tuple_, NULL);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_9);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        }
        goto __pyx_L6;
      }
      __pyx_L4_return: {
        __pyx_t_14 = __pyx_r;
        __pyx_r = 0;
        if (__pyx_t_6) {
          __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_tuple__2, NULL);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_9);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        }
        __pyx_r = __pyx_t_14;
        __pyx_t_14 = 0;
        goto __pyx_L0;
      }
      __pyx_L6:;
    }
    goto __pyx_L18;
    __pyx_L3_error:;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    goto __pyx_L1_error;
    __pyx_L18:;
  }

  /* "tesserocr.pyx":291
 * 
 * 
 * cdef str _image_buffer(image):             # <<<<<<<<<<<<<<
 *     """Return raw bytes of a PIL Image"""
 *     with closing(StringIO()) as f:
 */

  /* function exit code */
  __pyx_r = ((PyObject*)Py_None); __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("tesserocr._image_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_f);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":298
 * 
 * 
 * cdef _pix_to_image(Pix *pix):             # <<<<<<<<<<<<<<
 *     """Convert Pix object to PIL.Image."""
 *     cdef:
 */

static PyObject *__pyx_f_9tesserocr__pix_to_image(struct Pix *__pyx_v_pix) {
  unsigned char *__pyx_v_buff;
  size_t __pyx_v_size;
  PyObject *__pyx_v_f = NULL;
  PyObject *__pyx_v_image = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  int __pyx_t_13;
  int __pyx_t_14;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_pix_to_image", 0);

  /* "tesserocr.pyx":303
 *         unsigned char *buff
 *         size_t size
 *     pixWriteMemBmp(&buff, &size, pix)             # <<<<<<<<<<<<<<
 * 
 *     with closing(StringIO(<bytes>buff[:size])) as f:
 */
  pixWriteMemBmp((&__pyx_v_buff), (&__pyx_v_size), __pyx_v_pix);

  /* "tesserocr.pyx":305
 *     pixWriteMemBmp(&buff, &size, pix)
 * 
 *     with closing(StringIO(<bytes>buff[:size])) as f:             # <<<<<<<<<<<<<<
 *         image = Image.open(f)
 *         image.load()
 */
  /*with:*/ {
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_closing); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_StringIO); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_buff) + 0, __pyx_v_size - 0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __pyx_t_6 = NULL;
      __Pyx_INCREF(((PyObject*)__pyx_t_5));
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_5);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    if (!__pyx_t_4) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_3);
      __pyx_t_3 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_8 = __Pyx_PyObject_LookupSpecial(__pyx_t_1, __pyx_n_s_exit); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_7 = __Pyx_PyObject_LookupSpecial(__pyx_t_1, __pyx_n_s_enter); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_3 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    if (__pyx_t_3) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_7); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = __pyx_t_2;
    __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    /*try:*/ {
      {
        __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
        __Pyx_XGOTREF(__pyx_t_9);
        __Pyx_XGOTREF(__pyx_t_10);
        __Pyx_XGOTREF(__pyx_t_11);
        /*try:*/ {
          __pyx_v_f = __pyx_t_7;
          __pyx_t_7 = 0;

          /* "tesserocr.pyx":306
 * 
 *     with closing(StringIO(<bytes>buff[:size])) as f:
 *         image = Image.open(f)             # <<<<<<<<<<<<<<
 *         image.load()
 *     free(buff)
 */
          __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_Image); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __pyx_t_1 = NULL;
          if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
            __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
            if (likely(__pyx_t_1)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
              __Pyx_INCREF(__pyx_t_1);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_2, function);
            }
          }
          if (!__pyx_t_1) {
            __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_f); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
            __Pyx_GOTREF(__pyx_t_7);
          } else {
            __pyx_t_3 = PyTuple_New(1+1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
            __Pyx_GOTREF(__pyx_t_3);
            __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1); __pyx_t_1 = NULL;
            __Pyx_INCREF(__pyx_v_f);
            __Pyx_GIVEREF(__pyx_v_f);
            PyTuple_SET_ITEM(__pyx_t_3, 0+1, __pyx_v_f);
            __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
            __Pyx_GOTREF(__pyx_t_7);
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          }
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __pyx_v_image = __pyx_t_7;
          __pyx_t_7 = 0;

          /* "tesserocr.pyx":307
 *     with closing(StringIO(<bytes>buff[:size])) as f:
 *         image = Image.open(f)
 *         image.load()             # <<<<<<<<<<<<<<
 *     free(buff)
 * 
 */
          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_image, __pyx_n_s_load); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 307; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          __Pyx_GOTREF(__pyx_t_2);
          __pyx_t_3 = NULL;
          if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
            __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
            if (likely(__pyx_t_3)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
              __Pyx_INCREF(__pyx_t_3);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_2, function);
            }
          }
          if (__pyx_t_3) {
            __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 307; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          } else {
            __pyx_t_7 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 307; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
          }
          __Pyx_GOTREF(__pyx_t_7);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

          /* "tesserocr.pyx":305
 *     pixWriteMemBmp(&buff, &size, pix)
 * 
 *     with closing(StringIO(<bytes>buff[:size])) as f:             # <<<<<<<<<<<<<<
 *         image = Image.open(f)
 *         image.load()
 */
        }
        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
        goto __pyx_L14_try_end;
        __pyx_L7_error:;
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        /*except:*/ {
          __Pyx_AddTraceback("tesserocr._pix_to_image", __pyx_clineno, __pyx_lineno, __pyx_filename);
          if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_2, &__pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          __Pyx_GOTREF(__pyx_t_7);
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_1 = PyTuple_Pack(3, __pyx_t_7, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_1, NULL);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          if (unlikely(!__pyx_t_12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          __Pyx_GOTREF(__pyx_t_12);
          __pyx_t_13 = __Pyx_PyObject_IsTrue(__pyx_t_12);
          __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
          if (__pyx_t_13 < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          __pyx_t_14 = ((!(__pyx_t_13 != 0)) != 0);
          if (__pyx_t_14) {
            __Pyx_GIVEREF(__pyx_t_7);
            __Pyx_GIVEREF(__pyx_t_2);
            __Pyx_XGIVEREF(__pyx_t_3);
            __Pyx_ErrRestore(__pyx_t_7, __pyx_t_2, __pyx_t_3);
            __pyx_t_7 = 0; __pyx_t_2 = 0; __pyx_t_3 = 0; 
            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
          }
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          goto __pyx_L8_exception_handled;
        }
        __pyx_L9_except_error:;
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
        goto __pyx_L1_error;
        __pyx_L8_exception_handled:;
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
        __pyx_L14_try_end:;
      }
    }
    /*finally:*/ {
      /*normal exit:*/{
        if (__pyx_t_8) {
          __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_tuple__3, NULL);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_11);
          __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
        }
        goto __pyx_L6;
      }
      __pyx_L6:;
    }
    goto __pyx_L18;
    __pyx_L3_error:;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    goto __pyx_L1_error;
    __pyx_L18:;
  }

  /* "tesserocr.pyx":308
 *         image = Image.open(f)
 *         image.load()
 *     free(buff)             # <<<<<<<<<<<<<<
 * 
 *     return image
 */
  free(__pyx_v_buff);

  /* "tesserocr.pyx":310
 *     free(buff)
 * 
 *     return image             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(!__pyx_v_image)) { __Pyx_RaiseUnboundLocalError("image"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 310; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
  __Pyx_INCREF(__pyx_v_image);
  __pyx_r = __pyx_v_image;
  goto __pyx_L0;

  /* "tesserocr.pyx":298
 * 
 * 
 * cdef _pix_to_image(Pix *pix):             # <<<<<<<<<<<<<<
 *     """Convert Pix object to PIL.Image."""
 *     cdef:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("tesserocr._pix_to_image", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_f);
  __Pyx_XDECREF(__pyx_v_image);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":313
 * 
 * 
 * cdef boxa_to_list(Boxa *boxa):             # <<<<<<<<<<<<<<
 *     """Convert Boxa (boxes array) to list of boxes dicts."""
 *     boxes = []
 */

static PyObject *__pyx_f_9tesserocr_boxa_to_list(struct Boxa *__pyx_v_boxa) {
  PyObject *__pyx_v_boxes = NULL;
  struct Box *__pyx_v_box;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  struct Box **__pyx_t_2;
  struct Box **__pyx_t_3;
  struct Box **__pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("boxa_to_list", 0);

  /* "tesserocr.pyx":315
 * cdef boxa_to_list(Boxa *boxa):
 *     """Convert Boxa (boxes array) to list of boxes dicts."""
 *     boxes = []             # <<<<<<<<<<<<<<
 *     for box in boxa.box[:boxa.n]:
 *        boxes.append(box[0])
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_boxes = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":316
 *     """Convert Boxa (boxes array) to list of boxes dicts."""
 *     boxes = []
 *     for box in boxa.box[:boxa.n]:             # <<<<<<<<<<<<<<
 *        boxes.append(box[0])
 *     return boxes
 */
  __pyx_t_3 = (__pyx_v_boxa->box + __pyx_v_boxa->n);
  for (__pyx_t_4 = __pyx_v_boxa->box; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
    __pyx_t_2 = __pyx_t_4;
    __pyx_v_box = (__pyx_t_2[0]);

    /* "tesserocr.pyx":317
 *     boxes = []
 *     for box in boxa.box[:boxa.n]:
 *        boxes.append(box[0])             # <<<<<<<<<<<<<<
 *     return boxes
 * 
 */
    __pyx_t_1 = __pyx_convert__to_py_Box((__pyx_v_box[0])); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 317; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = __Pyx_PyList_Append(__pyx_v_boxes, __pyx_t_1); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 317; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "tesserocr.pyx":318
 *     for box in boxa.box[:boxa.n]:
 *        boxes.append(box[0])
 *     return boxes             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_boxes);
  __pyx_r = __pyx_v_boxes;
  goto __pyx_L0;

  /* "tesserocr.pyx":313
 * 
 * 
 * cdef boxa_to_list(Boxa *boxa):             # <<<<<<<<<<<<<<
 *     """Convert Boxa (boxes array) to list of boxes dicts."""
 *     boxes = []
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.boxa_to_list", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_boxes);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9tesserocr_12pixa_to_list_2generator2(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

/* "tesserocr.pyx":323
 * cdef pixa_to_list(Pixa *pixa):
 *     """Convert Pixa (Array of pixes and boxes) to list of pix, box tuples."""
 *     return zip((_pix_to_image(pix) for pix in pixa.pix[:pixa.n]), boxa_to_list(pixa.boxa))             # <<<<<<<<<<<<<<
 * 
 * 
 */

static PyObject *__pyx_pf_9tesserocr_12pixa_to_list_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *)__pyx_tp_new_9tesserocr___pyx_scope_struct_1_genexpr(__pyx_ptype_9tesserocr___pyx_scope_struct_1_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __Pyx_GOTREF(__pyx_cur_scope);
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9tesserocr_12pixa_to_list_2generator2, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_pixa_to_list_locals_genexpr); if (unlikely(!gen)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("tesserocr.pixa_to_list.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9tesserocr_12pixa_to_list_2generator2(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  struct Pix **__pyx_t_1;
  struct Pix **__pyx_t_2;
  struct Pix **__pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L6_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = (__pyx_cur_scope->__pyx_outer_scope->__pyx_v_pixa->pix + __pyx_cur_scope->__pyx_outer_scope->__pyx_v_pixa->n);
  for (__pyx_t_3 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_pixa->pix; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
    __pyx_t_1 = __pyx_t_3;
    __pyx_cur_scope->__pyx_v_pix = (__pyx_t_1[0]);
    __pyx_t_4 = __pyx_f_9tesserocr__pix_to_image(__pyx_cur_scope->__pyx_v_pix); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    __pyx_cur_scope->__pyx_t_0 = __pyx_t_1;
    __pyx_cur_scope->__pyx_t_1 = __pyx_t_2;
    __pyx_cur_scope->__pyx_t_2 = __pyx_t_3;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 1;
    return __pyx_r;
    __pyx_L6_resume_from_yield:;
    __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
    __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
    __pyx_t_3 = __pyx_cur_scope->__pyx_t_2;
    if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":321
 * 
 * 
 * cdef pixa_to_list(Pixa *pixa):             # <<<<<<<<<<<<<<
 *     """Convert Pixa (Array of pixes and boxes) to list of pix, box tuples."""
 *     return zip((_pix_to_image(pix) for pix in pixa.pix[:pixa.n]), boxa_to_list(pixa.boxa))
 */

static PyObject *__pyx_f_9tesserocr_pixa_to_list(struct Pixa *__pyx_v_pixa) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("pixa_to_list", 0);
  __pyx_cur_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list *)__pyx_tp_new_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list(__pyx_ptype_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __Pyx_RefNannyFinishContext();
    return 0;
  }
  __Pyx_GOTREF(__pyx_cur_scope);
  __pyx_cur_scope->__pyx_v_pixa = __pyx_v_pixa;

  /* "tesserocr.pyx":323
 * cdef pixa_to_list(Pixa *pixa):
 *     """Convert Pixa (Array of pixes and boxes) to list of pix, box tuples."""
 *     return zip((_pix_to_image(pix) for pix in pixa.pix[:pixa.n]), boxa_to_list(pixa.boxa))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_pf_9tesserocr_12pixa_to_list_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_f_9tesserocr_boxa_to_list(__pyx_cur_scope->__pyx_v_pixa->boxa); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_zip, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":321
 * 
 * 
 * cdef pixa_to_list(Pixa *pixa):             # <<<<<<<<<<<<<<
 *     """Convert Pixa (Array of pixes and boxes) to list of pix, box tuples."""
 *     return zip((_pix_to_image(pix) for pix in pixa.pix[:pixa.n]), boxa_to_list(pixa.boxa))
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("tesserocr.pixa_to_list", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":370
 * 
 *     @staticmethod
 *     cdef PyPageIterator createPageIterator(PageIterator *piter):             # <<<<<<<<<<<<<<
 *         cdef PyPageIterator pyiter = PyPageIterator.__new__(PyPageIterator)
 *         pyiter._piter = piter
 */

static struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_f_9tesserocr_14PyPageIterator_createPageIterator(tesseract::PageIterator *__pyx_v_piter) {
  struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_pyiter = 0;
  struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createPageIterator", 0);

  /* "tesserocr.pyx":371
 *     @staticmethod
 *     cdef PyPageIterator createPageIterator(PageIterator *piter):
 *         cdef PyPageIterator pyiter = PyPageIterator.__new__(PyPageIterator)             # <<<<<<<<<<<<<<
 *         pyiter._piter = piter
 *         return pyiter
 */
  __pyx_t_1 = __pyx_tp_new_9tesserocr_PyPageIterator(((PyTypeObject *)__pyx_ptype_9tesserocr_PyPageIterator), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (!(likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_9tesserocr_PyPageIterator)))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_pyiter = ((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":372
 *     cdef PyPageIterator createPageIterator(PageIterator *piter):
 *         cdef PyPageIterator pyiter = PyPageIterator.__new__(PyPageIterator)
 *         pyiter._piter = piter             # <<<<<<<<<<<<<<
 *         return pyiter
 * 
 */
  __pyx_v_pyiter->_piter = __pyx_v_piter;

  /* "tesserocr.pyx":373
 *         cdef PyPageIterator pyiter = PyPageIterator.__new__(PyPageIterator)
 *         pyiter._piter = piter
 *         return pyiter             # <<<<<<<<<<<<<<
 * 
 *     def __cinit__(self):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_pyiter));
  __pyx_r = __pyx_v_pyiter;
  goto __pyx_L0;

  /* "tesserocr.pyx":370
 * 
 *     @staticmethod
 *     cdef PyPageIterator createPageIterator(PageIterator *piter):             # <<<<<<<<<<<<<<
 *         cdef PyPageIterator pyiter = PyPageIterator.__new__(PyPageIterator)
 *         pyiter._piter = piter
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.createPageIterator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_pyiter);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":375
 *         return pyiter
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._piter = NULL
 * 
 */

/* Python wrapper */
static int __pyx_pw_9tesserocr_14PyPageIterator_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_9tesserocr_14PyPageIterator_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator___cinit__(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9tesserocr_14PyPageIterator___cinit__(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "tesserocr.pyx":376
 * 
 *     def __cinit__(self):
 *         self._piter = NULL             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->_piter = NULL;

  /* "tesserocr.pyx":375
 *         return pyiter
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._piter = NULL
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":378
 *         self._piter = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._piter != NULL:
 *             del self._piter
 */

/* Python wrapper */
static void __pyx_pw_9tesserocr_14PyPageIterator_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_9tesserocr_14PyPageIterator_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_9tesserocr_14PyPageIterator_2__dealloc__(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_9tesserocr_14PyPageIterator_2__dealloc__(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "tesserocr.pyx":379
 * 
 *     def __dealloc__(self):
 *         if self._piter != NULL:             # <<<<<<<<<<<<<<
 *             del self._piter
 * 
 */
  __pyx_t_1 = ((__pyx_v_self->_piter != NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":380
 *     def __dealloc__(self):
 *         if self._piter != NULL:
 *             del self._piter             # <<<<<<<<<<<<<<
 * 
 *     def __init__(self):
 */
    delete __pyx_v_self->_piter;

    /* "tesserocr.pyx":379
 * 
 *     def __dealloc__(self):
 *         if self._piter != NULL:             # <<<<<<<<<<<<<<
 *             del self._piter
 * 
 */
  }

  /* "tesserocr.pyx":378
 *         self._piter = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._piter != NULL:
 *             del self._piter
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "tesserocr.pyx":382
 *             del self._piter
 * 
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         raise TypeError('{} cannot be instantiated from Python'.format(type(self).__name__))
 * 
 */

/* Python wrapper */
static int __pyx_pw_9tesserocr_14PyPageIterator_5__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_9tesserocr_14PyPageIterator_5__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__init__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__init__", 0))) return -1;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_4__init__(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9tesserocr_14PyPageIterator_4__init__(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "tesserocr.pyx":383
 * 
 *     def __init__(self):
 *         raise TypeError('{} cannot be instantiated from Python'.format(type(self).__name__))             # <<<<<<<<<<<<<<
 * 
 *     def Begin(self):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_cannot_be_instantiated_from_Pyt, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":382
 *             del self._piter
 * 
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         raise TypeError('{} cannot be instantiated from Python'.format(type(self).__name__))
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":385
 *         raise TypeError('{} cannot be instantiated from Python'.format(type(self).__name__))
 * 
 *     def Begin(self):             # <<<<<<<<<<<<<<
 *         """Move the iterator to point to the start of the page to begin an iteration."""
 *         self._piter.Begin()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_7Begin(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_6Begin[] = "Move the iterator to point to the start of the page to begin an iteration.";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_7Begin(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Begin (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_6Begin(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_6Begin(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Begin", 0);

  /* "tesserocr.pyx":387
 *     def Begin(self):
 *         """Move the iterator to point to the start of the page to begin an iteration."""
 *         self._piter.Begin()             # <<<<<<<<<<<<<<
 * 
 *     def RestartParagraph(self):
 */
  __pyx_v_self->_piter->Begin();

  /* "tesserocr.pyx":385
 *         raise TypeError('{} cannot be instantiated from Python'.format(type(self).__name__))
 * 
 *     def Begin(self):             # <<<<<<<<<<<<<<
 *         """Move the iterator to point to the start of the page to begin an iteration."""
 *         self._piter.Begin()
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":389
 *         self._piter.Begin()
 * 
 *     def RestartParagraph(self):             # <<<<<<<<<<<<<<
 *         """Move the iterator to the beginning of the paragraph.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_9RestartParagraph(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_8RestartParagraph[] = "Move the iterator to the beginning of the paragraph.\n\n        This class implements this functionality by moving it to the zero indexed\n        blob of the first (leftmost) word on the first row of the paragraph.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_9RestartParagraph(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("RestartParagraph (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_8RestartParagraph(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_8RestartParagraph(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("RestartParagraph", 0);

  /* "tesserocr.pyx":395
 *         blob of the first (leftmost) word on the first row of the paragraph.
 *         """
 *         self._piter.RestartParagraph()             # <<<<<<<<<<<<<<
 * 
 *     def IsWithinFirstTextlineOfParagraph(self):
 */
  __pyx_v_self->_piter->RestartParagraph();

  /* "tesserocr.pyx":389
 *         self._piter.Begin()
 * 
 *     def RestartParagraph(self):             # <<<<<<<<<<<<<<
 *         """Move the iterator to the beginning of the paragraph.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":397
 *         self._piter.RestartParagraph()
 * 
 *     def IsWithinFirstTextlineOfParagraph(self):             # <<<<<<<<<<<<<<
 *         """Return whether this iterator points anywhere in the first textline of a
 *         paragraph."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_11IsWithinFirstTextlineOfParagraph(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_10IsWithinFirstTextlineOfParagraph[] = "Return whether this iterator points anywhere in the first textline of a\n        paragraph.";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_11IsWithinFirstTextlineOfParagraph(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("IsWithinFirstTextlineOfParagraph (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_10IsWithinFirstTextlineOfParagraph(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_10IsWithinFirstTextlineOfParagraph(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("IsWithinFirstTextlineOfParagraph", 0);

  /* "tesserocr.pyx":400
 *         """Return whether this iterator points anywhere in the first textline of a
 *         paragraph."""
 *         return self._piter.IsWithinFirstTextlineOfParagraph()             # <<<<<<<<<<<<<<
 * 
 *     def RestartRow(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_piter->IsWithinFirstTextlineOfParagraph()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":397
 *         self._piter.RestartParagraph()
 * 
 *     def IsWithinFirstTextlineOfParagraph(self):             # <<<<<<<<<<<<<<
 *         """Return whether this iterator points anywhere in the first textline of a
 *         paragraph."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.IsWithinFirstTextlineOfParagraph", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":402
 *         return self._piter.IsWithinFirstTextlineOfParagraph()
 * 
 *     def RestartRow(self):             # <<<<<<<<<<<<<<
 *         """Move the iterator to the beginning of the text line.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_13RestartRow(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_12RestartRow[] = "Move the iterator to the beginning of the text line.\n\n        This class implements this functionality by moving it to the zero indexed\n        blob of the first (leftmost) word of the row.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_13RestartRow(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("RestartRow (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_12RestartRow(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_12RestartRow(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("RestartRow", 0);

  /* "tesserocr.pyx":408
 *         blob of the first (leftmost) word of the row.
 *         """
 *         return self._piter.RestartRow()             # <<<<<<<<<<<<<<
 * 
 *     def Next(self, PageIteratorLevel level):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_void_to_None(__pyx_v_self->_piter->RestartRow()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":402
 *         return self._piter.IsWithinFirstTextlineOfParagraph()
 * 
 *     def RestartRow(self):             # <<<<<<<<<<<<<<
 *         """Move the iterator to the beginning of the text line.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.RestartRow", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":410
 *         return self._piter.RestartRow()
 * 
 *     def Next(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Move to the start of the next object at the given level in the
 *         page hierarchy, and returns false if the end of the page was reached.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_15Next(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_14Next[] = "Move to the start of the next object at the given level in the\n        page hierarchy, and returns false if the end of the page was reached.\n\n        .. note::\n\n            :attr:`RIL.SYMBOL` will skip non-text blocks, but all other\n            :class:`RIL` level values will visit each non-text block once.\n\n        Think of non text blocks as containing a single para, with a single line,\n        with a single imaginary word.\n\n        Calls to Next with different levels may be freely intermixed.\n        This function iterates words in right-to-left scripts correctly, if\n        the appropriate language has been loaded into Tesseract.\n\n        Args:\n            level (int): Iterator level. See :class:`RIL`.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_15Next(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Next (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 410; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.Next", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_14Next(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_14Next(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Next", 0);

  /* "tesserocr.pyx":429
 *             level (int): Iterator level. See :class:`RIL`.
 *         """
 *         return self._piter.Next(level)             # <<<<<<<<<<<<<<
 * 
 *     def IsAtBeginningOf(self, PageIteratorLevel level):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_piter->Next(__pyx_v_level)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":410
 *         return self._piter.RestartRow()
 * 
 *     def Next(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Move to the start of the next object at the given level in the
 *         page hierarchy, and returns false if the end of the page was reached.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.Next", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":431
 *         return self._piter.Next(level)
 * 
 *     def IsAtBeginningOf(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return whether the iterator is at the start of an object at the given
 *         level.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_17IsAtBeginningOf(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_16IsAtBeginningOf[] = "Return whether the iterator is at the start of an object at the given\n        level.\n\n        For instance, suppose an iterator it is pointed to the first symbol of the\n        first word of the third line of the second paragraph of the first block in\n        a page, then::\n\n            it.IsAtBeginningOf(RIL.BLOCK) is False\n            it.IsAtBeginningOf(RIL.PARA) is False\n            it.IsAtBeginningOf(RIL.TEXTLINE) is True\n            it.IsAtBeginningOf(RIL.WORD) is True\n            it.IsAtBeginningOf(RIL.SYMBOL) is True\n\n        Args:\n            level (int): Iterator level. See :class:`RIL`.\n\n        Returns:\n            bool: ``True`` if the iterator is at the start of an object at the\n                given level.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_17IsAtBeginningOf(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("IsAtBeginningOf (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 431; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.IsAtBeginningOf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_16IsAtBeginningOf(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_16IsAtBeginningOf(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("IsAtBeginningOf", 0);

  /* "tesserocr.pyx":452
 *                 given level.
 *         """
 *         return self._piter.IsAtBeginningOf(level)             # <<<<<<<<<<<<<<
 * 
 *     def IsAtFinalElement(self, PageIteratorLevel level, PageIteratorLevel element):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_piter->IsAtBeginningOf(__pyx_v_level)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":431
 *         return self._piter.Next(level)
 * 
 *     def IsAtBeginningOf(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return whether the iterator is at the start of an object at the given
 *         level.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.IsAtBeginningOf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":454
 *         return self._piter.IsAtBeginningOf(level)
 * 
 *     def IsAtFinalElement(self, PageIteratorLevel level, PageIteratorLevel element):             # <<<<<<<<<<<<<<
 *         """Return whether the iterator is positioned at the last element in a
 *         given level. (e.g. the last word in a line, the last line in a block)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_19IsAtFinalElement(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_18IsAtFinalElement[] = "Return whether the iterator is positioned at the last element in a\n        given level. (e.g. the last word in a line, the last line in a block)\n\n        Here's some two-paragraph example\n        text:\n\n            It starts off innocuously\n            enough but quickly turns bizarre.\n            The author inserts a cornucopia\n            of words to guard against confused\n            references.\n\n        Now take an iterator ``it`` pointed to the start of \"bizarre.\"\n\n            it.IsAtFinalElement(RIL.PARA, RIL.SYMBOL) = False\n            it.IsAtFinalElement(RIL.PARA, RIL.WORD) = True\n            it.IsAtFinalElement(RIL.BLOCK, RIL.WORD) = False\n\n        Args:\n            level (int): Iterator Level. See :class:`RIL`.\n            element (int): Element level. See :class:`RIL`.\n\n        Returns:\n            bool: ``True`` if the iterator is positioned at the last element\n                in the given level.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_19IsAtFinalElement(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  enum tesseract::PageIteratorLevel __pyx_v_element;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("IsAtFinalElement (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_level,&__pyx_n_s_element,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_level)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_element)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("IsAtFinalElement", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "IsAtFinalElement") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(values[0])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_element = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(values[1])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("IsAtFinalElement", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.IsAtFinalElement", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_18IsAtFinalElement(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), __pyx_v_level, __pyx_v_element);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_18IsAtFinalElement(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level, enum tesseract::PageIteratorLevel __pyx_v_element) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("IsAtFinalElement", 0);

  /* "tesserocr.pyx":481
 *                 in the given level.
 *         """
 *         return self._piter.IsAtFinalElement(level, element)             # <<<<<<<<<<<<<<
 * 
 *     def SetBoundingBoxComponents(self, bool include_upper_dots, bool include_lower_dots):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_piter->IsAtFinalElement(__pyx_v_level, __pyx_v_element)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 481; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":454
 *         return self._piter.IsAtBeginningOf(level)
 * 
 *     def IsAtFinalElement(self, PageIteratorLevel level, PageIteratorLevel element):             # <<<<<<<<<<<<<<
 *         """Return whether the iterator is positioned at the last element in a
 *         given level. (e.g. the last word in a line, the last line in a block)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.IsAtFinalElement", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":483
 *         return self._piter.IsAtFinalElement(level, element)
 * 
 *     def SetBoundingBoxComponents(self, bool include_upper_dots, bool include_lower_dots):             # <<<<<<<<<<<<<<
 *         """Controls what to include in a bounding box. Bounding boxes of all levels
 *         between :attr:`RIL.WORD` and :attr:`RIL.BLOCK` can include or exclude potential diacritics.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_21SetBoundingBoxComponents(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_20SetBoundingBoxComponents[] = "Controls what to include in a bounding box. Bounding boxes of all levels\n        between :attr:`RIL.WORD` and :attr:`RIL.BLOCK` can include or exclude potential diacritics.\n\n        Between layout analysis and recognition, it isn't known where all\n        diacritics belong, so this control is used to include or exclude some\n        diacritics that are above or below the main body of the word. In most cases\n        where the placement is obvious, and after recognition, it doesn't make as\n        much difference, as the diacritics will already be included in the word.\n\n        Args:\n            include_upper_dots (bool): Include upper dots.\n            include_lower_dots (bool): Include lower dots.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_21SetBoundingBoxComponents(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  bool __pyx_v_include_upper_dots;
  bool __pyx_v_include_lower_dots;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetBoundingBoxComponents (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_include_upper_dots,&__pyx_n_s_include_lower_dots,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_include_upper_dots)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_include_lower_dots)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetBoundingBoxComponents", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SetBoundingBoxComponents") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_include_upper_dots = __Pyx_PyObject_IsTrue(values[0]); if (unlikely((__pyx_v_include_upper_dots == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_include_lower_dots = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_include_lower_dots == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetBoundingBoxComponents", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.SetBoundingBoxComponents", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_20SetBoundingBoxComponents(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), __pyx_v_include_upper_dots, __pyx_v_include_lower_dots);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_20SetBoundingBoxComponents(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, bool __pyx_v_include_upper_dots, bool __pyx_v_include_lower_dots) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetBoundingBoxComponents", 0);

  /* "tesserocr.pyx":497
 *             include_lower_dots (bool): Include lower dots.
 *         """
 *         self._piter.SetBoundingBoxComponents(include_upper_dots, include_lower_dots)             # <<<<<<<<<<<<<<
 * 
 *     def BoundingBox(self, PageIteratorLevel level, const int padding=0):
 */
  __pyx_v_self->_piter->SetBoundingBoxComponents(__pyx_v_include_upper_dots, __pyx_v_include_lower_dots);

  /* "tesserocr.pyx":483
 *         return self._piter.IsAtFinalElement(level, element)
 * 
 *     def SetBoundingBoxComponents(self, bool include_upper_dots, bool include_lower_dots):             # <<<<<<<<<<<<<<
 *         """Controls what to include in a bounding box. Bounding boxes of all levels
 *         between :attr:`RIL.WORD` and :attr:`RIL.BLOCK` can include or exclude potential diacritics.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":499
 *         self._piter.SetBoundingBoxComponents(include_upper_dots, include_lower_dots)
 * 
 *     def BoundingBox(self, PageIteratorLevel level, const int padding=0):             # <<<<<<<<<<<<<<
 *         """Return the bounding rectangle of the current object at the given level.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_23BoundingBox(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_22BoundingBox[] = "Return the bounding rectangle of the current object at the given level.\n\n        See comment on coordinate system above.\n\n        Args:\n            level (int): Page Iteration Level. See :class:`RIL` for avaialbe levels.\n\n        Kwargs:\n            padding (int): The padding argument to :meth:`GetImage` can be used to expand\n                the image to include more foreground pixels.\n\n        Returns:\n            tuple or None if there is no such object at the current position.\n                The returned bounding box (left, top, right and bottom values\n                respectively) is guaranteed to match the size and position of\n                the image returned by :meth:`GetBinaryImage`, but may clip\n                foreground pixels from a grey image.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_23BoundingBox(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_v_padding;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("BoundingBox (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_level,&__pyx_n_s_padding,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_level)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_padding);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "BoundingBox") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(values[0])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[1]) {
      __pyx_v_padding = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_padding == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_padding = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("BoundingBox", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.BoundingBox", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_22BoundingBox(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), __pyx_v_level, __pyx_v_padding);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_22BoundingBox(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level, int __pyx_v_padding) {
  int __pyx_v_left;
  int __pyx_v_top;
  int __pyx_v_right;
  int __pyx_v_bottom;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("BoundingBox", 0);

  /* "tesserocr.pyx":519
 *         """
 *         cdef int left, top, right, bottom
 *         if not self._piter.BoundingBox(level, padding, &left, &top, &right, &bottom):             # <<<<<<<<<<<<<<
 *             return None
 *         return left, top, right, bottom
 */
  __pyx_t_1 = ((!(__pyx_v_self->_piter->BoundingBox(__pyx_v_level, __pyx_v_padding, (&__pyx_v_left), (&__pyx_v_top), (&__pyx_v_right), (&__pyx_v_bottom)) != 0)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":520
 *         cdef int left, top, right, bottom
 *         if not self._piter.BoundingBox(level, padding, &left, &top, &right, &bottom):
 *             return None             # <<<<<<<<<<<<<<
 *         return left, top, right, bottom
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":519
 *         """
 *         cdef int left, top, right, bottom
 *         if not self._piter.BoundingBox(level, padding, &left, &top, &right, &bottom):             # <<<<<<<<<<<<<<
 *             return None
 *         return left, top, right, bottom
 */
  }

  /* "tesserocr.pyx":521
 *         if not self._piter.BoundingBox(level, padding, &left, &top, &right, &bottom):
 *             return None
 *         return left, top, right, bottom             # <<<<<<<<<<<<<<
 * 
 *     def BoundingBoxInternal(self, PageIteratorLevel level):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_left); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 521; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_top); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 521; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_right); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 521; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_bottom); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 521; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = PyTuple_New(4); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 521; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_6, 3, __pyx_t_5);
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_t_5 = 0;
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":499
 *         self._piter.SetBoundingBoxComponents(include_upper_dots, include_lower_dots)
 * 
 *     def BoundingBox(self, PageIteratorLevel level, const int padding=0):             # <<<<<<<<<<<<<<
 *         """Return the bounding rectangle of the current object at the given level.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.BoundingBox", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":523
 *         return left, top, right, bottom
 * 
 *     def BoundingBoxInternal(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return the bounding rectangle of the object in a coordinate system of the
 *         working image rectangle having its origin at (rect_left_, rect_top_) with
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_25BoundingBoxInternal(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_24BoundingBoxInternal[] = "Return the bounding rectangle of the object in a coordinate system of the\n        working image rectangle having its origin at (rect_left_, rect_top_) with\n        respect to the original image and is scaled by a factor scale_.\n\n        Args:\n            level (int): Page Iteration Level. See :class:`RIL` for avaialbe levels.\n\n        Returns:\n            tuple or None if there is no such object at the current position.\n                The returned bounding box is represented as a tuple with\n                left, top, right and bottom values respectively.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_25BoundingBoxInternal(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("BoundingBoxInternal (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.BoundingBoxInternal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_24BoundingBoxInternal(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_24BoundingBoxInternal(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  int __pyx_v_left;
  int __pyx_v_top;
  int __pyx_v_right;
  int __pyx_v_bottom;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("BoundingBoxInternal", 0);

  /* "tesserocr.pyx":537
 *         """
 *         cdef int left, top, right, bottom
 *         if not self._piter.BoundingBoxInternal(level, &left, &top, &right, &bottom):             # <<<<<<<<<<<<<<
 *             return None
 *         return left, top, right, bottom
 */
  __pyx_t_1 = ((!(__pyx_v_self->_piter->BoundingBoxInternal(__pyx_v_level, (&__pyx_v_left), (&__pyx_v_top), (&__pyx_v_right), (&__pyx_v_bottom)) != 0)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":538
 *         cdef int left, top, right, bottom
 *         if not self._piter.BoundingBoxInternal(level, &left, &top, &right, &bottom):
 *             return None             # <<<<<<<<<<<<<<
 *         return left, top, right, bottom
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":537
 *         """
 *         cdef int left, top, right, bottom
 *         if not self._piter.BoundingBoxInternal(level, &left, &top, &right, &bottom):             # <<<<<<<<<<<<<<
 *             return None
 *         return left, top, right, bottom
 */
  }

  /* "tesserocr.pyx":539
 *         if not self._piter.BoundingBoxInternal(level, &left, &top, &right, &bottom):
 *             return None
 *         return left, top, right, bottom             # <<<<<<<<<<<<<<
 * 
 *     def Empty(self, PageIteratorLevel level):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_left); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_top); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_right); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_bottom); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = PyTuple_New(4); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_6, 3, __pyx_t_5);
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_t_5 = 0;
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":523
 *         return left, top, right, bottom
 * 
 *     def BoundingBoxInternal(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return the bounding rectangle of the object in a coordinate system of the
 *         working image rectangle having its origin at (rect_left_, rect_top_) with
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.BoundingBoxInternal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":541
 *         return left, top, right, bottom
 * 
 *     def Empty(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return whether there is no object of a given level.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_27Empty(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_26Empty[] = "Return whether there is no object of a given level.\n\n        Args:\n            level (int): Iterator level. See :class:`RIL`.\n\n        Returns:\n            bool: ``True`` if there is no object at the given level.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_27Empty(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Empty (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.Empty", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_26Empty(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_26Empty(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Empty", 0);

  /* "tesserocr.pyx":550
 *             bool: ``True`` if there is no object at the given level.
 *         """
 *         return self._piter.Empty(level)             # <<<<<<<<<<<<<<
 * 
 *     def BlockType(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_piter->Empty(__pyx_v_level)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":541
 *         return left, top, right, bottom
 * 
 *     def Empty(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return whether there is no object of a given level.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.Empty", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":552
 *         return self._piter.Empty(level)
 * 
 *     def BlockType(self):             # <<<<<<<<<<<<<<
 *         """Return the type of the current block. See :class:`PolyBlockType` for
 *         possible types.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_29BlockType(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_28BlockType[] = "Return the type of the current block. See :class:`PolyBlockType` for\n        possible types.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_29BlockType(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("BlockType (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_28BlockType(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_28BlockType(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("BlockType", 0);

  /* "tesserocr.pyx":556
 *         possible types.
 *         """
 *         return self._piter.BlockType()             # <<<<<<<<<<<<<<
 * 
 *     def BlockPolygon(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_enum__PolyBlockType(__pyx_v_self->_piter->BlockType()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 556; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":552
 *         return self._piter.Empty(level)
 * 
 *     def BlockType(self):             # <<<<<<<<<<<<<<
 *         """Return the type of the current block. See :class:`PolyBlockType` for
 *         possible types.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.BlockType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":558
 *         return self._piter.BlockType()
 * 
 *     def BlockPolygon(self):             # <<<<<<<<<<<<<<
 *         """Return the polygon outline of the current block.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_31BlockPolygon(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_30BlockPolygon[] = "Return the polygon outline of the current block.\n\n        Returns:\n            list or None: list of points (x,y tuples) which list the vertices\n                of the polygon, and the last edge is the line segment between the last\n                point and the first point.\n\n                ``None`` will be returned if the iterator is\n                at the end of the document or layout analysis was not used.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_31BlockPolygon(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("BlockPolygon (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_30BlockPolygon(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9tesserocr_14PyPageIterator_12BlockPolygon_2generator3(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

/* "tesserocr.pyx":573
 *             return None
 *         try:
 *             return zip((x for x in pta.x[:pta.n]), (y for y in pta.y[:pta.n]))             # <<<<<<<<<<<<<<
 *         finally:
 *             free(pta)
 */

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_12BlockPolygon_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *)__pyx_tp_new_9tesserocr___pyx_scope_struct_3_genexpr(__pyx_ptype_9tesserocr___pyx_scope_struct_3_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __Pyx_GOTREF(__pyx_cur_scope);
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9tesserocr_14PyPageIterator_12BlockPolygon_2generator3, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_BlockPolygon_locals_genexpr); if (unlikely(!gen)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.BlockPolygon.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9tesserocr_14PyPageIterator_12BlockPolygon_2generator3(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  float *__pyx_t_1;
  float *__pyx_t_2;
  float *__pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L6_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = (__pyx_cur_scope->__pyx_outer_scope->__pyx_v_pta->x + __pyx_cur_scope->__pyx_outer_scope->__pyx_v_pta->n);
  for (__pyx_t_3 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_pta->x; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_4 = PyFloat_FromDouble((__pyx_t_1[0])); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_x);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_x, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_cur_scope->__pyx_v_x);
    __pyx_r = __pyx_cur_scope->__pyx_v_x;
    __pyx_cur_scope->__pyx_t_0 = __pyx_t_1;
    __pyx_cur_scope->__pyx_t_1 = __pyx_t_2;
    __pyx_cur_scope->__pyx_t_2 = __pyx_t_3;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 1;
    return __pyx_r;
    __pyx_L6_resume_from_yield:;
    __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
    __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
    __pyx_t_3 = __pyx_cur_scope->__pyx_t_2;
    if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9tesserocr_14PyPageIterator_12BlockPolygon_5generator4(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_12BlockPolygon_3genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *)__pyx_tp_new_9tesserocr___pyx_scope_struct_4_genexpr(__pyx_ptype_9tesserocr___pyx_scope_struct_4_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __Pyx_GOTREF(__pyx_cur_scope);
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9tesserocr_14PyPageIterator_12BlockPolygon_5generator4, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_BlockPolygon_locals_genexpr); if (unlikely(!gen)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.BlockPolygon.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9tesserocr_14PyPageIterator_12BlockPolygon_5generator4(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  float *__pyx_t_1;
  float *__pyx_t_2;
  float *__pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L6_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = (__pyx_cur_scope->__pyx_outer_scope->__pyx_v_pta->y + __pyx_cur_scope->__pyx_outer_scope->__pyx_v_pta->n);
  for (__pyx_t_3 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_pta->y; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_4 = PyFloat_FromDouble((__pyx_t_1[0])); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_y);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_y, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_cur_scope->__pyx_v_y);
    __pyx_r = __pyx_cur_scope->__pyx_v_y;
    __pyx_cur_scope->__pyx_t_0 = __pyx_t_1;
    __pyx_cur_scope->__pyx_t_1 = __pyx_t_2;
    __pyx_cur_scope->__pyx_t_2 = __pyx_t_3;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 1;
    return __pyx_r;
    __pyx_L6_resume_from_yield:;
    __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
    __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
    __pyx_t_3 = __pyx_cur_scope->__pyx_t_2;
    if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":558
 *         return self._piter.BlockType()
 * 
 *     def BlockPolygon(self):             # <<<<<<<<<<<<<<
 *         """Return the polygon outline of the current block.
 * 
 */

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_30BlockPolygon(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  char const *__pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("BlockPolygon", 0);
  __pyx_cur_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *)__pyx_tp_new_9tesserocr___pyx_scope_struct_2_BlockPolygon(__pyx_ptype_9tesserocr___pyx_scope_struct_2_BlockPolygon, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __Pyx_GOTREF(__pyx_cur_scope);

  /* "tesserocr.pyx":569
 *                 at the end of the document or layout analysis was not used.
 *         """
 *         cdef Pta *pta = self._piter.BlockPolygon()             # <<<<<<<<<<<<<<
 *         if pta == NULL:
 *             return None
 */
  __pyx_cur_scope->__pyx_v_pta = __pyx_v_self->_piter->BlockPolygon();

  /* "tesserocr.pyx":570
 *         """
 *         cdef Pta *pta = self._piter.BlockPolygon()
 *         if pta == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         try:
 */
  __pyx_t_1 = ((__pyx_cur_scope->__pyx_v_pta == NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":571
 *         cdef Pta *pta = self._piter.BlockPolygon()
 *         if pta == NULL:
 *             return None             # <<<<<<<<<<<<<<
 *         try:
 *             return zip((x for x in pta.x[:pta.n]), (y for y in pta.y[:pta.n]))
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":570
 *         """
 *         cdef Pta *pta = self._piter.BlockPolygon()
 *         if pta == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         try:
 */
  }

  /* "tesserocr.pyx":572
 *         if pta == NULL:
 *             return None
 *         try:             # <<<<<<<<<<<<<<
 *             return zip((x for x in pta.x[:pta.n]), (y for y in pta.y[:pta.n]))
 *         finally:
 */
  /*try:*/ {

    /* "tesserocr.pyx":573
 *             return None
 *         try:
 *             return zip((x for x in pta.x[:pta.n]), (y for y in pta.y[:pta.n]))             # <<<<<<<<<<<<<<
 *         finally:
 *             free(pta)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __pyx_pf_9tesserocr_14PyPageIterator_12BlockPolygon_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __pyx_pf_9tesserocr_14PyPageIterator_12BlockPolygon_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
    __pyx_t_2 = 0;
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_zip, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L4_return;
  }

  /* "tesserocr.pyx":575
 *             return zip((x for x in pta.x[:pta.n]), (y for y in pta.y[:pta.n]))
 *         finally:
 *             free(pta)             # <<<<<<<<<<<<<<
 * 
 *     def GetBinaryImage(self, PageIteratorLevel level):
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L5_error:;
      __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10) < 0)) __Pyx_ErrFetch(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_13);
      __pyx_t_5 = __pyx_lineno; __pyx_t_6 = __pyx_clineno; __pyx_t_7 = __pyx_filename;
      {
        free(__pyx_cur_scope->__pyx_v_pta);
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_XGIVEREF(__pyx_t_12);
        __Pyx_XGIVEREF(__pyx_t_13);
        __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);
      }
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_ErrRestore(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0;
      __pyx_lineno = __pyx_t_5; __pyx_clineno = __pyx_t_6; __pyx_filename = __pyx_t_7;
      goto __pyx_L1_error;
    }
    __pyx_L4_return: {
      __pyx_t_13 = __pyx_r;
      __pyx_r = 0;
      free(__pyx_cur_scope->__pyx_v_pta);
      __pyx_r = __pyx_t_13;
      __pyx_t_13 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":558
 *         return self._piter.BlockType()
 * 
 *     def BlockPolygon(self):             # <<<<<<<<<<<<<<
 *         """Return the polygon outline of the current block.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.BlockPolygon", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":577
 *             free(pta)
 * 
 *     def GetBinaryImage(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return a binary image of the current object at the given level.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_33GetBinaryImage(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_32GetBinaryImage[] = "Return a binary image of the current object at the given level.\n\n        The position and size match the return from :meth:`BoundingBoxInternal`, and so\n        this could be upscaled with respect to the original input image.\n\n        Args:\n            level (int): Iterator level. See :class:`RIL`.\n\n        Returns:\n            :class:`PIL.Image`: Image object or None if no image is returned.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_33GetBinaryImage(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetBinaryImage (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.GetBinaryImage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_32GetBinaryImage(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_32GetBinaryImage(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  struct Pix *__pyx_v_pix;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  char const *__pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetBinaryImage", 0);

  /* "tesserocr.pyx":589
 *             :class:`PIL.Image`: Image object or None if no image is returned.
 *         """
 *         cdef Pix *pix = self._piter.GetBinaryImage(level)             # <<<<<<<<<<<<<<
 *         if pix == NULL:
 *             return None
 */
  __pyx_v_pix = __pyx_v_self->_piter->GetBinaryImage(__pyx_v_level);

  /* "tesserocr.pyx":590
 *         """
 *         cdef Pix *pix = self._piter.GetBinaryImage(level)
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         try:
 */
  __pyx_t_1 = ((__pyx_v_pix == NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":591
 *         cdef Pix *pix = self._piter.GetBinaryImage(level)
 *         if pix == NULL:
 *             return None             # <<<<<<<<<<<<<<
 *         try:
 *             return _pix_to_image(pix)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":590
 *         """
 *         cdef Pix *pix = self._piter.GetBinaryImage(level)
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         try:
 */
  }

  /* "tesserocr.pyx":592
 *         if pix == NULL:
 *             return None
 *         try:             # <<<<<<<<<<<<<<
 *             return _pix_to_image(pix)
 *         finally:
 */
  /*try:*/ {

    /* "tesserocr.pyx":593
 *             return None
 *         try:
 *             return _pix_to_image(pix)             # <<<<<<<<<<<<<<
 *         finally:
 *             pixDestroy(&pix)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __pyx_f_9tesserocr__pix_to_image(__pyx_v_pix); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 593; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L4_return;
  }

  /* "tesserocr.pyx":595
 *             return _pix_to_image(pix)
 *         finally:
 *             pixDestroy(&pix)             # <<<<<<<<<<<<<<
 * 
 *     def GetImage(self, PageIteratorLevel level, int padding, original_image):
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L5_error:;
      __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8) < 0)) __Pyx_ErrFetch(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __pyx_t_3 = __pyx_lineno; __pyx_t_4 = __pyx_clineno; __pyx_t_5 = __pyx_filename;
      {
        pixDestroy((&__pyx_v_pix));
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
      }
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ErrRestore(__pyx_t_6, __pyx_t_7, __pyx_t_8);
      __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0;
      __pyx_lineno = __pyx_t_3; __pyx_clineno = __pyx_t_4; __pyx_filename = __pyx_t_5;
      goto __pyx_L1_error;
    }
    __pyx_L4_return: {
      __pyx_t_11 = __pyx_r;
      __pyx_r = 0;
      pixDestroy((&__pyx_v_pix));
      __pyx_r = __pyx_t_11;
      __pyx_t_11 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":577
 *             free(pta)
 * 
 *     def GetBinaryImage(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return a binary image of the current object at the given level.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.GetBinaryImage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":597
 *             pixDestroy(&pix)
 * 
 *     def GetImage(self, PageIteratorLevel level, int padding, original_image):             # <<<<<<<<<<<<<<
 *         """Return an image of the current object at the given level in greyscale
 *         if available in the input.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_35GetImage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_34GetImage[] = "Return an image of the current object at the given level in greyscale\n        if available in the input.\n\n        To guarantee a binary image use :meth:`BinaryImage`.\n\n        Args:\n            level (int): Iterator level. See :class:`RIL`.\n            padding (int): Padding by which to expand the returned image.\n\n                .. note::\n\n                    in order to give the best possible image, the bounds are\n                    expanded slightly over the binary connected component, by\n                    the supplied padding, so the top-left position of the returned\n                    image is returned along with the image (left, top respectively).\n                    These will most likely not match the coordinates returned by\n                    :meth:`BoundingBox`.\n\n            original_image (:class:`PIL.Image`): Original image.\n                If you do not supply an original image (None), you will get a binary one.\n\n        Returns:\n            :class:`PIL.Image`: The image of the current object at the given level in greyscale.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_35GetImage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_v_padding;
  PyObject *__pyx_v_original_image = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetImage (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_level,&__pyx_n_s_padding,&__pyx_n_s_original_image,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_level)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_padding)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("GetImage", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_original_image)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("GetImage", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "GetImage") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(values[0])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_padding = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_padding == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_original_image = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("GetImage", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.GetImage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_34GetImage(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), __pyx_v_level, __pyx_v_padding, __pyx_v_original_image);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_34GetImage(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level, int __pyx_v_padding, PyObject *__pyx_v_original_image) {
  struct Pix *__pyx_v_pix;
  struct Pix *__pyx_v_opix;
  size_t __pyx_v_size;
  __pyx_t_9tesseract_cuchar_t *__pyx_v_buff;
  int __pyx_v_left;
  int __pyx_v_top;
  PyObject *__pyx_v_raw = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  __pyx_t_9tesseract_cuchar_t *__pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  int __pyx_t_9;
  char const *__pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetImage", 0);

  /* "tesserocr.pyx":624
 *         cdef:
 *             Pix *pix
 *             Pix *opix = NULL             # <<<<<<<<<<<<<<
 *             size_t size
 *             cuchar_t *buff
 */
  __pyx_v_opix = NULL;

  /* "tesserocr.pyx":629
 *             int left
 *             int top
 *         if original_image:             # <<<<<<<<<<<<<<
 *             raw = _image_buffer(original_image)
 *             size = len(raw)
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_original_image); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 629; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "tesserocr.pyx":630
 *             int top
 *         if original_image:
 *             raw = _image_buffer(original_image)             # <<<<<<<<<<<<<<
 *             size = len(raw)
 *             buff = raw
 */
    __pyx_t_2 = __pyx_f_9tesserocr__image_buffer(__pyx_v_original_image); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_v_raw = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "tesserocr.pyx":631
 *         if original_image:
 *             raw = _image_buffer(original_image)
 *             size = len(raw)             # <<<<<<<<<<<<<<
 *             buff = raw
 *             opix = pixReadMemBmp(buff, size)
 */
    __pyx_t_3 = PyObject_Length(__pyx_v_raw); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 631; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_size = __pyx_t_3;

    /* "tesserocr.pyx":632
 *             raw = _image_buffer(original_image)
 *             size = len(raw)
 *             buff = raw             # <<<<<<<<<<<<<<
 *             opix = pixReadMemBmp(buff, size)
 *         pix = self._piter.GetImage(level, padding, opix, &left, &top)
 */
    __pyx_t_4 = __Pyx_PyObject_AsUString(__pyx_v_raw); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_buff = __pyx_t_4;

    /* "tesserocr.pyx":633
 *             size = len(raw)
 *             buff = raw
 *             opix = pixReadMemBmp(buff, size)             # <<<<<<<<<<<<<<
 *         pix = self._piter.GetImage(level, padding, opix, &left, &top)
 *         try:
 */
    __pyx_v_opix = pixReadMemBmp(__pyx_v_buff, __pyx_v_size);

    /* "tesserocr.pyx":629
 *             int left
 *             int top
 *         if original_image:             # <<<<<<<<<<<<<<
 *             raw = _image_buffer(original_image)
 *             size = len(raw)
 */
  }

  /* "tesserocr.pyx":634
 *             buff = raw
 *             opix = pixReadMemBmp(buff, size)
 *         pix = self._piter.GetImage(level, padding, opix, &left, &top)             # <<<<<<<<<<<<<<
 *         try:
 *             return _pix_to_image(pix), left, top
 */
  __pyx_v_pix = __pyx_v_self->_piter->GetImage(__pyx_v_level, __pyx_v_padding, __pyx_v_opix, (&__pyx_v_left), (&__pyx_v_top));

  /* "tesserocr.pyx":635
 *             opix = pixReadMemBmp(buff, size)
 *         pix = self._piter.GetImage(level, padding, opix, &left, &top)
 *         try:             # <<<<<<<<<<<<<<
 *             return _pix_to_image(pix), left, top
 *         finally:
 */
  /*try:*/ {

    /* "tesserocr.pyx":636
 *         pix = self._piter.GetImage(level, padding, opix, &left, &top)
 *         try:
 *             return _pix_to_image(pix), left, top             # <<<<<<<<<<<<<<
 *         finally:
 *             pixDestroy(&pix)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __pyx_f_9tesserocr__pix_to_image(__pyx_v_pix); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 636; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_left); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 636; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_top); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 636; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = PyTuple_New(3); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 636; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_t_6);
    __pyx_t_2 = 0;
    __pyx_t_5 = 0;
    __pyx_t_6 = 0;
    __pyx_r = __pyx_t_7;
    __pyx_t_7 = 0;
    goto __pyx_L4_return;
  }

  /* "tesserocr.pyx":638
 *             return _pix_to_image(pix), left, top
 *         finally:
 *             pixDestroy(&pix)             # <<<<<<<<<<<<<<
 *             if opix != NULL:
 *                 pixDestroy(&opix)
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L5_error:;
      __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_14, &__pyx_t_15, &__pyx_t_16);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13) < 0)) __Pyx_ErrFetch(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_14);
      __Pyx_XGOTREF(__pyx_t_15);
      __Pyx_XGOTREF(__pyx_t_16);
      __pyx_t_8 = __pyx_lineno; __pyx_t_9 = __pyx_clineno; __pyx_t_10 = __pyx_filename;
      {
        pixDestroy((&__pyx_v_pix));

        /* "tesserocr.pyx":639
 *         finally:
 *             pixDestroy(&pix)
 *             if opix != NULL:             # <<<<<<<<<<<<<<
 *                 pixDestroy(&opix)
 * 
 */
        __pyx_t_1 = ((__pyx_v_opix != NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":640
 *             pixDestroy(&pix)
 *             if opix != NULL:
 *                 pixDestroy(&opix)             # <<<<<<<<<<<<<<
 * 
 *     def Baseline(self, PageIteratorLevel level):
 */
          pixDestroy((&__pyx_v_opix));

          /* "tesserocr.pyx":639
 *         finally:
 *             pixDestroy(&pix)
 *             if opix != NULL:             # <<<<<<<<<<<<<<
 *                 pixDestroy(&opix)
 * 
 */
        }
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_14);
        __Pyx_XGIVEREF(__pyx_t_15);
        __Pyx_XGIVEREF(__pyx_t_16);
        __Pyx_ExceptionReset(__pyx_t_14, __pyx_t_15, __pyx_t_16);
      }
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_XGIVEREF(__pyx_t_13);
      __Pyx_ErrRestore(__pyx_t_11, __pyx_t_12, __pyx_t_13);
      __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
      __pyx_lineno = __pyx_t_8; __pyx_clineno = __pyx_t_9; __pyx_filename = __pyx_t_10;
      goto __pyx_L1_error;
    }
    __pyx_L4_return: {
      __pyx_t_16 = __pyx_r;
      __pyx_r = 0;

      /* "tesserocr.pyx":638
 *             return _pix_to_image(pix), left, top
 *         finally:
 *             pixDestroy(&pix)             # <<<<<<<<<<<<<<
 *             if opix != NULL:
 *                 pixDestroy(&opix)
 */
      pixDestroy((&__pyx_v_pix));

      /* "tesserocr.pyx":639
 *         finally:
 *             pixDestroy(&pix)
 *             if opix != NULL:             # <<<<<<<<<<<<<<
 *                 pixDestroy(&opix)
 * 
 */
      __pyx_t_1 = ((__pyx_v_opix != NULL) != 0);
      if (__pyx_t_1) {

        /* "tesserocr.pyx":640
 *             pixDestroy(&pix)
 *             if opix != NULL:
 *                 pixDestroy(&opix)             # <<<<<<<<<<<<<<
 * 
 *     def Baseline(self, PageIteratorLevel level):
 */
        pixDestroy((&__pyx_v_opix));

        /* "tesserocr.pyx":639
 *         finally:
 *             pixDestroy(&pix)
 *             if opix != NULL:             # <<<<<<<<<<<<<<
 *                 pixDestroy(&opix)
 * 
 */
      }
      __pyx_r = __pyx_t_16;
      __pyx_t_16 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":597
 *             pixDestroy(&pix)
 * 
 *     def GetImage(self, PageIteratorLevel level, int padding, original_image):             # <<<<<<<<<<<<<<
 *         """Return an image of the current object at the given level in greyscale
 *         if available in the input.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.GetImage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_raw);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":642
 *                 pixDestroy(&opix)
 * 
 *     def Baseline(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return the baseline of the current object at the given level.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_37Baseline(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_36Baseline[] = "Return the baseline of the current object at the given level.\n\n        The baseline is the line that passes through (x1, y1) and (x2, y2).\n\n        .. warning::\n\n            with vertical text, baselines may be vertical!\n\n        Args:\n            level (int): Iterator level. See :class:`RIL`.\n\n        Returns:\n            tuple: Baseline points' coordinates (x1, y1), (x2, y2).\n                ``None`` if there is no baseline at the current position.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_37Baseline(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Baseline (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyPageIterator.Baseline", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_36Baseline(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_36Baseline(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  int __pyx_v_x1;
  int __pyx_v_y1;
  int __pyx_v_x2;
  int __pyx_v_y2;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Baseline", 0);

  /* "tesserocr.pyx":659
 *         """
 *         cdef int x1, y1, x2, y2
 *         if not self._piter.Baseline(level, &x1, &y1, &x2, &y2):             # <<<<<<<<<<<<<<
 *             return False
 *         return (x1, y1), (x2, y2)
 */
  __pyx_t_1 = ((!(__pyx_v_self->_piter->Baseline(__pyx_v_level, (&__pyx_v_x1), (&__pyx_v_y1), (&__pyx_v_x2), (&__pyx_v_y2)) != 0)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":660
 *         cdef int x1, y1, x2, y2
 *         if not self._piter.Baseline(level, &x1, &y1, &x2, &y2):
 *             return False             # <<<<<<<<<<<<<<
 *         return (x1, y1), (x2, y2)
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;

    /* "tesserocr.pyx":659
 *         """
 *         cdef int x1, y1, x2, y2
 *         if not self._piter.Baseline(level, &x1, &y1, &x2, &y2):             # <<<<<<<<<<<<<<
 *             return False
 *         return (x1, y1), (x2, y2)
 */
  }

  /* "tesserocr.pyx":661
 *         if not self._piter.Baseline(level, &x1, &y1, &x2, &y2):
 *             return False
 *         return (x1, y1), (x2, y2)             # <<<<<<<<<<<<<<
 * 
 *     def Orientation(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_x1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_y1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_x2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_y2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
  __pyx_t_3 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_5);
  __pyx_t_4 = 0;
  __pyx_t_5 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":642
 *                 pixDestroy(&opix)
 * 
 *     def Baseline(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return the baseline of the current object at the given level.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.Baseline", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":663
 *         return (x1, y1), (x2, y2)
 * 
 *     def Orientation(self):             # <<<<<<<<<<<<<<
 *         """Return the orientation for the block the iterator points to.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_39Orientation(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_38Orientation[] = "Return the orientation for the block the iterator points to.\n\n        Returns:\n            tuple: The following values are returned respectively::\n\n                orientation: See :class:`Orientation`\n                writing_direction: See :class:`WritingDirection`\n                textline_order: See :class:`TextlineOrder`\n                deskew_angle: After rotating the block so the text orientation is\n                    upright, how many radians does one have to rotate the\n                    block anti-clockwise for it to be level?\n                        -Pi/4 <= deskew_angle <= Pi/4\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_39Orientation(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Orientation (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_38Orientation(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_38Orientation(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  enum tesseract::Orientation __pyx_v_orientation;
  enum tesseract::WritingDirection __pyx_v_writing_direction;
  enum tesseract::TextlineOrder __pyx_v_textline_order;
  float __pyx_v_deskew_angle;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Orientation", 0);

  /* "tesserocr.pyx":682
 *             TessTextlineOrder textline_order
 *             float deskew_angle
 *         self._piter.Orientation(&orientation, &writing_direction, &textline_order, &deskew_angle)             # <<<<<<<<<<<<<<
 *         return orientation, writing_direction, textline_order, deskew_angle
 * 
 */
  __pyx_v_self->_piter->Orientation((&__pyx_v_orientation), (&__pyx_v_writing_direction), (&__pyx_v_textline_order), (&__pyx_v_deskew_angle));

  /* "tesserocr.pyx":683
 *             float deskew_angle
 *         self._piter.Orientation(&orientation, &writing_direction, &textline_order, &deskew_angle)
 *         return orientation, writing_direction, textline_order, deskew_angle             # <<<<<<<<<<<<<<
 * 
 *     def ParagraphInfo(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_enum__tesseract_3a__3a_Orientation(__pyx_v_orientation); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 683; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_WritingDirection(__pyx_v_writing_direction); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 683; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_enum__tesseract_3a__3a_TextlineOrder(__pyx_v_textline_order); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 683; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyFloat_FromDouble(__pyx_v_deskew_angle); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 683; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 683; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":663
 *         return (x1, y1), (x2, y2)
 * 
 *     def Orientation(self):             # <<<<<<<<<<<<<<
 *         """Return the orientation for the block the iterator points to.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.Orientation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":685
 *         return orientation, writing_direction, textline_order, deskew_angle
 * 
 *     def ParagraphInfo(self):             # <<<<<<<<<<<<<<
 *         """Return information about the current paragraph, if available.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_41ParagraphInfo(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_14PyPageIterator_40ParagraphInfo[] = "Return information about the current paragraph, if available.\n\n        Returns:\n            tuple: The following values are returned respectively::\n\n                justification:\n                    LEFT if ragged right, or fully justified and script is left-to-right.\n                    RIGHT if ragged left, or fully justified and script is right-to-left.\n                    UNKNOWN if it looks like source code or we have very few lines.\n                    See :class:`Justification`.\n                is_list_item:\n                    ``True`` if we believe this is a member of an ordered or unordered list.\n                is_crown:\n                    ``True`` if the first line of the paragraph is aligned with the other\n                    lines of the paragraph even though subsequent paragraphs have first\n                    line indents.  This typically indicates that this is the continuation\n                    of a previous paragraph or that it is the very first paragraph in\n                    the chapter.\n                first_line_indent:\n                    For LEFT aligned paragraphs, the first text line of paragraphs of\n                    this kind are indented this many pixels from the left edge of the\n                    rest of the paragraph.\n                    for RIGHT aligned paragraphs, the first text line of paragraphs of\n                    this kind are indented this many pixels from the right edge of the\n                    rest of the paragraph.\n                    NOTE 1: This value may be negative.\n                    NOTE 2: if ``is_crown == True``, the first line of this paragraph is\n                        actually flush, and first_line_indent is set to the \"common\"\n                        first_line_indent for subsequent paragraphs in this block\n                        of text.\n        ";
static PyObject *__pyx_pw_9tesserocr_14PyPageIterator_41ParagraphInfo(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ParagraphInfo (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_14PyPageIterator_40ParagraphInfo(((struct __pyx_obj_9tesserocr_PyPageIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_14PyPageIterator_40ParagraphInfo(struct __pyx_obj_9tesserocr_PyPageIterator *__pyx_v_self) {
  enum tesseract::ParagraphJustification __pyx_v_justification;
  bool __pyx_v_is_list_item;
  bool __pyx_v_is_crown;
  int __pyx_v_first_line_indent;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ParagraphInfo", 0);

  /* "tesserocr.pyx":722
 *             bool is_crown
 *             int first_line_indent
 *         self._piter.ParagraphInfo(&justification, &is_list_item, &is_crown, &first_line_indent)             # <<<<<<<<<<<<<<
 *         return justification, is_list_item, is_crown, first_line_indent
 * 
 */
  __pyx_v_self->_piter->ParagraphInfo((&__pyx_v_justification), (&__pyx_v_is_list_item), (&__pyx_v_is_crown), (&__pyx_v_first_line_indent));

  /* "tesserocr.pyx":723
 *             int first_line_indent
 *         self._piter.ParagraphInfo(&justification, &is_list_item, &is_crown, &first_line_indent)
 *         return justification, is_list_item, is_crown, first_line_indent             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_enum__tesseract_3a__3a_ParagraphJustification(__pyx_v_justification); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_is_list_item); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_is_crown); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_first_line_indent); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":685
 *         return orientation, writing_direction, textline_order, deskew_angle
 * 
 *     def ParagraphInfo(self):             # <<<<<<<<<<<<<<
 *         """Return information about the current paragraph, if available.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("tesserocr.PyPageIterator.ParagraphInfo", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":730
 *     cdef LTRResultIterator *_ltrriter
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._ltrriter = NULL
 * 
 */

/* Python wrapper */
static int __pyx_pw_9tesserocr_19PyLTRResultIterator_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_9tesserocr_19PyLTRResultIterator_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator___cinit__(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9tesserocr_19PyLTRResultIterator___cinit__(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "tesserocr.pyx":731
 * 
 *     def __cinit__(self):
 *         self._ltrriter = NULL             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->_ltrriter = NULL;

  /* "tesserocr.pyx":730
 *     cdef LTRResultIterator *_ltrriter
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._ltrriter = NULL
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":733
 *         self._ltrriter = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._ltrriter != NULL:
 *             del self._ltrriter
 */

/* Python wrapper */
static void __pyx_pw_9tesserocr_19PyLTRResultIterator_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_9tesserocr_19PyLTRResultIterator_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_9tesserocr_19PyLTRResultIterator_2__dealloc__(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_9tesserocr_19PyLTRResultIterator_2__dealloc__(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "tesserocr.pyx":734
 * 
 *     def __dealloc__(self):
 *         if self._ltrriter != NULL:             # <<<<<<<<<<<<<<
 *             del self._ltrriter
 *         self._piter = NULL
 */
  __pyx_t_1 = ((__pyx_v_self->_ltrriter != NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":735
 *     def __dealloc__(self):
 *         if self._ltrriter != NULL:
 *             del self._ltrriter             # <<<<<<<<<<<<<<
 *         self._piter = NULL
 * 
 */
    delete __pyx_v_self->_ltrriter;

    /* "tesserocr.pyx":734
 * 
 *     def __dealloc__(self):
 *         if self._ltrriter != NULL:             # <<<<<<<<<<<<<<
 *             del self._ltrriter
 *         self._piter = NULL
 */
  }

  /* "tesserocr.pyx":736
 *         if self._ltrriter != NULL:
 *             del self._ltrriter
 *         self._piter = NULL             # <<<<<<<<<<<<<<
 * 
 *     def GetChoiceIterator(self):
 */
  __pyx_v_self->__pyx_base._piter = NULL;

  /* "tesserocr.pyx":733
 *         self._ltrriter = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._ltrriter != NULL:
 *             del self._ltrriter
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "tesserocr.pyx":738
 *         self._piter = NULL
 * 
 *     def GetChoiceIterator(self):             # <<<<<<<<<<<<<<
 *         """Return `PyChoiceIterator` instance to iterate over symbol choices"""
 *         cdef:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_5GetChoiceIterator(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_4GetChoiceIterator[] = "Return `PyChoiceIterator` instance to iterate over symbol choices";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_5GetChoiceIterator(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetChoiceIterator (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_4GetChoiceIterator(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_4GetChoiceIterator(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  tesseract::LTRResultIterator const *__pyx_v_ltrriter;
  tesseract::ChoiceIterator *__pyx_v_citer;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  tesseract::LTRResultIterator *__pyx_t_1;
  tesseract::ChoiceIterator *__pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetChoiceIterator", 0);

  /* "tesserocr.pyx":741
 *         """Return `PyChoiceIterator` instance to iterate over symbol choices"""
 *         cdef:
 *             const LTRResultIterator *ltrriter = self._ltrriter             # <<<<<<<<<<<<<<
 *             ChoiceIterator *citer = new ChoiceIterator(ltrriter[0])
 *         return PyChoiceIterator.create(citer)
 */
  __pyx_t_1 = __pyx_v_self->_ltrriter;
  __pyx_v_ltrriter = __pyx_t_1;

  /* "tesserocr.pyx":742
 *         cdef:
 *             const LTRResultIterator *ltrriter = self._ltrriter
 *             ChoiceIterator *citer = new ChoiceIterator(ltrriter[0])             # <<<<<<<<<<<<<<
 *         return PyChoiceIterator.create(citer)
 * 
 */
  try {
    __pyx_t_2 = new tesseract::ChoiceIterator((__pyx_v_ltrriter[0]));
  } catch(...) {
    __Pyx_CppExn2PyErr();
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 742; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_v_citer = __pyx_t_2;

  /* "tesserocr.pyx":743
 *             const LTRResultIterator *ltrriter = self._ltrriter
 *             ChoiceIterator *citer = new ChoiceIterator(ltrriter[0])
 *         return PyChoiceIterator.create(citer)             # <<<<<<<<<<<<<<
 * 
 *     def GetUTF8Text(self, PageIteratorLevel level):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = ((PyObject *)__pyx_f_9tesserocr_16PyChoiceIterator_create(__pyx_v_citer)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":738
 *         self._piter = NULL
 * 
 *     def GetChoiceIterator(self):             # <<<<<<<<<<<<<<
 *         """Return `PyChoiceIterator` instance to iterate over symbol choices"""
 *         cdef:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.GetChoiceIterator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":745
 *         return PyChoiceIterator.create(citer)
 * 
 *     def GetUTF8Text(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Returns the UTF-8 encoded text string for the current
 *         object at the given level.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_7GetUTF8Text(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_6GetUTF8Text[] = "Returns the UTF-8 encoded text string for the current\n        object at the given level.\n\n        Args:\n            level (int): Iterator level. See :class:`RIL`.\n\n        Returns:\n            unicode: UTF-8 encoded text for the given level's current object.\n\n        Raises:\n            :exc:`RuntimeError`: If no text returned.\n        ";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_7GetUTF8Text(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetUTF8Text (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 745; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.GetUTF8Text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_6GetUTF8Text(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_6GetUTF8Text(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetUTF8Text", 0);

  /* "tesserocr.pyx":758
 *             :exc:`RuntimeError`: If no text returned.
 *         """
 *         cdef char *text = self._ltrriter.GetUTF8Text(level)             # <<<<<<<<<<<<<<
 *         if text == NULL:
 *             raise RuntimeError('No text returned')
 */
  __pyx_v_text = __pyx_v_self->_ltrriter->GetUTF8Text(__pyx_v_level);

  /* "tesserocr.pyx":759
 *         """
 *         cdef char *text = self._ltrriter.GetUTF8Text(level)
 *         if text == NULL:             # <<<<<<<<<<<<<<
 *             raise RuntimeError('No text returned')
 *         return _free_str(text)
 */
  __pyx_t_1 = ((__pyx_v_text == NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":760
 *         cdef char *text = self._ltrriter.GetUTF8Text(level)
 *         if text == NULL:
 *             raise RuntimeError('No text returned')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 760; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 760; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

    /* "tesserocr.pyx":759
 *         """
 *         cdef char *text = self._ltrriter.GetUTF8Text(level)
 *         if text == NULL:             # <<<<<<<<<<<<<<
 *             raise RuntimeError('No text returned')
 *         return _free_str(text)
 */
  }

  /* "tesserocr.pyx":761
 *         if text == NULL:
 *             raise RuntimeError('No text returned')
 *         return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 *     def SetLineSeparator(self, cchar_t *separator):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":745
 *         return PyChoiceIterator.create(citer)
 * 
 *     def GetUTF8Text(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Returns the UTF-8 encoded text string for the current
 *         object at the given level.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.GetUTF8Text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":763
 *         return _free_str(text)
 * 
 *     def SetLineSeparator(self, cchar_t *separator):             # <<<<<<<<<<<<<<
 *         """Set the string inserted at the end of each text line. "\n" by default."""
 *         self._ltrriter.SetLineSeparator(separator)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_9SetLineSeparator(PyObject *__pyx_v_self, PyObject *__pyx_arg_separator); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_8SetLineSeparator[] = "Set the string inserted at the end of each text line. \"\n\" by default.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_9SetLineSeparator(PyObject *__pyx_v_self, PyObject *__pyx_arg_separator) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_separator;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetLineSeparator (wrapper)", 0);
  assert(__pyx_arg_separator); {
    __pyx_v_separator = __Pyx_PyObject_AsString(__pyx_arg_separator); if (unlikely((!__pyx_v_separator) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 763; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.SetLineSeparator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_8SetLineSeparator(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_separator));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_8SetLineSeparator(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_separator) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetLineSeparator", 0);

  /* "tesserocr.pyx":765
 *     def SetLineSeparator(self, cchar_t *separator):
 *         """Set the string inserted at the end of each text line. "\n" by default."""
 *         self._ltrriter.SetLineSeparator(separator)             # <<<<<<<<<<<<<<
 * 
 *     def SetParagraphSeparator(self, cchar_t *separator):
 */
  __pyx_v_self->_ltrriter->SetLineSeparator(__pyx_v_separator);

  /* "tesserocr.pyx":763
 *         return _free_str(text)
 * 
 *     def SetLineSeparator(self, cchar_t *separator):             # <<<<<<<<<<<<<<
 *         """Set the string inserted at the end of each text line. "\n" by default."""
 *         self._ltrriter.SetLineSeparator(separator)
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":767
 *         self._ltrriter.SetLineSeparator(separator)
 * 
 *     def SetParagraphSeparator(self, cchar_t *separator):             # <<<<<<<<<<<<<<
 *         """Set the string inserted at the end of each paragraph. "\n" by default."""
 *         self._ltrriter.SetParagraphSeparator(separator)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_11SetParagraphSeparator(PyObject *__pyx_v_self, PyObject *__pyx_arg_separator); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_10SetParagraphSeparator[] = "Set the string inserted at the end of each paragraph. \"\n\" by default.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_11SetParagraphSeparator(PyObject *__pyx_v_self, PyObject *__pyx_arg_separator) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_separator;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetParagraphSeparator (wrapper)", 0);
  assert(__pyx_arg_separator); {
    __pyx_v_separator = __Pyx_PyObject_AsString(__pyx_arg_separator); if (unlikely((!__pyx_v_separator) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 767; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.SetParagraphSeparator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_10SetParagraphSeparator(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_separator));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_10SetParagraphSeparator(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_separator) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetParagraphSeparator", 0);

  /* "tesserocr.pyx":769
 *     def SetParagraphSeparator(self, cchar_t *separator):
 *         """Set the string inserted at the end of each paragraph. "\n" by default."""
 *         self._ltrriter.SetParagraphSeparator(separator)             # <<<<<<<<<<<<<<
 * 
 *     def Confidence(self, PageIteratorLevel level):
 */
  __pyx_v_self->_ltrriter->SetParagraphSeparator(__pyx_v_separator);

  /* "tesserocr.pyx":767
 *         self._ltrriter.SetLineSeparator(separator)
 * 
 *     def SetParagraphSeparator(self, cchar_t *separator):             # <<<<<<<<<<<<<<
 *         """Set the string inserted at the end of each paragraph. "\n" by default."""
 *         self._ltrriter.SetParagraphSeparator(separator)
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":771
 *         self._ltrriter.SetParagraphSeparator(separator)
 * 
 *     def Confidence(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return the mean confidence of the current object at the given level.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_13Confidence(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_12Confidence[] = "Return the mean confidence of the current object at the given level.\n\n        The number should be interpreted as a percent probability. (0.0-100.0)\n        ";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_13Confidence(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Confidence (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.Confidence", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_12Confidence(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_12Confidence(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Confidence", 0);

  /* "tesserocr.pyx":776
 *         The number should be interpreted as a percent probability. (0.0-100.0)
 *         """
 *         return self._ltrriter.Confidence(level)             # <<<<<<<<<<<<<<
 * 
 *     def WordFontAttributes(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->_ltrriter->Confidence(__pyx_v_level)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 776; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":771
 *         self._ltrriter.SetParagraphSeparator(separator)
 * 
 *     def Confidence(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return the mean confidence of the current object at the given level.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.Confidence", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":778
 *         return self._ltrriter.Confidence(level)
 * 
 *     def WordFontAttributes(self):             # <<<<<<<<<<<<<<
 *         """Return the font attributes of the current word.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_15WordFontAttributes(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_14WordFontAttributes[] = "Return the font attributes of the current word.\n\n        .. note::\n            If iterating at a higher level object than words, eg textlines,\n            then this will return the attributes of the first word in that textline.\n\n        Returns:\n            dict: A dictionary with the font attributes::\n\n                font_name: String representing a font name. Lifespan is the same as\n                    the iterator itself, ie rendered invalid by various members of\n                    :class:`PyTessBaseAPI`, including `Init`, `SetImage`, `End` or\n                    deleting the :class:`PyTessBaseAPI`.\n                bold (bool): ``True`` if bold.\n                italic (bool): ``True`` if italic.\n                underlined (bool): ``True`` if underlined.\n                monospace (bool): ``True`` if monospace.\n                serif (bool): ``True`` if serif.\n                smallcaps (bool): ``True`` if smallcaps.\n                pointsize (int): printers points (1/72 inch.)\n                font_id (int): font id.\n        ";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_15WordFontAttributes(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WordFontAttributes (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_14WordFontAttributes(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_14WordFontAttributes(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  bool __pyx_v_is_bold;
  bool __pyx_v_is_italic;
  bool __pyx_v_is_underlined;
  bool __pyx_v_is_monospace;
  bool __pyx_v_is_serif;
  bool __pyx_v_is_smallcaps;
  int __pyx_v_pointsize;
  int __pyx_v_font_id;
  __pyx_t_9tesseract_cchar_t *__pyx_v_font_name;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WordFontAttributes", 0);

  /* "tesserocr.pyx":811
 *             int font_id
 *             cchar_t *font_name
 *         font_name = self._ltrriter.WordFontAttributes(&is_bold, &is_italic, &is_underlined,             # <<<<<<<<<<<<<<
 *                                                  &is_monospace, &is_serif, &is_smallcaps,
 *                                                  &pointsize, &font_id)
 */
  __pyx_v_font_name = __pyx_v_self->_ltrriter->WordFontAttributes((&__pyx_v_is_bold), (&__pyx_v_is_italic), (&__pyx_v_is_underlined), (&__pyx_v_is_monospace), (&__pyx_v_is_serif), (&__pyx_v_is_smallcaps), (&__pyx_v_pointsize), (&__pyx_v_font_id));

  /* "tesserocr.pyx":814
 *                                                  &is_monospace, &is_serif, &is_smallcaps,
 *                                                  &pointsize, &font_id)
 *         return {             # <<<<<<<<<<<<<<
 *             'font_name': font_name,
 *             'bold': is_bold,
 */
  __Pyx_XDECREF(__pyx_r);

  /* "tesserocr.pyx":815
 *                                                  &pointsize, &font_id)
 *         return {
 *             'font_name': font_name,             # <<<<<<<<<<<<<<
 *             'bold': is_bold,
 *             'italic': is_italic,
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_font_name); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_font_name, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":816
 *         return {
 *             'font_name': font_name,
 *             'bold': is_bold,             # <<<<<<<<<<<<<<
 *             'italic': is_italic,
 *             'underlined': is_underlined,
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_is_bold); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_bold, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":817
 *             'font_name': font_name,
 *             'bold': is_bold,
 *             'italic': is_italic,             # <<<<<<<<<<<<<<
 *             'underlined': is_underlined,
 *             'monospace': is_monospace,
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_is_italic); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_italic, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":818
 *             'bold': is_bold,
 *             'italic': is_italic,
 *             'underlined': is_underlined,             # <<<<<<<<<<<<<<
 *             'monospace': is_monospace,
 *             'serif': is_serif,
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_is_underlined); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_underlined, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":819
 *             'italic': is_italic,
 *             'underlined': is_underlined,
 *             'monospace': is_monospace,             # <<<<<<<<<<<<<<
 *             'serif': is_serif,
 *             'smallcaps': is_smallcaps,
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_is_monospace); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_monospace, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":820
 *             'underlined': is_underlined,
 *             'monospace': is_monospace,
 *             'serif': is_serif,             # <<<<<<<<<<<<<<
 *             'smallcaps': is_smallcaps,
 *             'pointsize': pointsize,
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_is_serif); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_serif, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":821
 *             'monospace': is_monospace,
 *             'serif': is_serif,
 *             'smallcaps': is_smallcaps,             # <<<<<<<<<<<<<<
 *             'pointsize': pointsize,
 *             'font_id': font_id
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_is_smallcaps); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_smallcaps, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":822
 *             'serif': is_serif,
 *             'smallcaps': is_smallcaps,
 *             'pointsize': pointsize,             # <<<<<<<<<<<<<<
 *             'font_id': font_id
 *         }
 */
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_pointsize); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_pointsize, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":824
 *             'pointsize': pointsize,
 *             'font_id': font_id
 *         }             # <<<<<<<<<<<<<<
 * 
 *     def WordRecognitionLanguage(self):
 */
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_font_id); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_font_id, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":778
 *         return self._ltrriter.Confidence(level)
 * 
 *     def WordFontAttributes(self):             # <<<<<<<<<<<<<<
 *         """Return the font attributes of the current word.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.WordFontAttributes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":826
 *         }
 * 
 *     def WordRecognitionLanguage(self):             # <<<<<<<<<<<<<<
 *         """Return the name of the language used to recognize this word.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_17WordRecognitionLanguage(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_16WordRecognitionLanguage[] = "Return the name of the language used to recognize this word.\n\n        Returns ``None`` on error.\n        ";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_17WordRecognitionLanguage(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WordRecognitionLanguage (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_16WordRecognitionLanguage(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_16WordRecognitionLanguage(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_lang;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WordRecognitionLanguage", 0);

  /* "tesserocr.pyx":831
 *         Returns ``None`` on error.
 *         """
 *         cdef cchar_t *lang = self._ltrriter.WordRecognitionLanguage()             # <<<<<<<<<<<<<<
 *         if lang == NULL:
 *             return None
 */
  __pyx_v_lang = __pyx_v_self->_ltrriter->WordRecognitionLanguage();

  /* "tesserocr.pyx":832
 *         """
 *         cdef cchar_t *lang = self._ltrriter.WordRecognitionLanguage()
 *         if lang == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return lang
 */
  __pyx_t_1 = ((__pyx_v_lang == NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":833
 *         cdef cchar_t *lang = self._ltrriter.WordRecognitionLanguage()
 *         if lang == NULL:
 *             return None             # <<<<<<<<<<<<<<
 *         return lang
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":832
 *         """
 *         cdef cchar_t *lang = self._ltrriter.WordRecognitionLanguage()
 *         if lang == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return lang
 */
  }

  /* "tesserocr.pyx":834
 *         if lang == NULL:
 *             return None
 *         return lang             # <<<<<<<<<<<<<<
 * 
 *     def WordDirection(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_lang); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":826
 *         }
 * 
 *     def WordRecognitionLanguage(self):             # <<<<<<<<<<<<<<
 *         """Return the name of the language used to recognize this word.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.WordRecognitionLanguage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":836
 *         return lang
 * 
 *     def WordDirection(self):             # <<<<<<<<<<<<<<
 *         """Return the overall directionality of this word.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_19WordDirection(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_18WordDirection[] = "Return the overall directionality of this word.\n\n        See :class:`DIR` for available values.\n        ";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_19WordDirection(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WordDirection (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_18WordDirection(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_18WordDirection(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WordDirection", 0);

  /* "tesserocr.pyx":841
 *         See :class:`DIR` for available values.
 *         """
 *         return self._ltrriter.WordDirection()             # <<<<<<<<<<<<<<
 * 
 *     def WordIsFromDictionary(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_enum__StrongScriptDirection(__pyx_v_self->_ltrriter->WordDirection()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":836
 *         return lang
 * 
 *     def WordDirection(self):             # <<<<<<<<<<<<<<
 *         """Return the overall directionality of this word.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.WordDirection", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":843
 *         return self._ltrriter.WordDirection()
 * 
 *     def WordIsFromDictionary(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current word was found in a dictionary."""
 *         return self._ltrriter.WordIsFromDictionary()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_21WordIsFromDictionary(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_20WordIsFromDictionary[] = "Return True if the current word was found in a dictionary.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_21WordIsFromDictionary(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WordIsFromDictionary (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_20WordIsFromDictionary(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_20WordIsFromDictionary(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WordIsFromDictionary", 0);

  /* "tesserocr.pyx":845
 *     def WordIsFromDictionary(self):
 *         """Return True if the current word was found in a dictionary."""
 *         return self._ltrriter.WordIsFromDictionary()             # <<<<<<<<<<<<<<
 * 
 *     def WordIsNumeric(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_ltrriter->WordIsFromDictionary()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 845; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":843
 *         return self._ltrriter.WordDirection()
 * 
 *     def WordIsFromDictionary(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current word was found in a dictionary."""
 *         return self._ltrriter.WordIsFromDictionary()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.WordIsFromDictionary", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":847
 *         return self._ltrriter.WordIsFromDictionary()
 * 
 *     def WordIsNumeric(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current word is numeric."""
 *         return self._ltrriter.WordIsNumeric()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_23WordIsNumeric(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_22WordIsNumeric[] = "Return True if the current word is numeric.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_23WordIsNumeric(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WordIsNumeric (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_22WordIsNumeric(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_22WordIsNumeric(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WordIsNumeric", 0);

  /* "tesserocr.pyx":849
 *     def WordIsNumeric(self):
 *         """Return True if the current word is numeric."""
 *         return self._ltrriter.WordIsNumeric()             # <<<<<<<<<<<<<<
 * 
 *     def HasBlamerInfo(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_ltrriter->WordIsNumeric()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":847
 *         return self._ltrriter.WordIsFromDictionary()
 * 
 *     def WordIsNumeric(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current word is numeric."""
 *         return self._ltrriter.WordIsNumeric()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.WordIsNumeric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":851
 *         return self._ltrriter.WordIsNumeric()
 * 
 *     def HasBlamerInfo(self):             # <<<<<<<<<<<<<<
 *         """Return True if the word contains blamer information."""
 *         return self._ltrriter.HasBlamerInfo()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_25HasBlamerInfo(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_24HasBlamerInfo[] = "Return True if the word contains blamer information.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_25HasBlamerInfo(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("HasBlamerInfo (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_24HasBlamerInfo(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_24HasBlamerInfo(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("HasBlamerInfo", 0);

  /* "tesserocr.pyx":853
 *     def HasBlamerInfo(self):
 *         """Return True if the word contains blamer information."""
 *         return self._ltrriter.HasBlamerInfo()             # <<<<<<<<<<<<<<
 * 
 *     def GetBlamerDebug(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_ltrriter->HasBlamerInfo()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 853; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":851
 *         return self._ltrriter.WordIsNumeric()
 * 
 *     def HasBlamerInfo(self):             # <<<<<<<<<<<<<<
 *         """Return True if the word contains blamer information."""
 *         return self._ltrriter.HasBlamerInfo()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.HasBlamerInfo", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":855
 *         return self._ltrriter.HasBlamerInfo()
 * 
 *     def GetBlamerDebug(self):             # <<<<<<<<<<<<<<
 *         """Return a string with blamer information for this word."""
 *         return self._ltrriter.GetBlamerDebug()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_27GetBlamerDebug(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_26GetBlamerDebug[] = "Return a string with blamer information for this word.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_27GetBlamerDebug(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetBlamerDebug (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_26GetBlamerDebug(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_26GetBlamerDebug(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetBlamerDebug", 0);

  /* "tesserocr.pyx":857
 *     def GetBlamerDebug(self):
 *         """Return a string with blamer information for this word."""
 *         return self._ltrriter.GetBlamerDebug()             # <<<<<<<<<<<<<<
 * 
 *     def GetBlamerMisadaptionDebug(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_self->_ltrriter->GetBlamerDebug()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":855
 *         return self._ltrriter.HasBlamerInfo()
 * 
 *     def GetBlamerDebug(self):             # <<<<<<<<<<<<<<
 *         """Return a string with blamer information for this word."""
 *         return self._ltrriter.GetBlamerDebug()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.GetBlamerDebug", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":859
 *         return self._ltrriter.GetBlamerDebug()
 * 
 *     def GetBlamerMisadaptionDebug(self):             # <<<<<<<<<<<<<<
 *         """Return a string with misadaption information for this word."""
 *         return self._ltrriter.GetBlamerMisadaptionDebug()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_29GetBlamerMisadaptionDebug(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_28GetBlamerMisadaptionDebug[] = "Return a string with misadaption information for this word.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_29GetBlamerMisadaptionDebug(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetBlamerMisadaptionDebug (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_28GetBlamerMisadaptionDebug(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_28GetBlamerMisadaptionDebug(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetBlamerMisadaptionDebug", 0);

  /* "tesserocr.pyx":861
 *     def GetBlamerMisadaptionDebug(self):
 *         """Return a string with misadaption information for this word."""
 *         return self._ltrriter.GetBlamerMisadaptionDebug()             # <<<<<<<<<<<<<<
 * 
 *     def HasTruthString(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_self->_ltrriter->GetBlamerMisadaptionDebug()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":859
 *         return self._ltrriter.GetBlamerDebug()
 * 
 *     def GetBlamerMisadaptionDebug(self):             # <<<<<<<<<<<<<<
 *         """Return a string with misadaption information for this word."""
 *         return self._ltrriter.GetBlamerMisadaptionDebug()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.GetBlamerMisadaptionDebug", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":863
 *         return self._ltrriter.GetBlamerMisadaptionDebug()
 * 
 *     def HasTruthString(self):             # <<<<<<<<<<<<<<
 *         """Returns True if a truth string was recorded for the current word."""
 *         return self._ltrriter.HasTruthString()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_31HasTruthString(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_30HasTruthString[] = "Returns True if a truth string was recorded for the current word.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_31HasTruthString(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("HasTruthString (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_30HasTruthString(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_30HasTruthString(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("HasTruthString", 0);

  /* "tesserocr.pyx":865
 *     def HasTruthString(self):
 *         """Returns True if a truth string was recorded for the current word."""
 *         return self._ltrriter.HasTruthString()             # <<<<<<<<<<<<<<
 * 
 *     def EquivalentToTruth(self, cchar_t *text):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_ltrriter->HasTruthString()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":863
 *         return self._ltrriter.GetBlamerMisadaptionDebug()
 * 
 *     def HasTruthString(self):             # <<<<<<<<<<<<<<
 *         """Returns True if a truth string was recorded for the current word."""
 *         return self._ltrriter.HasTruthString()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.HasTruthString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":867
 *         return self._ltrriter.HasTruthString()
 * 
 *     def EquivalentToTruth(self, cchar_t *text):             # <<<<<<<<<<<<<<
 *         """Return True if the given string is equivalent to the truth string for
 *         the current word."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_33EquivalentToTruth(PyObject *__pyx_v_self, PyObject *__pyx_arg_text); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_32EquivalentToTruth[] = "Return True if the given string is equivalent to the truth string for\n        the current word.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_33EquivalentToTruth(PyObject *__pyx_v_self, PyObject *__pyx_arg_text) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_text;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("EquivalentToTruth (wrapper)", 0);
  assert(__pyx_arg_text); {
    __pyx_v_text = __Pyx_PyObject_AsString(__pyx_arg_text); if (unlikely((!__pyx_v_text) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 867; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.EquivalentToTruth", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_32EquivalentToTruth(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_text));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_32EquivalentToTruth(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_text) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("EquivalentToTruth", 0);

  /* "tesserocr.pyx":870
 *         """Return True if the given string is equivalent to the truth string for
 *         the current word."""
 *         return self._ltrriter.EquivalentToTruth(text)             # <<<<<<<<<<<<<<
 * 
 *     def WordTruthUTF8Text(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_ltrriter->EquivalentToTruth(__pyx_v_text)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":867
 *         return self._ltrriter.HasTruthString()
 * 
 *     def EquivalentToTruth(self, cchar_t *text):             # <<<<<<<<<<<<<<
 *         """Return True if the given string is equivalent to the truth string for
 *         the current word."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.EquivalentToTruth", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":872
 *         return self._ltrriter.EquivalentToTruth(text)
 * 
 *     def WordTruthUTF8Text(self):             # <<<<<<<<<<<<<<
 *         """Return a UTF-8 encoded truth string for the current word."""
 *         cdef char *text = self._ltrriter.WordTruthUTF8Text()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_35WordTruthUTF8Text(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_34WordTruthUTF8Text[] = "Return a UTF-8 encoded truth string for the current word.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_35WordTruthUTF8Text(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WordTruthUTF8Text (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_34WordTruthUTF8Text(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_34WordTruthUTF8Text(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WordTruthUTF8Text", 0);

  /* "tesserocr.pyx":874
 *     def WordTruthUTF8Text(self):
 *         """Return a UTF-8 encoded truth string for the current word."""
 *         cdef char *text = self._ltrriter.WordTruthUTF8Text()             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
  __pyx_v_text = __pyx_v_self->_ltrriter->WordTruthUTF8Text();

  /* "tesserocr.pyx":875
 *         """Return a UTF-8 encoded truth string for the current word."""
 *         cdef char *text = self._ltrriter.WordTruthUTF8Text()
 *         return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 *     def WordNormedUTF8Text(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 875; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":872
 *         return self._ltrriter.EquivalentToTruth(text)
 * 
 *     def WordTruthUTF8Text(self):             # <<<<<<<<<<<<<<
 *         """Return a UTF-8 encoded truth string for the current word."""
 *         cdef char *text = self._ltrriter.WordTruthUTF8Text()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.WordTruthUTF8Text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":877
 *         return _free_str(text)
 * 
 *     def WordNormedUTF8Text(self):             # <<<<<<<<<<<<<<
 *         """Returns a UTF-8 encoded normalized OCR string for the
 *         current word."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_37WordNormedUTF8Text(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_36WordNormedUTF8Text[] = "Returns a UTF-8 encoded normalized OCR string for the\n        current word.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_37WordNormedUTF8Text(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WordNormedUTF8Text (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_36WordNormedUTF8Text(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_36WordNormedUTF8Text(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WordNormedUTF8Text", 0);

  /* "tesserocr.pyx":880
 *         """Returns a UTF-8 encoded normalized OCR string for the
 *         current word."""
 *         cdef char *text = self._ltrriter.WordNormedUTF8Text()             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
  __pyx_v_text = __pyx_v_self->_ltrriter->WordNormedUTF8Text();

  /* "tesserocr.pyx":881
 *         current word."""
 *         cdef char *text = self._ltrriter.WordNormedUTF8Text()
 *         return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 *     def WordLattice(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 881; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":877
 *         return _free_str(text)
 * 
 *     def WordNormedUTF8Text(self):             # <<<<<<<<<<<<<<
 *         """Returns a UTF-8 encoded normalized OCR string for the
 *         current word."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.WordNormedUTF8Text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":883
 *         return _free_str(text)
 * 
 *     def WordLattice(self):             # <<<<<<<<<<<<<<
 *         """Return a serialized choice lattice."""
 *         cdef:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_39WordLattice(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_38WordLattice[] = "Return a serialized choice lattice.";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_39WordLattice(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WordLattice (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_38WordLattice(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_38WordLattice(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_word_lattice;
  int __pyx_v_lattice_size;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WordLattice", 0);

  /* "tesserocr.pyx":888
 *             cchar_t *word_lattice
 *             int lattice_size
 *         word_lattice = self._ltrriter.WordLattice(&lattice_size)             # <<<<<<<<<<<<<<
 *         if not lattice_size:
 *             return None
 */
  __pyx_v_word_lattice = __pyx_v_self->_ltrriter->WordLattice((&__pyx_v_lattice_size));

  /* "tesserocr.pyx":889
 *             int lattice_size
 *         word_lattice = self._ltrriter.WordLattice(&lattice_size)
 *         if not lattice_size:             # <<<<<<<<<<<<<<
 *             return None
 *         return word_lattice[:lattice_size]
 */
  __pyx_t_1 = ((!(__pyx_v_lattice_size != 0)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":890
 *         word_lattice = self._ltrriter.WordLattice(&lattice_size)
 *         if not lattice_size:
 *             return None             # <<<<<<<<<<<<<<
 *         return word_lattice[:lattice_size]
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":889
 *             int lattice_size
 *         word_lattice = self._ltrriter.WordLattice(&lattice_size)
 *         if not lattice_size:             # <<<<<<<<<<<<<<
 *             return None
 *         return word_lattice[:lattice_size]
 */
  }

  /* "tesserocr.pyx":891
 *         if not lattice_size:
 *             return None
 *         return word_lattice[:lattice_size]             # <<<<<<<<<<<<<<
 * 
 *     def SymbolIsSuperscript(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyUnicode_FromStringAndSize(__pyx_v_word_lattice + 0, __pyx_v_lattice_size - 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 891; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":883
 *         return _free_str(text)
 * 
 *     def WordLattice(self):             # <<<<<<<<<<<<<<
 *         """Return a serialized choice lattice."""
 *         cdef:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.WordLattice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":893
 *         return word_lattice[:lattice_size]
 * 
 *     def SymbolIsSuperscript(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current symbol is a superscript.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_41SymbolIsSuperscript(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_40SymbolIsSuperscript[] = "Return True if the current symbol is a superscript.\n\n        If iterating at a higher level object than symbols, eg words, then\n        this will return the attributes of the first symbol in that word.\n        ";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_41SymbolIsSuperscript(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SymbolIsSuperscript (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_40SymbolIsSuperscript(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_40SymbolIsSuperscript(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SymbolIsSuperscript", 0);

  /* "tesserocr.pyx":899
 *         this will return the attributes of the first symbol in that word.
 *         """
 *         return self._ltrriter.SymbolIsSuperscript()             # <<<<<<<<<<<<<<
 * 
 *     def SymbolIsSubscript(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_ltrriter->SymbolIsSuperscript()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 899; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":893
 *         return word_lattice[:lattice_size]
 * 
 *     def SymbolIsSuperscript(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current symbol is a superscript.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.SymbolIsSuperscript", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":901
 *         return self._ltrriter.SymbolIsSuperscript()
 * 
 *     def SymbolIsSubscript(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current symbol is a subscript.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_43SymbolIsSubscript(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_42SymbolIsSubscript[] = "Return True if the current symbol is a subscript.\n\n        If iterating at a higher level object than symbols, eg words, then\n        this will return the attributes of the first symbol in that word.\n        ";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_43SymbolIsSubscript(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SymbolIsSubscript (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_42SymbolIsSubscript(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_42SymbolIsSubscript(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SymbolIsSubscript", 0);

  /* "tesserocr.pyx":907
 *         this will return the attributes of the first symbol in that word.
 *         """
 *         return self._ltrriter.SymbolIsSubscript()             # <<<<<<<<<<<<<<
 * 
 *     def SymbolIsDropcap(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_ltrriter->SymbolIsSubscript()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 907; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":901
 *         return self._ltrriter.SymbolIsSuperscript()
 * 
 *     def SymbolIsSubscript(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current symbol is a subscript.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.SymbolIsSubscript", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":909
 *         return self._ltrriter.SymbolIsSubscript()
 * 
 *     def SymbolIsDropcap(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current symbol is a dropcap.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_45SymbolIsDropcap(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_19PyLTRResultIterator_44SymbolIsDropcap[] = "Return True if the current symbol is a dropcap.\n\n        If iterating at a higher level object than symbols, eg words, then\n        this will return the attributes of the first symbol in that word.\n        ";
static PyObject *__pyx_pw_9tesserocr_19PyLTRResultIterator_45SymbolIsDropcap(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SymbolIsDropcap (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_19PyLTRResultIterator_44SymbolIsDropcap(((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_19PyLTRResultIterator_44SymbolIsDropcap(struct __pyx_obj_9tesserocr_PyLTRResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SymbolIsDropcap", 0);

  /* "tesserocr.pyx":915
 *         this will return the attributes of the first symbol in that word.
 *         """
 *         return self._ltrriter.SymbolIsDropcap()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_ltrriter->SymbolIsDropcap()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 915; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":909
 *         return self._ltrriter.SymbolIsSubscript()
 * 
 *     def SymbolIsDropcap(self):             # <<<<<<<<<<<<<<
 *         """Return True if the current symbol is a dropcap.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyLTRResultIterator.SymbolIsDropcap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":927
 * 
 *     @staticmethod
 *     cdef PyResultIterator createResultIterator(ResultIterator *riter):             # <<<<<<<<<<<<<<
 *         cdef PyResultIterator pyiter = PyResultIterator.__new__(PyResultIterator)
 *         pyiter._piter = <PageIterator *>riter
 */

static struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_f_9tesserocr_16PyResultIterator_createResultIterator(tesseract::ResultIterator *__pyx_v_riter) {
  struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_pyiter = 0;
  struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createResultIterator", 0);

  /* "tesserocr.pyx":928
 *     @staticmethod
 *     cdef PyResultIterator createResultIterator(ResultIterator *riter):
 *         cdef PyResultIterator pyiter = PyResultIterator.__new__(PyResultIterator)             # <<<<<<<<<<<<<<
 *         pyiter._piter = <PageIterator *>riter
 *         pyiter._ltrriter = <LTRResultIterator *>riter
 */
  __pyx_t_1 = __pyx_tp_new_9tesserocr_PyResultIterator(((PyTypeObject *)__pyx_ptype_9tesserocr_PyResultIterator), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 928; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (!(likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_9tesserocr_PyResultIterator)))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 928; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_pyiter = ((struct __pyx_obj_9tesserocr_PyResultIterator *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":929
 *     cdef PyResultIterator createResultIterator(ResultIterator *riter):
 *         cdef PyResultIterator pyiter = PyResultIterator.__new__(PyResultIterator)
 *         pyiter._piter = <PageIterator *>riter             # <<<<<<<<<<<<<<
 *         pyiter._ltrriter = <LTRResultIterator *>riter
 *         pyiter._riter = riter
 */
  __pyx_v_pyiter->__pyx_base.__pyx_base._piter = ((tesseract::PageIterator *)__pyx_v_riter);

  /* "tesserocr.pyx":930
 *         cdef PyResultIterator pyiter = PyResultIterator.__new__(PyResultIterator)
 *         pyiter._piter = <PageIterator *>riter
 *         pyiter._ltrriter = <LTRResultIterator *>riter             # <<<<<<<<<<<<<<
 *         pyiter._riter = riter
 *         return pyiter
 */
  __pyx_v_pyiter->__pyx_base._ltrriter = ((tesseract::LTRResultIterator *)__pyx_v_riter);

  /* "tesserocr.pyx":931
 *         pyiter._piter = <PageIterator *>riter
 *         pyiter._ltrriter = <LTRResultIterator *>riter
 *         pyiter._riter = riter             # <<<<<<<<<<<<<<
 *         return pyiter
 * 
 */
  __pyx_v_pyiter->_riter = __pyx_v_riter;

  /* "tesserocr.pyx":932
 *         pyiter._ltrriter = <LTRResultIterator *>riter
 *         pyiter._riter = riter
 *         return pyiter             # <<<<<<<<<<<<<<
 * 
 *     def __cinit__(self):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_pyiter));
  __pyx_r = __pyx_v_pyiter;
  goto __pyx_L0;

  /* "tesserocr.pyx":927
 * 
 *     @staticmethod
 *     cdef PyResultIterator createResultIterator(ResultIterator *riter):             # <<<<<<<<<<<<<<
 *         cdef PyResultIterator pyiter = PyResultIterator.__new__(PyResultIterator)
 *         pyiter._piter = <PageIterator *>riter
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyResultIterator.createResultIterator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_pyiter);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":934
 *         return pyiter
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._riter = NULL
 * 
 */

/* Python wrapper */
static int __pyx_pw_9tesserocr_16PyResultIterator_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_9tesserocr_16PyResultIterator_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_9tesserocr_16PyResultIterator___cinit__(((struct __pyx_obj_9tesserocr_PyResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9tesserocr_16PyResultIterator___cinit__(struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "tesserocr.pyx":935
 * 
 *     def __cinit__(self):
 *         self._riter = NULL             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->_riter = NULL;

  /* "tesserocr.pyx":934
 *         return pyiter
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._riter = NULL
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":937
 *         self._riter = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._riter != NULL:
 *             del self._riter
 */

/* Python wrapper */
static void __pyx_pw_9tesserocr_16PyResultIterator_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_9tesserocr_16PyResultIterator_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_9tesserocr_16PyResultIterator_2__dealloc__(((struct __pyx_obj_9tesserocr_PyResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_9tesserocr_16PyResultIterator_2__dealloc__(struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "tesserocr.pyx":938
 * 
 *     def __dealloc__(self):
 *         if self._riter != NULL:             # <<<<<<<<<<<<<<
 *             del self._riter
 *             # set super class pointers to NULL
 */
  __pyx_t_1 = ((__pyx_v_self->_riter != NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":939
 *     def __dealloc__(self):
 *         if self._riter != NULL:
 *             del self._riter             # <<<<<<<<<<<<<<
 *             # set super class pointers to NULL
 *             # to avoid multiple deletes
 */
    delete __pyx_v_self->_riter;

    /* "tesserocr.pyx":938
 * 
 *     def __dealloc__(self):
 *         if self._riter != NULL:             # <<<<<<<<<<<<<<
 *             del self._riter
 *             # set super class pointers to NULL
 */
  }

  /* "tesserocr.pyx":942
 *             # set super class pointers to NULL
 *             # to avoid multiple deletes
 *         self._ltrriter = NULL             # <<<<<<<<<<<<<<
 * 
 *     def IsAtBeginningOf(self, PageIteratorLevel level):
 */
  __pyx_v_self->__pyx_base._ltrriter = NULL;

  /* "tesserocr.pyx":937
 *         self._riter = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._riter != NULL:
 *             del self._riter
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "tesserocr.pyx":944
 *         self._ltrriter = NULL
 * 
 *     def IsAtBeginningOf(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return whether we're at the logical beginning of the
 *         given level. (as opposed to :class:`PyResultIterator`'s left-to-right
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_16PyResultIterator_5IsAtBeginningOf(PyObject *__pyx_v_self, PyObject *__pyx_arg_level); /*proto*/
static char __pyx_doc_9tesserocr_16PyResultIterator_4IsAtBeginningOf[] = "Return whether we're at the logical beginning of the\n        given level. (as opposed to :class:`PyResultIterator`'s left-to-right\n        top-to-bottom order).\n\n        Otherwise, this acts the same as :meth:`PyPageIterator.IsAtBeginningOf`.\n        ";
static PyObject *__pyx_pw_9tesserocr_16PyResultIterator_5IsAtBeginningOf(PyObject *__pyx_v_self, PyObject *__pyx_arg_level) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("IsAtBeginningOf (wrapper)", 0);
  assert(__pyx_arg_level); {
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_arg_level)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 944; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyResultIterator.IsAtBeginningOf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_16PyResultIterator_4IsAtBeginningOf(((struct __pyx_obj_9tesserocr_PyResultIterator *)__pyx_v_self), ((enum tesseract::PageIteratorLevel)__pyx_v_level));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_16PyResultIterator_4IsAtBeginningOf(struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("IsAtBeginningOf", 0);

  /* "tesserocr.pyx":951
 *         Otherwise, this acts the same as :meth:`PyPageIterator.IsAtBeginningOf`.
 *         """
 *         return self._riter.IsAtBeginningOf(level)             # <<<<<<<<<<<<<<
 * 
 *     def ParagraphIsLtr(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_riter->IsAtBeginningOf(__pyx_v_level)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 951; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":944
 *         self._ltrriter = NULL
 * 
 *     def IsAtBeginningOf(self, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *         """Return whether we're at the logical beginning of the
 *         given level. (as opposed to :class:`PyResultIterator`'s left-to-right
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyResultIterator.IsAtBeginningOf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":953
 *         return self._riter.IsAtBeginningOf(level)
 * 
 *     def ParagraphIsLtr(self):             # <<<<<<<<<<<<<<
 *         """Return whether the current paragraph's dominant reading direction
 *         is left-to-right (as opposed to right-to-left).
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_16PyResultIterator_7ParagraphIsLtr(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_16PyResultIterator_6ParagraphIsLtr[] = "Return whether the current paragraph's dominant reading direction\n        is left-to-right (as opposed to right-to-left).\n        ";
static PyObject *__pyx_pw_9tesserocr_16PyResultIterator_7ParagraphIsLtr(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ParagraphIsLtr (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_16PyResultIterator_6ParagraphIsLtr(((struct __pyx_obj_9tesserocr_PyResultIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_16PyResultIterator_6ParagraphIsLtr(struct __pyx_obj_9tesserocr_PyResultIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ParagraphIsLtr", 0);

  /* "tesserocr.pyx":957
 *         is left-to-right (as opposed to right-to-left).
 *         """
 *         return self._riter.ParagraphIsLtr()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_riter->ParagraphIsLtr()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":953
 *         return self._riter.IsAtBeginningOf(level)
 * 
 *     def ParagraphIsLtr(self):             # <<<<<<<<<<<<<<
 *         """Return whether the current paragraph's dominant reading direction
 *         is left-to-right (as opposed to right-to-left).
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyResultIterator.ParagraphIsLtr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":965
 * 
 *     @staticmethod
 *     cdef PyChoiceIterator create(ChoiceIterator *citer):             # <<<<<<<<<<<<<<
 *         cdef PyChoiceIterator pyciter = PyChoiceIterator.__new__(PyChoiceIterator)
 *         pyciter._citer = citer
 */

static struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_f_9tesserocr_16PyChoiceIterator_create(tesseract::ChoiceIterator *__pyx_v_citer) {
  struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_pyciter = 0;
  struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("create", 0);

  /* "tesserocr.pyx":966
 *     @staticmethod
 *     cdef PyChoiceIterator create(ChoiceIterator *citer):
 *         cdef PyChoiceIterator pyciter = PyChoiceIterator.__new__(PyChoiceIterator)             # <<<<<<<<<<<<<<
 *         pyciter._citer = citer
 *         return pyciter
 */
  __pyx_t_1 = __pyx_tp_new_9tesserocr_PyChoiceIterator(((PyTypeObject *)__pyx_ptype_9tesserocr_PyChoiceIterator), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 966; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (!(likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_9tesserocr_PyChoiceIterator)))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 966; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_pyciter = ((struct __pyx_obj_9tesserocr_PyChoiceIterator *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":967
 *     cdef PyChoiceIterator create(ChoiceIterator *citer):
 *         cdef PyChoiceIterator pyciter = PyChoiceIterator.__new__(PyChoiceIterator)
 *         pyciter._citer = citer             # <<<<<<<<<<<<<<
 *         return pyciter
 * 
 */
  __pyx_v_pyciter->_citer = __pyx_v_citer;

  /* "tesserocr.pyx":968
 *         cdef PyChoiceIterator pyciter = PyChoiceIterator.__new__(PyChoiceIterator)
 *         pyciter._citer = citer
 *         return pyciter             # <<<<<<<<<<<<<<
 * 
 *     def __cinit__(self):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_pyciter));
  __pyx_r = __pyx_v_pyciter;
  goto __pyx_L0;

  /* "tesserocr.pyx":965
 * 
 *     @staticmethod
 *     cdef PyChoiceIterator create(ChoiceIterator *citer):             # <<<<<<<<<<<<<<
 *         cdef PyChoiceIterator pyciter = PyChoiceIterator.__new__(PyChoiceIterator)
 *         pyciter._citer = citer
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyChoiceIterator.create", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_pyciter);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":970
 *         return pyciter
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._citer = NULL
 * 
 */

/* Python wrapper */
static int __pyx_pw_9tesserocr_16PyChoiceIterator_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_9tesserocr_16PyChoiceIterator_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_9tesserocr_16PyChoiceIterator___cinit__(((struct __pyx_obj_9tesserocr_PyChoiceIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9tesserocr_16PyChoiceIterator___cinit__(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "tesserocr.pyx":971
 * 
 *     def __cinit__(self):
 *         self._citer = NULL             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->_citer = NULL;

  /* "tesserocr.pyx":970
 *         return pyciter
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._citer = NULL
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":973
 *         self._citer = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._citer != NULL:
 *             del self._citer
 */

/* Python wrapper */
static void __pyx_pw_9tesserocr_16PyChoiceIterator_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_9tesserocr_16PyChoiceIterator_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_9tesserocr_16PyChoiceIterator_2__dealloc__(((struct __pyx_obj_9tesserocr_PyChoiceIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_9tesserocr_16PyChoiceIterator_2__dealloc__(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "tesserocr.pyx":974
 * 
 *     def __dealloc__(self):
 *         if self._citer != NULL:             # <<<<<<<<<<<<<<
 *             del self._citer
 * 
 */
  __pyx_t_1 = ((__pyx_v_self->_citer != NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":975
 *     def __dealloc__(self):
 *         if self._citer != NULL:
 *             del self._citer             # <<<<<<<<<<<<<<
 * 
 *     def __init__(self, ltr_iterator):
 */
    delete __pyx_v_self->_citer;

    /* "tesserocr.pyx":974
 * 
 *     def __dealloc__(self):
 *         if self._citer != NULL:             # <<<<<<<<<<<<<<
 *             del self._citer
 * 
 */
  }

  /* "tesserocr.pyx":973
 *         self._citer = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._citer != NULL:
 *             del self._citer
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "tesserocr.pyx":977
 *             del self._citer
 * 
 *     def __init__(self, ltr_iterator):             # <<<<<<<<<<<<<<
 *         raise TypeError('ChoiceIterator cannot be instantiated from Python')
 * 
 */

/* Python wrapper */
static int __pyx_pw_9tesserocr_16PyChoiceIterator_5__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_9tesserocr_16PyChoiceIterator_5__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ltr_iterator = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ltr_iterator,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ltr_iterator)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 977; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_ltr_iterator = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 977; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyChoiceIterator.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_16PyChoiceIterator_4__init__(((struct __pyx_obj_9tesserocr_PyChoiceIterator *)__pyx_v_self), __pyx_v_ltr_iterator);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9tesserocr_16PyChoiceIterator_4__init__(CYTHON_UNUSED struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_ltr_iterator) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "tesserocr.pyx":978
 * 
 *     def __init__(self, ltr_iterator):
 *         raise TypeError('ChoiceIterator cannot be instantiated from Python')             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":977
 *             del self._citer
 * 
 *     def __init__(self, ltr_iterator):             # <<<<<<<<<<<<<<
 *         raise TypeError('ChoiceIterator cannot be instantiated from Python')
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyChoiceIterator.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":980
 *         raise TypeError('ChoiceIterator cannot be instantiated from Python')
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return iterate_choices(self)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_16PyChoiceIterator_7__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_9tesserocr_16PyChoiceIterator_7__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_16PyChoiceIterator_6__iter__(((struct __pyx_obj_9tesserocr_PyChoiceIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_16PyChoiceIterator_6__iter__(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__iter__", 0);

  /* "tesserocr.pyx":981
 * 
 *     def __iter__(self):
 *         return iterate_choices(self)             # <<<<<<<<<<<<<<
 * 
 *     def Next(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_iterate_choices); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3); __pyx_t_3 = NULL;
    __Pyx_INCREF(((PyObject *)__pyx_v_self));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
    PyTuple_SET_ITEM(__pyx_t_4, 0+1, ((PyObject *)__pyx_v_self));
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":980
 *         raise TypeError('ChoiceIterator cannot be instantiated from Python')
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return iterate_choices(self)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("tesserocr.PyChoiceIterator.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":983
 *         return iterate_choices(self)
 * 
 *     def Next(self):             # <<<<<<<<<<<<<<
 *         """Move to the next choice for the symbol and returns False if there
 *         are none left."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_16PyChoiceIterator_9Next(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_16PyChoiceIterator_8Next[] = "Move to the next choice for the symbol and returns False if there\n        are none left.";
static PyObject *__pyx_pw_9tesserocr_16PyChoiceIterator_9Next(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Next (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_16PyChoiceIterator_8Next(((struct __pyx_obj_9tesserocr_PyChoiceIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_16PyChoiceIterator_8Next(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Next", 0);

  /* "tesserocr.pyx":986
 *         """Move to the next choice for the symbol and returns False if there
 *         are none left."""
 *         return self._citer.Next()             # <<<<<<<<<<<<<<
 * 
 *     def GetUTF8Text(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_citer->Next()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 986; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":983
 *         return iterate_choices(self)
 * 
 *     def Next(self):             # <<<<<<<<<<<<<<
 *         """Move to the next choice for the symbol and returns False if there
 *         are none left."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyChoiceIterator.Next", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":988
 *         return self._citer.Next()
 * 
 *     def GetUTF8Text(self):             # <<<<<<<<<<<<<<
 *         """Return the UTF-8 encoded text string for the current
 *         choice."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_16PyChoiceIterator_11GetUTF8Text(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_16PyChoiceIterator_10GetUTF8Text[] = "Return the UTF-8 encoded text string for the current\n        choice.";
static PyObject *__pyx_pw_9tesserocr_16PyChoiceIterator_11GetUTF8Text(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetUTF8Text (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_16PyChoiceIterator_10GetUTF8Text(((struct __pyx_obj_9tesserocr_PyChoiceIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_16PyChoiceIterator_10GetUTF8Text(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetUTF8Text", 0);

  /* "tesserocr.pyx":991
 *         """Return the UTF-8 encoded text string for the current
 *         choice."""
 *         cdef cchar_t *text = self._citer.GetUTF8Text()             # <<<<<<<<<<<<<<
 *         if text == NULL:
 *             return None
 */
  __pyx_v_text = __pyx_v_self->_citer->GetUTF8Text();

  /* "tesserocr.pyx":992
 *         choice."""
 *         cdef cchar_t *text = self._citer.GetUTF8Text()
 *         if text == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return text
 */
  __pyx_t_1 = ((__pyx_v_text == NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":993
 *         cdef cchar_t *text = self._citer.GetUTF8Text()
 *         if text == NULL:
 *             return None             # <<<<<<<<<<<<<<
 *         return text
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":992
 *         choice."""
 *         cdef cchar_t *text = self._citer.GetUTF8Text()
 *         if text == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return text
 */
  }

  /* "tesserocr.pyx":994
 *         if text == NULL:
 *             return None
 *         return text             # <<<<<<<<<<<<<<
 * 
 *     def Confidence(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 994; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":988
 *         return self._citer.Next()
 * 
 *     def GetUTF8Text(self):             # <<<<<<<<<<<<<<
 *         """Return the UTF-8 encoded text string for the current
 *         choice."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyChoiceIterator.GetUTF8Text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":996
 *         return text
 * 
 *     def Confidence(self):             # <<<<<<<<<<<<<<
 *         """Return the confidence of the current choice.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_16PyChoiceIterator_13Confidence(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_16PyChoiceIterator_12Confidence[] = "Return the confidence of the current choice.\n\n        The number should be interpreted as a percent probability. (0.0f-100.0f)\n        ";
static PyObject *__pyx_pw_9tesserocr_16PyChoiceIterator_13Confidence(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Confidence (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_16PyChoiceIterator_12Confidence(((struct __pyx_obj_9tesserocr_PyChoiceIterator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_16PyChoiceIterator_12Confidence(struct __pyx_obj_9tesserocr_PyChoiceIterator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Confidence", 0);

  /* "tesserocr.pyx":1001
 *         The number should be interpreted as a percent probability. (0.0f-100.0f)
 *         """
 *         return self._citer.Confidence()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->_citer->Confidence()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1001; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":996
 *         return text
 * 
 *     def Confidence(self):             # <<<<<<<<<<<<<<
 *         """Return the confidence of the current choice.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyChoiceIterator.Confidence", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9tesserocr_2generator(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

/* "tesserocr.pyx":1004
 * 
 * 
 * def iterate_choices(citerator):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate :class:`PyChoiceIterator`."""
 *     yield citerator
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_1iterate_choices(PyObject *__pyx_self, PyObject *__pyx_v_citerator); /*proto*/
static char __pyx_doc_9tesserocr_iterate_choices[] = "Helper generator function to iterate :class:`PyChoiceIterator`.";
static PyMethodDef __pyx_mdef_9tesserocr_1iterate_choices = {"iterate_choices", (PyCFunction)__pyx_pw_9tesserocr_1iterate_choices, METH_O, __pyx_doc_9tesserocr_iterate_choices};
static PyObject *__pyx_pw_9tesserocr_1iterate_choices(PyObject *__pyx_self, PyObject *__pyx_v_citerator) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iterate_choices (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_iterate_choices(__pyx_self, ((PyObject *)__pyx_v_citerator));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_iterate_choices(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_citerator) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("iterate_choices", 0);
  __pyx_cur_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *)__pyx_tp_new_9tesserocr___pyx_scope_struct_5_iterate_choices(__pyx_ptype_9tesserocr___pyx_scope_struct_5_iterate_choices, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __Pyx_GOTREF(__pyx_cur_scope);
  __pyx_cur_scope->__pyx_v_citerator = __pyx_v_citerator;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_citerator);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_citerator);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9tesserocr_2generator, (PyObject *) __pyx_cur_scope, __pyx_n_s_iterate_choices, __pyx_n_s_iterate_choices); if (unlikely(!gen)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("tesserocr.iterate_choices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9tesserocr_2generator(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *__pyx_cur_scope = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L4_resume_from_yield;
    case 2: goto __pyx_L7_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1006
 * def iterate_choices(citerator):
 *     """Helper generator function to iterate :class:`PyChoiceIterator`."""
 *     yield citerator             # <<<<<<<<<<<<<<
 *     while citerator.Next():
 *         yield citerator
 */
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_citerator);
  __pyx_r = __pyx_cur_scope->__pyx_v_citerator;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  /* return from generator, yielding value */
  __pyx_generator->resume_label = 1;
  return __pyx_r;
  __pyx_L4_resume_from_yield:;
  if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1007
 *     """Helper generator function to iterate :class:`PyChoiceIterator`."""
 *     yield citerator
 *     while citerator.Next():             # <<<<<<<<<<<<<<
 *         yield citerator
 * 
 */
  while (1) {
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_citerator, __pyx_n_s_Next); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1007; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    if (__pyx_t_3) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1007; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1007; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1007; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (!__pyx_t_4) break;

    /* "tesserocr.pyx":1008
 *     yield citerator
 *     while citerator.Next():
 *         yield citerator             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __Pyx_INCREF(__pyx_cur_scope->__pyx_v_citerator);
    __pyx_r = __pyx_cur_scope->__pyx_v_citerator;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 2;
    return __pyx_r;
    __pyx_L7_resume_from_yield:;
    if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1008; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "tesserocr.pyx":1004
 * 
 * 
 * def iterate_choices(citerator):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate :class:`PyChoiceIterator`."""
 *     yield citerator
 */

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("iterate_choices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9tesserocr_5generator1(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

/* "tesserocr.pyx":1011
 * 
 * 
 * def iterate_level(iterator, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate a :class:`PyPageIterator`
 *     level.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_4iterate_level(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_3iterate_level[] = "Helper generator function to iterate a :class:`PyPageIterator`\n    level.\n    ";
static PyMethodDef __pyx_mdef_9tesserocr_4iterate_level = {"iterate_level", (PyCFunction)__pyx_pw_9tesserocr_4iterate_level, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_3iterate_level};
static PyObject *__pyx_pw_9tesserocr_4iterate_level(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_iterator = 0;
  enum tesseract::PageIteratorLevel __pyx_v_level;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iterate_level (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_iterator,&__pyx_n_s_level,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_iterator)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_level)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("iterate_level", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "iterate_level") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_iterator = values[0];
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(values[1])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("iterate_level", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.iterate_level", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_3iterate_level(__pyx_self, __pyx_v_iterator, __pyx_v_level);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_3iterate_level(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_iterator, enum tesseract::PageIteratorLevel __pyx_v_level) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("iterate_level", 0);
  __pyx_cur_scope = (struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *)__pyx_tp_new_9tesserocr___pyx_scope_struct_6_iterate_level(__pyx_ptype_9tesserocr___pyx_scope_struct_6_iterate_level, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __Pyx_GOTREF(__pyx_cur_scope);
  __pyx_cur_scope->__pyx_v_iterator = __pyx_v_iterator;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_iterator);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_iterator);
  __pyx_cur_scope->__pyx_v_level = __pyx_v_level;
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9tesserocr_5generator1, (PyObject *) __pyx_cur_scope, __pyx_n_s_iterate_level, __pyx_n_s_iterate_level); if (unlikely(!gen)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("tesserocr.iterate_level", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9tesserocr_5generator1(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *__pyx_cur_scope = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L4_resume_from_yield;
    case 2: goto __pyx_L7_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1015
 *     level.
 *     """
 *     yield iterator             # <<<<<<<<<<<<<<
 *     while iterator.Next(level):
 *         yield iterator
 */
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_iterator);
  __pyx_r = __pyx_cur_scope->__pyx_v_iterator;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  /* return from generator, yielding value */
  __pyx_generator->resume_label = 1;
  return __pyx_r;
  __pyx_L4_resume_from_yield:;
  if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1016
 *     """
 *     yield iterator
 *     while iterator.Next(level):             # <<<<<<<<<<<<<<
 *         yield iterator
 * 
 */
  while (1) {
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_iterator, __pyx_n_s_Next); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageIteratorLevel(__pyx_cur_scope->__pyx_v_level); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    if (!__pyx_t_4) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
      __pyx_t_3 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (!__pyx_t_6) break;

    /* "tesserocr.pyx":1017
 *     yield iterator
 *     while iterator.Next(level):
 *         yield iterator             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __Pyx_INCREF(__pyx_cur_scope->__pyx_v_iterator);
    __pyx_r = __pyx_cur_scope->__pyx_v_iterator;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 2;
    return __pyx_r;
    __pyx_L7_resume_from_yield:;
    if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "tesserocr.pyx":1011
 * 
 * 
 * def iterate_level(iterator, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate a :class:`PyPageIterator`
 *     level.
 */

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("iterate_level", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1066
 * 
 *     @staticmethod
 *     def Version():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.Version()
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_1Version(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_9tesserocr_13PyTessBaseAPI_1Version = {"Version", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_1Version, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_1Version(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Version (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("Version", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return NULL;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "Version", 0))) return NULL;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_Version();

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_Version() {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Version", 0);

  /* "tesserocr.pyx":1067
 *     @staticmethod
 *     def Version():
 *         return TessBaseAPI.Version()             # <<<<<<<<<<<<<<
 * 
 *     @staticmethod
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(tesseract::TessBaseAPI::Version()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1066
 * 
 *     @staticmethod
 *     def Version():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.Version()
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.Version", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1070
 * 
 *     @staticmethod
 *     def ClearPersistentCache():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_3ClearPersistentCache(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_9tesserocr_13PyTessBaseAPI_3ClearPersistentCache = {"ClearPersistentCache", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_3ClearPersistentCache, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_3ClearPersistentCache(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ClearPersistentCache (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("ClearPersistentCache", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return NULL;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "ClearPersistentCache", 0))) return NULL;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_2ClearPersistentCache();

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_2ClearPersistentCache() {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ClearPersistentCache", 0);

  /* "tesserocr.pyx":1071
 *     @staticmethod
 *     def ClearPersistentCache():
 *         return TessBaseAPI.ClearPersistentCache()             # <<<<<<<<<<<<<<
 * 
 *     def __cinit__(self, cchar_t *path=_DEFAULT_PATH,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_void_to_None(tesseract::TessBaseAPI::ClearPersistentCache()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1070
 * 
 *     @staticmethod
 *     def ClearPersistentCache():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.ClearPersistentCache", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1073
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 *     def __cinit__(self, cchar_t *path=_DEFAULT_PATH,             # <<<<<<<<<<<<<<
 *                   cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                   bool init=True):
 */

/* Python wrapper */
static int __pyx_pw_9tesserocr_13PyTessBaseAPI_5__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_9tesserocr_13PyTessBaseAPI_5__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_path;
  __pyx_t_9tesseract_cchar_t *__pyx_v_lang;
  enum tesseract::PageSegMode __pyx_v_psm;
  bool __pyx_v_init;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_path,&__pyx_n_s_lang,&__pyx_n_s_psm,&__pyx_n_s_init,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_path);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lang);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_psm);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_init);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1073; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_path = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_path) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1073; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_path = __pyx_k__6;
    }
    if (values[1]) {
      __pyx_v_lang = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_lang) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1074; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_lang = __pyx_k__7;
    }
    if (values[2]) {
      __pyx_v_psm = ((enum tesseract::PageSegMode)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageSegMode(values[2])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1074; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_psm = __pyx_k__8;
    }
    if (values[3]) {
      __pyx_v_init = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_init == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1075; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "tesserocr.pyx":1075
 *     def __cinit__(self, cchar_t *path=_DEFAULT_PATH,
 *                   cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                   bool init=True):             # <<<<<<<<<<<<<<
 *         with nogil:
 *             self._pix = NULL
 */
      __pyx_v_init = ((bool)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1073; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_4__cinit__(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_path, __pyx_v_lang, __pyx_v_psm, __pyx_v_init);

  /* "tesserocr.pyx":1073
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 *     def __cinit__(self, cchar_t *path=_DEFAULT_PATH,             # <<<<<<<<<<<<<<
 *                   cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                   bool init=True):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9tesserocr_13PyTessBaseAPI_4__cinit__(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::PageSegMode __pyx_v_psm, bool __pyx_v_init) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "tesserocr.pyx":1076
 *                   cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                   bool init=True):
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._pix = NULL
 *             if init:
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1077
 *                   bool init=True):
 *         with nogil:
 *             self._pix = NULL             # <<<<<<<<<<<<<<
 *             if init:
 *                 self._init_api(path, lang, OEM_DEFAULT, NULL, 0, NULL, NULL, False, psm)
 */
        __pyx_v_self->_pix = NULL;

        /* "tesserocr.pyx":1078
 *         with nogil:
 *             self._pix = NULL
 *             if init:             # <<<<<<<<<<<<<<
 *                 self._init_api(path, lang, OEM_DEFAULT, NULL, 0, NULL, NULL, False, psm)
 * 
 */
        __pyx_t_1 = (__pyx_v_init != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":1079
 *             self._pix = NULL
 *             if init:
 *                 self._init_api(path, lang, OEM_DEFAULT, NULL, 0, NULL, NULL, False, psm)             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
          ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_init_api(__pyx_v_self, __pyx_v_path, __pyx_v_lang, tesseract::OEM_DEFAULT, NULL, 0, NULL, NULL, 0, __pyx_v_psm);

          /* "tesserocr.pyx":1078
 *         with nogil:
 *             self._pix = NULL
 *             if init:             # <<<<<<<<<<<<<<
 *                 self._init_api(path, lang, OEM_DEFAULT, NULL, 0, NULL, NULL, False, psm)
 * 
 */
        }
      }

      /* "tesserocr.pyx":1076
 *                   cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                   bool init=True):
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._pix = NULL
 *             if init:
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1073
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 *     def __cinit__(self, cchar_t *path=_DEFAULT_PATH,             # <<<<<<<<<<<<<<
 *                   cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                   bool init=True):
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1081
 *                 self._init_api(path, lang, OEM_DEFAULT, NULL, 0, NULL, NULL, False, psm)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._end_api()
 * 
 */

/* Python wrapper */
static void __pyx_pw_9tesserocr_13PyTessBaseAPI_7__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_9tesserocr_13PyTessBaseAPI_7__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_9tesserocr_13PyTessBaseAPI_6__dealloc__(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_9tesserocr_13PyTessBaseAPI_6__dealloc__(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "tesserocr.pyx":1082
 * 
 *     def __dealloc__(self):
 *         self._end_api()             # <<<<<<<<<<<<<<
 * 
 *     cdef int _init_api(self, cchar_t *path, cchar_t *lang,
 */
  ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_end_api(__pyx_v_self);

  /* "tesserocr.pyx":1081
 *                 self._init_api(path, lang, OEM_DEFAULT, NULL, 0, NULL, NULL, False, psm)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._end_api()
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "tesserocr.pyx":1084
 *         self._end_api()
 * 
 *     cdef int _init_api(self, cchar_t *path, cchar_t *lang,             # <<<<<<<<<<<<<<
 *                         OcrEngineMode oem, char **configs, int configs_size,
 *                         const GenericVector[STRING] *vars_vec, const GenericVector[STRING] *vars_vals,
 */

static int __pyx_f_9tesserocr_13PyTessBaseAPI__init_api(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::OcrEngineMode __pyx_v_oem, char **__pyx_v_configs, int __pyx_v_configs_size, GenericVector<STRING>  const *__pyx_v_vars_vec, GenericVector<STRING>  const *__pyx_v_vars_vals, bool __pyx_v_set_only_non_debug_params, enum tesseract::PageSegMode __pyx_v_psm) {
  int __pyx_v_ret;
  int __pyx_r;
  int __pyx_t_1;

  /* "tesserocr.pyx":1088
 *                         const GenericVector[STRING] *vars_vec, const GenericVector[STRING] *vars_vals,
 *                         bool set_only_non_debug_params, PageSegMode psm) nogil:
 *         cdef int ret = self._baseapi.Init(path, lang, oem, configs, configs_size, vars_vec, vars_vals,             # <<<<<<<<<<<<<<
 *                                           set_only_non_debug_params)
 *         if ret != -1:
 */
  __pyx_v_ret = __pyx_v_self->_baseapi.Init(__pyx_v_path, __pyx_v_lang, __pyx_v_oem, __pyx_v_configs, __pyx_v_configs_size, __pyx_v_vars_vec, __pyx_v_vars_vals, __pyx_v_set_only_non_debug_params);

  /* "tesserocr.pyx":1090
 *         cdef int ret = self._baseapi.Init(path, lang, oem, configs, configs_size, vars_vec, vars_vals,
 *                                           set_only_non_debug_params)
 *         if ret != -1:             # <<<<<<<<<<<<<<
 *             self._baseapi.SetPageSegMode(psm)
 *         return ret
 */
  __pyx_t_1 = ((__pyx_v_ret != -1L) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1091
 *                                           set_only_non_debug_params)
 *         if ret != -1:
 *             self._baseapi.SetPageSegMode(psm)             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
    __pyx_v_self->_baseapi.SetPageSegMode(__pyx_v_psm);

    /* "tesserocr.pyx":1090
 *         cdef int ret = self._baseapi.Init(path, lang, oem, configs, configs_size, vars_vec, vars_vals,
 *                                           set_only_non_debug_params)
 *         if ret != -1:             # <<<<<<<<<<<<<<
 *             self._baseapi.SetPageSegMode(psm)
 *         return ret
 */
  }

  /* "tesserocr.pyx":1092
 *         if ret != -1:
 *             self._baseapi.SetPageSegMode(psm)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     cdef void _end_api(self) nogil:
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "tesserocr.pyx":1084
 *         self._end_api()
 * 
 *     cdef int _init_api(self, cchar_t *path, cchar_t *lang,             # <<<<<<<<<<<<<<
 *                         OcrEngineMode oem, char **configs, int configs_size,
 *                         const GenericVector[STRING] *vars_vec, const GenericVector[STRING] *vars_vals,
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "tesserocr.pyx":1094
 *         return ret
 * 
 *     cdef void _end_api(self) nogil:             # <<<<<<<<<<<<<<
 *         self._destroy_pix()
 *         self._baseapi.End()
 */

static void __pyx_f_9tesserocr_13PyTessBaseAPI__end_api(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {

  /* "tesserocr.pyx":1095
 * 
 *     cdef void _end_api(self) nogil:
 *         self._destroy_pix()             # <<<<<<<<<<<<<<
 *         self._baseapi.End()
 * 
 */
  ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

  /* "tesserocr.pyx":1096
 *     cdef void _end_api(self) nogil:
 *         self._destroy_pix()
 *         self._baseapi.End()             # <<<<<<<<<<<<<<
 * 
 *     cdef void _destroy_pix(self) nogil:
 */
  __pyx_v_self->_baseapi.End();

  /* "tesserocr.pyx":1094
 *         return ret
 * 
 *     cdef void _end_api(self) nogil:             # <<<<<<<<<<<<<<
 *         self._destroy_pix()
 *         self._baseapi.End()
 */

  /* function exit code */
}

/* "tesserocr.pyx":1098
 *         self._baseapi.End()
 * 
 *     cdef void _destroy_pix(self) nogil:             # <<<<<<<<<<<<<<
 *         if self._pix != NULL:
 *             pixDestroy(&self._pix)
 */

static void __pyx_f_9tesserocr_13PyTessBaseAPI__destroy_pix(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  int __pyx_t_1;

  /* "tesserocr.pyx":1099
 * 
 *     cdef void _destroy_pix(self) nogil:
 *         if self._pix != NULL:             # <<<<<<<<<<<<<<
 *             pixDestroy(&self._pix)
 *             self._pix = NULL
 */
  __pyx_t_1 = ((__pyx_v_self->_pix != NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1100
 *     cdef void _destroy_pix(self) nogil:
 *         if self._pix != NULL:
 *             pixDestroy(&self._pix)             # <<<<<<<<<<<<<<
 *             self._pix = NULL
 * 
 */
    pixDestroy((&__pyx_v_self->_pix));

    /* "tesserocr.pyx":1101
 *         if self._pix != NULL:
 *             pixDestroy(&self._pix)
 *             self._pix = NULL             # <<<<<<<<<<<<<<
 * 
 *     def GetDatapath(self):
 */
    __pyx_v_self->_pix = NULL;

    /* "tesserocr.pyx":1099
 * 
 *     cdef void _destroy_pix(self) nogil:
 *         if self._pix != NULL:             # <<<<<<<<<<<<<<
 *             pixDestroy(&self._pix)
 *             self._pix = NULL
 */
  }

  /* "tesserocr.pyx":1098
 *         self._baseapi.End()
 * 
 *     cdef void _destroy_pix(self) nogil:             # <<<<<<<<<<<<<<
 *         if self._pix != NULL:
 *             pixDestroy(&self._pix)
 */

  /* function exit code */
}

/* "tesserocr.pyx":1103
 *             self._pix = NULL
 * 
 *     def GetDatapath(self):             # <<<<<<<<<<<<<<
 *         """Return tessdata parent directory"""
 *         return self._baseapi.GetDatapath()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_9GetDatapath(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_8GetDatapath[] = "Return tessdata parent directory";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_9GetDatapath(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetDatapath (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_8GetDatapath(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_8GetDatapath(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetDatapath", 0);

  /* "tesserocr.pyx":1105
 *     def GetDatapath(self):
 *         """Return tessdata parent directory"""
 *         return self._baseapi.GetDatapath()             # <<<<<<<<<<<<<<
 * 
 *     def SetOutputName(self, cchar_t *name):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_self->_baseapi.GetDatapath()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1103
 *             self._pix = NULL
 * 
 *     def GetDatapath(self):             # <<<<<<<<<<<<<<
 *         """Return tessdata parent directory"""
 *         return self._baseapi.GetDatapath()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetDatapath", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1107
 *         return self._baseapi.GetDatapath()
 * 
 *     def SetOutputName(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Set the name of the bonus output files. Needed only for debugging."""
 *         self._baseapi.SetOutputName(name)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_11SetOutputName(PyObject *__pyx_v_self, PyObject *__pyx_arg_name); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_10SetOutputName[] = "Set the name of the bonus output files. Needed only for debugging.";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_11SetOutputName(PyObject *__pyx_v_self, PyObject *__pyx_arg_name) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_name;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetOutputName (wrapper)", 0);
  assert(__pyx_arg_name); {
    __pyx_v_name = __Pyx_PyObject_AsString(__pyx_arg_name); if (unlikely((!__pyx_v_name) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetOutputName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_10SetOutputName(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_10SetOutputName(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetOutputName", 0);

  /* "tesserocr.pyx":1109
 *     def SetOutputName(self, cchar_t *name):
 *         """Set the name of the bonus output files. Needed only for debugging."""
 *         self._baseapi.SetOutputName(name)             # <<<<<<<<<<<<<<
 * 
 *     def SetVariable(self, cchar_t *name, cchar_t *val):
 */
  __pyx_v_self->_baseapi.SetOutputName(__pyx_v_name);

  /* "tesserocr.pyx":1107
 *         return self._baseapi.GetDatapath()
 * 
 *     def SetOutputName(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Set the name of the bonus output files. Needed only for debugging."""
 *         self._baseapi.SetOutputName(name)
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1111
 *         self._baseapi.SetOutputName(name)
 * 
 *     def SetVariable(self, cchar_t *name, cchar_t *val):             # <<<<<<<<<<<<<<
 *         """Set the value of an internal parameter.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_13SetVariable(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_12SetVariable[] = "Set the value of an internal parameter.\n\n        Supply the name of the parameter and the value as a string, just as\n        you would in a config file.\n\n        Eg SetVariable(\"tessedit_char_blacklist\", \"xyz\"); to ignore x, y and z.\n        Or SetVariable(\"classify_bln_numeric_mode\", \"1\"); to set numeric-only mode.\n\n        SetVariable may be used before Init, but settings will revert to\n        defaults on End().\n\n        Args:\n            name (str): Variable name\n            value (str): Variable value\n\n        Returns:\n            bool: ``False`` if the name lookup failed.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_13SetVariable(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_name;
  __pyx_t_9tesseract_cchar_t *__pyx_v_val;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetVariable (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name_2,&__pyx_n_s_val,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name_2)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_val)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetVariable", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1111; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SetVariable") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1111; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_name = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_name) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1111; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_val = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_val) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1111; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetVariable", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1111; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_12SetVariable(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_name, __pyx_v_val);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_12SetVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name, __pyx_t_9tesseract_cchar_t *__pyx_v_val) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SetVariable", 0);

  /* "tesserocr.pyx":1130
 *             bool: ``False`` if the name lookup failed.
 *         """
 *         return self._baseapi.SetVariable(name, val)             # <<<<<<<<<<<<<<
 * 
 *     def SetDebugVariable(self, cchar_t *name, cchar_t *val):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_baseapi.SetVariable(__pyx_v_name, __pyx_v_val)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1111
 *         self._baseapi.SetOutputName(name)
 * 
 *     def SetVariable(self, cchar_t *name, cchar_t *val):             # <<<<<<<<<<<<<<
 *         """Set the value of an internal parameter.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1132
 *         return self._baseapi.SetVariable(name, val)
 * 
 *     def SetDebugVariable(self, cchar_t *name, cchar_t *val):             # <<<<<<<<<<<<<<
 *         """Set the value of an internal parameter. (debug)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_15SetDebugVariable(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_14SetDebugVariable[] = "Set the value of an internal parameter. (debug)\n\n        Supply the name of the parameter and the value as a string, just as\n        you would in a config file.\n\n        Eg SetVariable(\"tessedit_char_blacklist\", \"xyz\"); to ignore x, y and z.\n        Or SetVariable(\"classify_bln_numeric_mode\", \"1\"); to set numeric-only mode.\n\n        SetVariable may be used before Init, but settings will revert to\n        defaults on End().\n\n        Args:\n            name (str): Variable name\n            value (str): Variable value\n\n        Returns:\n            bool: ``False`` if the name lookup failed.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_15SetDebugVariable(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_name;
  __pyx_t_9tesseract_cchar_t *__pyx_v_val;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetDebugVariable (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name_2,&__pyx_n_s_val,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name_2)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_val)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetDebugVariable", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1132; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SetDebugVariable") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1132; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_name = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_name) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1132; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_val = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_val) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1132; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetDebugVariable", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1132; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetDebugVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_14SetDebugVariable(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_name, __pyx_v_val);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_14SetDebugVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name, __pyx_t_9tesseract_cchar_t *__pyx_v_val) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SetDebugVariable", 0);

  /* "tesserocr.pyx":1151
 *             bool: ``False`` if the name lookup failed.
 *         """
 *         return self._baseapi.SetDebugVariable(name, val)             # <<<<<<<<<<<<<<
 * 
 *     def GetIntVariable(self, cchar_t *name):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_baseapi.SetDebugVariable(__pyx_v_name, __pyx_v_val)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1132
 *         return self._baseapi.SetVariable(name, val)
 * 
 *     def SetDebugVariable(self, cchar_t *name, cchar_t *val):             # <<<<<<<<<<<<<<
 *         """Set the value of an internal parameter. (debug)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetDebugVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1153
 *         return self._baseapi.SetDebugVariable(name, val)
 * 
 *     def GetIntVariable(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of the given int parameter if it exists among Tesseract parameters.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_17GetIntVariable(PyObject *__pyx_v_self, PyObject *__pyx_arg_name); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_16GetIntVariable[] = "Return the value of the given int parameter if it exists among Tesseract parameters.\n\n        Returns ``None`` if the paramter was not found.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_17GetIntVariable(PyObject *__pyx_v_self, PyObject *__pyx_arg_name) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_name;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetIntVariable (wrapper)", 0);
  assert(__pyx_arg_name); {
    __pyx_v_name = __Pyx_PyObject_AsString(__pyx_arg_name); if (unlikely((!__pyx_v_name) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetIntVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_16GetIntVariable(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_16GetIntVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name) {
  int __pyx_v_val;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetIntVariable", 0);

  /* "tesserocr.pyx":1159
 *         """
 *         cdef int val
 *         if self._baseapi.GetIntVariable(name, &val):             # <<<<<<<<<<<<<<
 *             return val
 *         return None
 */
  __pyx_t_1 = (__pyx_v_self->_baseapi.GetIntVariable(__pyx_v_name, (&__pyx_v_val)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1160
 *         cdef int val
 *         if self._baseapi.GetIntVariable(name, &val):
 *             return val             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_val); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "tesserocr.pyx":1159
 *         """
 *         cdef int val
 *         if self._baseapi.GetIntVariable(name, &val):             # <<<<<<<<<<<<<<
 *             return val
 *         return None
 */
  }

  /* "tesserocr.pyx":1161
 *         if self._baseapi.GetIntVariable(name, &val):
 *             return val
 *         return None             # <<<<<<<<<<<<<<
 * 
 *     def GetBoolVariable(self, cchar_t *name):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "tesserocr.pyx":1153
 *         return self._baseapi.SetDebugVariable(name, val)
 * 
 *     def GetIntVariable(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of the given int parameter if it exists among Tesseract parameters.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetIntVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1163
 *         return None
 * 
 *     def GetBoolVariable(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of the given bool parameter if it exists among Tesseract parameters.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_19GetBoolVariable(PyObject *__pyx_v_self, PyObject *__pyx_arg_name); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_18GetBoolVariable[] = "Return the value of the given bool parameter if it exists among Tesseract parameters.\n\n        Returns ``None`` if the paramter was not found.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_19GetBoolVariable(PyObject *__pyx_v_self, PyObject *__pyx_arg_name) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_name;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetBoolVariable (wrapper)", 0);
  assert(__pyx_arg_name); {
    __pyx_v_name = __Pyx_PyObject_AsString(__pyx_arg_name); if (unlikely((!__pyx_v_name) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1163; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetBoolVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_18GetBoolVariable(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_18GetBoolVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name) {
  bool __pyx_v_val;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetBoolVariable", 0);

  /* "tesserocr.pyx":1169
 *         """
 *         cdef bool val
 *         if self._baseapi.GetBoolVariable(name, &val):             # <<<<<<<<<<<<<<
 *             return val
 *         return None
 */
  __pyx_t_1 = (__pyx_v_self->_baseapi.GetBoolVariable(__pyx_v_name, (&__pyx_v_val)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1170
 *         cdef bool val
 *         if self._baseapi.GetBoolVariable(name, &val):
 *             return val             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_val); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "tesserocr.pyx":1169
 *         """
 *         cdef bool val
 *         if self._baseapi.GetBoolVariable(name, &val):             # <<<<<<<<<<<<<<
 *             return val
 *         return None
 */
  }

  /* "tesserocr.pyx":1171
 *         if self._baseapi.GetBoolVariable(name, &val):
 *             return val
 *         return None             # <<<<<<<<<<<<<<
 * 
 *     def GetDoubleVariable(self, cchar_t *name):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "tesserocr.pyx":1163
 *         return None
 * 
 *     def GetBoolVariable(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of the given bool parameter if it exists among Tesseract parameters.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetBoolVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1173
 *         return None
 * 
 *     def GetDoubleVariable(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of the given double parameter if it exists among Tesseract parameters.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_21GetDoubleVariable(PyObject *__pyx_v_self, PyObject *__pyx_arg_name); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_20GetDoubleVariable[] = "Return the value of the given double parameter if it exists among Tesseract parameters.\n\n        Returns ``None`` if the paramter was not found.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_21GetDoubleVariable(PyObject *__pyx_v_self, PyObject *__pyx_arg_name) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_name;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetDoubleVariable (wrapper)", 0);
  assert(__pyx_arg_name); {
    __pyx_v_name = __Pyx_PyObject_AsString(__pyx_arg_name); if (unlikely((!__pyx_v_name) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1173; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetDoubleVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_20GetDoubleVariable(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_20GetDoubleVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name) {
  double __pyx_v_val;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetDoubleVariable", 0);

  /* "tesserocr.pyx":1179
 *         """
 *         cdef double val
 *         if self._baseapi.GetDoubleVariable(name, &val):             # <<<<<<<<<<<<<<
 *             return val
 *         return None
 */
  __pyx_t_1 = (__pyx_v_self->_baseapi.GetDoubleVariable(__pyx_v_name, (&__pyx_v_val)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1180
 *         cdef double val
 *         if self._baseapi.GetDoubleVariable(name, &val):
 *             return val             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyFloat_FromDouble(__pyx_v_val); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "tesserocr.pyx":1179
 *         """
 *         cdef double val
 *         if self._baseapi.GetDoubleVariable(name, &val):             # <<<<<<<<<<<<<<
 *             return val
 *         return None
 */
  }

  /* "tesserocr.pyx":1181
 *         if self._baseapi.GetDoubleVariable(name, &val):
 *             return val
 *         return None             # <<<<<<<<<<<<<<
 * 
 *     def GetStringVariable(self, cchar_t *name):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "tesserocr.pyx":1173
 *         return None
 * 
 *     def GetDoubleVariable(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of the given double parameter if it exists among Tesseract parameters.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetDoubleVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1183
 *         return None
 * 
 *     def GetStringVariable(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of the given string parameter if it exists among Tesseract parameters.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_23GetStringVariable(PyObject *__pyx_v_self, PyObject *__pyx_arg_name); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_22GetStringVariable[] = "Return the value of the given string parameter if it exists among Tesseract parameters.\n\n        Returns ``None`` if the paramter was not found.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_23GetStringVariable(PyObject *__pyx_v_self, PyObject *__pyx_arg_name) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_name;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetStringVariable (wrapper)", 0);
  assert(__pyx_arg_name); {
    __pyx_v_name = __Pyx_PyObject_AsString(__pyx_arg_name); if (unlikely((!__pyx_v_name) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1183; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetStringVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_22GetStringVariable(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_22GetStringVariable(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_val;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetStringVariable", 0);

  /* "tesserocr.pyx":1188
 *         Returns ``None`` if the paramter was not found.
 *         """
 *         cdef cchar_t *val = self._baseapi.GetStringVariable(name)             # <<<<<<<<<<<<<<
 *         if val != NULL:
 *             return val
 */
  __pyx_v_val = __pyx_v_self->_baseapi.GetStringVariable(__pyx_v_name);

  /* "tesserocr.pyx":1189
 *         """
 *         cdef cchar_t *val = self._baseapi.GetStringVariable(name)
 *         if val != NULL:             # <<<<<<<<<<<<<<
 *             return val
 *         return None
 */
  __pyx_t_1 = ((__pyx_v_val != NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1190
 *         cdef cchar_t *val = self._baseapi.GetStringVariable(name)
 *         if val != NULL:
 *             return val             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_val); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "tesserocr.pyx":1189
 *         """
 *         cdef cchar_t *val = self._baseapi.GetStringVariable(name)
 *         if val != NULL:             # <<<<<<<<<<<<<<
 *             return val
 *         return None
 */
  }

  /* "tesserocr.pyx":1191
 *         if val != NULL:
 *             return val
 *         return None             # <<<<<<<<<<<<<<
 * 
 *     def GetVariableAsString(self, cchar_t *name):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "tesserocr.pyx":1183
 *         return None
 * 
 *     def GetStringVariable(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of the given string parameter if it exists among Tesseract parameters.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetStringVariable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1193
 *         return None
 * 
 *     def GetVariableAsString(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of named variable as a string (regardless of type),
 *         if it exists.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_25GetVariableAsString(PyObject *__pyx_v_self, PyObject *__pyx_arg_name); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_24GetVariableAsString[] = "Return the value of named variable as a string (regardless of type),\n        if it exists.\n\n        Returns ``None`` if paramter was not found.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_25GetVariableAsString(PyObject *__pyx_v_self, PyObject *__pyx_arg_name) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_name;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetVariableAsString (wrapper)", 0);
  assert(__pyx_arg_name); {
    __pyx_v_name = __Pyx_PyObject_AsString(__pyx_arg_name); if (unlikely((!__pyx_v_name) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1193; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetVariableAsString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_24GetVariableAsString(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_24GetVariableAsString(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_name) {
  STRING __pyx_v_val;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetVariableAsString", 0);

  /* "tesserocr.pyx":1200
 *         """
 *         cdef STRING val
 *         if self._baseapi.GetVariableAsString(name, &val):             # <<<<<<<<<<<<<<
 *             return val.string()
 *         return None
 */
  __pyx_t_1 = (__pyx_v_self->_baseapi.GetVariableAsString(__pyx_v_name, (&__pyx_v_val)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1201
 *         cdef STRING val
 *         if self._baseapi.GetVariableAsString(name, &val):
 *             return val.string()             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_val.string()); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "tesserocr.pyx":1200
 *         """
 *         cdef STRING val
 *         if self._baseapi.GetVariableAsString(name, &val):             # <<<<<<<<<<<<<<
 *             return val.string()
 *         return None
 */
  }

  /* "tesserocr.pyx":1202
 *         if self._baseapi.GetVariableAsString(name, &val):
 *             return val.string()
 *         return None             # <<<<<<<<<<<<<<
 * 
 *     def InitFull(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "tesserocr.pyx":1193
 *         return None
 * 
 *     def GetVariableAsString(self, cchar_t *name):             # <<<<<<<<<<<<<<
 *         """Return the value of named variable as a string (regardless of type),
 *         if it exists.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetVariableAsString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1204
 *         return None
 * 
 *     def InitFull(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,             # <<<<<<<<<<<<<<
 *              OcrEngineMode oem=OEM_DEFAULT, list configs=[], dict variables={},
 *              bool set_only_non_debug_params=False):
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_27InitFull(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_26InitFull[] = "Initialize the API with the given parameters (advanced).\n\n        It is entirely safe (and eventually will be efficient too) to call\n        :meth:`Init` multiple times on the same instance to change language, or just\n        to reset the classifier.\n\n        Page Segmentation Mode is set to :attr:`PSM.AUTO` after initialization by default.\n\n        Args:\n            path (str): The name of the parent directory of tessdata.\n                Must end in /.\n            lang (str): An ISO 639-3 language string. Defaults to 'eng'.\n                The language may be a string of the form [~]<lang>[+[~]<lang>]* indicating\n                that multiple languages are to be loaded. Eg hin+eng will load Hindi and\n                English. Languages may specify internally that they want to be loaded\n                with one or more other languages, so the ~ sign is available to override\n                that. Eg if hin were set to load eng by default, then hin+~eng would force\n                loading only hin. The number of loaded languages is limited only by\n                memory, with the caveat that loading additional languages will impact\n                both speed and accuracy, as there is more work to do to decide on the\n                applicable language, and there is more chance of hallucinating incorrect\n                words.\n            oem (int): OCR engine mode. Defaults to :attr:`OEM.DEFAULT`.\n                See :class:`OEM` for all avaialbe options.\n            configs (list): List of config files to load variables from.\n            variables (dict): Extra variables to be set.\n            set_only_non_debug_params (bool): If ``True``, only params that do not contain\n                \"debug\" in the name will be set.\n\n        Raises:\n            :exc:`RuntimeError`: If API initialization fails.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_27InitFull(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_path;
  __pyx_t_9tesseract_cchar_t *__pyx_v_lang;
  enum tesseract::OcrEngineMode __pyx_v_oem;
  PyObject *__pyx_v_configs = 0;
  PyObject *__pyx_v_variables = 0;
  bool __pyx_v_set_only_non_debug_params;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("InitFull (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_path,&__pyx_n_s_lang,&__pyx_n_s_oem,&__pyx_n_s_configs,&__pyx_n_s_variables,&__pyx_n_s_set_only_non_debug_params,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[3] = __pyx_k__9;
    values[4] = __pyx_k__10;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_path);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lang);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_oem);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_configs);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_variables);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_set_only_non_debug_params);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "InitFull") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1204; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_path = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_path) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1204; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_path = __pyx_k__11;
    }
    if (values[1]) {
      __pyx_v_lang = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_lang) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1204; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_lang = __pyx_k__12;
    }
    if (values[2]) {
      __pyx_v_oem = ((enum tesseract::OcrEngineMode)__Pyx_PyInt_As_enum__tesseract_3a__3a_OcrEngineMode(values[2])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_oem = __pyx_k__13;
    }
    __pyx_v_configs = ((PyObject*)values[3]);
    __pyx_v_variables = ((PyObject*)values[4]);
    if (values[5]) {
      __pyx_v_set_only_non_debug_params = __Pyx_PyObject_IsTrue(values[5]); if (unlikely((__pyx_v_set_only_non_debug_params == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1206; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "tesserocr.pyx":1206
 *     def InitFull(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,
 *              OcrEngineMode oem=OEM_DEFAULT, list configs=[], dict variables={},
 *              bool set_only_non_debug_params=False):             # <<<<<<<<<<<<<<
 *         """Initialize the API with the given parameters (advanced).
 * 
 */
      __pyx_v_set_only_non_debug_params = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("InitFull", 0, 0, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1204; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.InitFull", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_configs), (&PyList_Type), 1, "configs", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_variables), (&PyDict_Type), 1, "variables", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_26InitFull(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_path, __pyx_v_lang, __pyx_v_oem, __pyx_v_configs, __pyx_v_variables, __pyx_v_set_only_non_debug_params);

  /* "tesserocr.pyx":1204
 *         return None
 * 
 *     def InitFull(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,             # <<<<<<<<<<<<<<
 *              OcrEngineMode oem=OEM_DEFAULT, list configs=[], dict variables={},
 *              bool set_only_non_debug_params=False):
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_26InitFull(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::OcrEngineMode __pyx_v_oem, PyObject *__pyx_v_configs, PyObject *__pyx_v_variables, bool __pyx_v_set_only_non_debug_params) {
  int __pyx_v_configs_size;
  char **__pyx_v_configs_;
  GenericVector<STRING>  __pyx_v_vars_vec;
  GenericVector<STRING>  __pyx_v_vars_vals;
  __pyx_t_9tesseract_cchar_t *__pyx_v_val;
  STRING __pyx_v_sval;
  Py_ssize_t __pyx_v_i;
  PyObject *__pyx_v_c = NULL;
  PyObject *__pyx_v_k = NULL;
  PyObject *__pyx_v_v = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  Py_ssize_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  char *__pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  __pyx_t_9tesseract_cchar_t *__pyx_t_9;
  int __pyx_t_10;
  char const *__pyx_t_11;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("InitFull", 0);

  /* "tesserocr.pyx":1240
 *         """
 *         cdef:
 *             int configs_size = len(configs)             # <<<<<<<<<<<<<<
 *             char **configs_ = <char **>malloc(configs_size * sizeof(char *))
 *             GenericVector[STRING] vars_vec
 */
  if (unlikely(__pyx_v_configs == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_1 = PyList_GET_SIZE(__pyx_v_configs); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_configs_size = __pyx_t_1;

  /* "tesserocr.pyx":1241
 *         cdef:
 *             int configs_size = len(configs)
 *             char **configs_ = <char **>malloc(configs_size * sizeof(char *))             # <<<<<<<<<<<<<<
 *             GenericVector[STRING] vars_vec
 *             GenericVector[STRING] vars_vals
 */
  __pyx_v_configs_ = ((char **)malloc((__pyx_v_configs_size * (sizeof(char *)))));

  /* "tesserocr.pyx":1247
 *             STRING sval
 * 
 *         for i, c in enumerate(configs):             # <<<<<<<<<<<<<<
 *             configs_[i] = c
 * 
 */
  __pyx_t_1 = 0;
  __pyx_t_2 = __pyx_v_configs; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
  for (;;) {
    if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
    #if CYTHON_COMPILING_IN_CPYTHON
    __pyx_t_4 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_4); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    #else
    __pyx_t_4 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    #endif
    __Pyx_XDECREF_SET(__pyx_v_c, __pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_v_i = __pyx_t_1;
    __pyx_t_1 = (__pyx_t_1 + 1);

    /* "tesserocr.pyx":1248
 * 
 *         for i, c in enumerate(configs):
 *             configs_[i] = c             # <<<<<<<<<<<<<<
 * 
 *         for k, v in variables.iteritems():
 */
    __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_c); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    (__pyx_v_configs_[__pyx_v_i]) = __pyx_t_5;

    /* "tesserocr.pyx":1247
 *             STRING sval
 * 
 *         for i, c in enumerate(configs):             # <<<<<<<<<<<<<<
 *             configs_[i] = c
 * 
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":1250
 *             configs_[i] = c
 * 
 *         for k, v in variables.iteritems():             # <<<<<<<<<<<<<<
 *             val = k
 *             sval = val
 */
  __pyx_t_1 = 0;
  if (unlikely(__pyx_v_variables == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "iteritems");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_4 = __Pyx_dict_iterator(__pyx_v_variables, 1, __pyx_n_s_iteritems, (&__pyx_t_3), (&__pyx_t_6)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_2);
  __pyx_t_2 = __pyx_t_4;
  __pyx_t_4 = 0;
  while (1) {
    __pyx_t_8 = __Pyx_dict_iter_next(__pyx_t_2, __pyx_t_3, &__pyx_t_1, &__pyx_t_4, &__pyx_t_7, NULL, __pyx_t_6);
    if (unlikely(__pyx_t_8 == 0)) break;
    if (unlikely(__pyx_t_8 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_7);
    __pyx_t_7 = 0;

    /* "tesserocr.pyx":1251
 * 
 *         for k, v in variables.iteritems():
 *             val = k             # <<<<<<<<<<<<<<
 *             sval = val
 *             vars_vec.push_back(sval)
 */
    __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_k); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_val = __pyx_t_9;

    /* "tesserocr.pyx":1252
 *         for k, v in variables.iteritems():
 *             val = k
 *             sval = val             # <<<<<<<<<<<<<<
 *             vars_vec.push_back(sval)
 *             val = v
 */
    __pyx_v_sval = __pyx_v_val;

    /* "tesserocr.pyx":1253
 *             val = k
 *             sval = val
 *             vars_vec.push_back(sval)             # <<<<<<<<<<<<<<
 *             val = v
 *             sval = val
 */
    __pyx_v_vars_vec.push_back(__pyx_v_sval);

    /* "tesserocr.pyx":1254
 *             sval = val
 *             vars_vec.push_back(sval)
 *             val = v             # <<<<<<<<<<<<<<
 *             sval = val
 *             vars_vals.push_back(sval)
 */
    __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_v); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_val = __pyx_t_9;

    /* "tesserocr.pyx":1255
 *             vars_vec.push_back(sval)
 *             val = v
 *             sval = val             # <<<<<<<<<<<<<<
 *             vars_vals.push_back(sval)
 * 
 */
    __pyx_v_sval = __pyx_v_val;

    /* "tesserocr.pyx":1256
 *             val = v
 *             sval = val
 *             vars_vals.push_back(sval)             # <<<<<<<<<<<<<<
 * 
 *         with nogil:
 */
    __pyx_v_vars_vals.push_back(__pyx_v_sval);
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":1258
 *             vars_vals.push_back(sval)
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             try:
 *                 if self._init_api(path, lang, oem, configs_, configs_size, &vars_vec, &vars_vals,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1259
 * 
 *         with nogil:
 *             try:             # <<<<<<<<<<<<<<
 *                 if self._init_api(path, lang, oem, configs_, configs_size, &vars_vec, &vars_vals,
 *                                   set_only_non_debug_params, PSM_AUTO) == -1:
 */
        /*try:*/ {

          /* "tesserocr.pyx":1261
 *             try:
 *                 if self._init_api(path, lang, oem, configs_, configs_size, &vars_vec, &vars_vals,
 *                                   set_only_non_debug_params, PSM_AUTO) == -1:             # <<<<<<<<<<<<<<
 *                     with gil:
 *                         raise RuntimeError('Failed to initialize API')
 */
          __pyx_t_10 = ((((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_init_api(__pyx_v_self, __pyx_v_path, __pyx_v_lang, __pyx_v_oem, __pyx_v_configs_, __pyx_v_configs_size, (&__pyx_v_vars_vec), (&__pyx_v_vars_vals), __pyx_v_set_only_non_debug_params, tesseract::PSM_AUTO) == -1L) != 0);

          /* "tesserocr.pyx":1260
 *         with nogil:
 *             try:
 *                 if self._init_api(path, lang, oem, configs_, configs_size, &vars_vec, &vars_vals,             # <<<<<<<<<<<<<<
 *                                   set_only_non_debug_params, PSM_AUTO) == -1:
 *                     with gil:
 */
          if (__pyx_t_10) {

            /* "tesserocr.pyx":1262
 *                 if self._init_api(path, lang, oem, configs_, configs_size, &vars_vec, &vars_vals,
 *                                   set_only_non_debug_params, PSM_AUTO) == -1:
 *                     with gil:             # <<<<<<<<<<<<<<
 *                         raise RuntimeError('Failed to initialize API')
 *             finally:
 */
            {
                #ifdef WITH_THREAD
                PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
                #endif
                /*try:*/ {

                  /* "tesserocr.pyx":1263
 *                                   set_only_non_debug_params, PSM_AUTO) == -1:
 *                     with gil:
 *                         raise RuntimeError('Failed to initialize API')             # <<<<<<<<<<<<<<
 *             finally:
 *                 free(configs_)
 */
                  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1263; __pyx_clineno = __LINE__; goto __pyx_L15_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1263; __pyx_clineno = __LINE__; goto __pyx_L15_error;}
                }

                /* "tesserocr.pyx":1262
 *                 if self._init_api(path, lang, oem, configs_, configs_size, &vars_vec, &vars_vals,
 *                                   set_only_non_debug_params, PSM_AUTO) == -1:
 *                     with gil:             # <<<<<<<<<<<<<<
 *                         raise RuntimeError('Failed to initialize API')
 *             finally:
 */
                /*finally:*/ {
                  __pyx_L15_error: {
                    #ifdef WITH_THREAD
                    PyGILState_Release(__pyx_gilstate_save);
                    #endif
                    goto __pyx_L11_error;
                  }
                }
            }

            /* "tesserocr.pyx":1260
 *         with nogil:
 *             try:
 *                 if self._init_api(path, lang, oem, configs_, configs_size, &vars_vec, &vars_vals,             # <<<<<<<<<<<<<<
 *                                   set_only_non_debug_params, PSM_AUTO) == -1:
 *                     with gil:
 */
          }
        }

        /* "tesserocr.pyx":1265
 *                         raise RuntimeError('Failed to initialize API')
 *             finally:
 *                 free(configs_)             # <<<<<<<<<<<<<<
 * 
 *     def Init(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,
 */
        /*finally:*/ {
          /*normal exit:*/{
            free(__pyx_v_configs_);
            goto __pyx_L12;
          }
          /*exception exit:*/{
            #ifdef WITH_THREAD
            PyGILState_STATE __pyx_gilstate_save;
            #endif
            __pyx_L11_error:;
            __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0;
            #ifdef WITH_THREAD
            __pyx_gilstate_save = PyGILState_Ensure();
            #endif
            __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
            __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
            __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
            if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_15, &__pyx_t_16, &__pyx_t_17);
            if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_12, &__pyx_t_13, &__pyx_t_14) < 0)) __Pyx_ErrFetch(&__pyx_t_12, &__pyx_t_13, &__pyx_t_14);
            __Pyx_XGOTREF(__pyx_t_12);
            __Pyx_XGOTREF(__pyx_t_13);
            __Pyx_XGOTREF(__pyx_t_14);
            __Pyx_XGOTREF(__pyx_t_15);
            __Pyx_XGOTREF(__pyx_t_16);
            __Pyx_XGOTREF(__pyx_t_17);
            __pyx_t_6 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_11 = __pyx_filename;
            #ifdef WITH_THREAD
            PyGILState_Release(__pyx_gilstate_save);
            #endif
            {
              free(__pyx_v_configs_);
            }
            #ifdef WITH_THREAD
            __pyx_gilstate_save = PyGILState_Ensure();
            #endif
            if (PY_MAJOR_VERSION >= 3) {
              __Pyx_XGIVEREF(__pyx_t_15);
              __Pyx_XGIVEREF(__pyx_t_16);
              __Pyx_XGIVEREF(__pyx_t_17);
              __Pyx_ExceptionReset(__pyx_t_15, __pyx_t_16, __pyx_t_17);
            }
            __Pyx_XGIVEREF(__pyx_t_12);
            __Pyx_XGIVEREF(__pyx_t_13);
            __Pyx_XGIVEREF(__pyx_t_14);
            __Pyx_ErrRestore(__pyx_t_12, __pyx_t_13, __pyx_t_14);
            #ifdef WITH_THREAD
            PyGILState_Release(__pyx_gilstate_save);
            #endif
            __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0;
            __pyx_lineno = __pyx_t_6; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_11;
            goto __pyx_L8_error;
          }
          __pyx_L12:;
        }
      }

      /* "tesserocr.pyx":1258
 *             vars_vals.push_back(sval)
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             try:
 *                 if self._init_api(path, lang, oem, configs_, configs_size, &vars_vec, &vars_vals,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L9;
        }
        __pyx_L8_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L9:;
      }
  }

  /* "tesserocr.pyx":1204
 *         return None
 * 
 *     def InitFull(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,             # <<<<<<<<<<<<<<
 *              OcrEngineMode oem=OEM_DEFAULT, list configs=[], dict variables={},
 *              bool set_only_non_debug_params=False):
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.InitFull", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_c);
  __Pyx_XDECREF(__pyx_v_k);
  __Pyx_XDECREF(__pyx_v_v);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1267
 *                 free(configs_)
 * 
 *     def Init(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,             # <<<<<<<<<<<<<<
 *              OcrEngineMode oem=OEM_DEFAULT):
 *         """Initialize the API with the given data path, language and OCR engine mode.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_29Init(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_28Init[] = "Initialize the API with the given data path, language and OCR engine mode.\n\n        See :meth:`InitFull` for more intialization info and options.\n\n        Args:\n            path (str): The name of the parent directory of tessdata.\n                Must end in /. Uses default installation path if not specified.\n            lang (str): An ISO 639-3 language string. Defaults to 'eng'.\n                See :meth:`InitFull` for full description of this parameter.\n            oem (int): OCR engine mode. Defaults to :attr:`OEM.DEFAULT`.\n                See :class:`OEM` for all avaialbe options.\n\n        Raises:\n            :exc:`RuntimeError`: If API initialization fails.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_29Init(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_path;
  __pyx_t_9tesseract_cchar_t *__pyx_v_lang;
  enum tesseract::OcrEngineMode __pyx_v_oem;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Init (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_path,&__pyx_n_s_lang,&__pyx_n_s_oem,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_path);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lang);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_oem);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "Init") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1267; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_path = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_path) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1267; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_path = __pyx_k__15;
    }
    if (values[1]) {
      __pyx_v_lang = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_lang) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1267; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_lang = __pyx_k__16;
    }
    if (values[2]) {
      __pyx_v_oem = ((enum tesseract::OcrEngineMode)__Pyx_PyInt_As_enum__tesseract_3a__3a_OcrEngineMode(values[2])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_oem = __pyx_k__17;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("Init", 0, 0, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1267; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.Init", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_28Init(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_path, __pyx_v_lang, __pyx_v_oem);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_28Init(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::OcrEngineMode __pyx_v_oem) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Init", 0);

  /* "tesserocr.pyx":1284
 *             :exc:`RuntimeError`: If API initialization fails.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             if self._init_api(path, lang, oem, NULL, 0, NULL, NULL, False, PSM_AUTO) == -1:
 *                 with gil:
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1285
 *         """
 *         with nogil:
 *             if self._init_api(path, lang, oem, NULL, 0, NULL, NULL, False, PSM_AUTO) == -1:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to initialize API')
 */
        __pyx_t_1 = ((((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_init_api(__pyx_v_self, __pyx_v_path, __pyx_v_lang, __pyx_v_oem, NULL, 0, NULL, NULL, 0, tesseract::PSM_AUTO) == -1L) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":1286
 *         with nogil:
 *             if self._init_api(path, lang, oem, NULL, 0, NULL, NULL, False, PSM_AUTO) == -1:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to initialize API')
 * 
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":1287
 *             if self._init_api(path, lang, oem, NULL, 0, NULL, NULL, False, PSM_AUTO) == -1:
 *                 with gil:
 *                     raise RuntimeError('Failed to initialize API')             # <<<<<<<<<<<<<<
 * 
 *     def GetInitLanguagesAsString(self):
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1287; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1287; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":1286
 *         with nogil:
 *             if self._init_api(path, lang, oem, NULL, 0, NULL, NULL, False, PSM_AUTO) == -1:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to initialize API')
 * 
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":1285
 *         """
 *         with nogil:
 *             if self._init_api(path, lang, oem, NULL, 0, NULL, NULL, False, PSM_AUTO) == -1:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to initialize API')
 */
        }
      }

      /* "tesserocr.pyx":1284
 *             :exc:`RuntimeError`: If API initialization fails.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             if self._init_api(path, lang, oem, NULL, 0, NULL, NULL, False, PSM_AUTO) == -1:
 *                 with gil:
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1267
 *                 free(configs_)
 * 
 *     def Init(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,             # <<<<<<<<<<<<<<
 *              OcrEngineMode oem=OEM_DEFAULT):
 *         """Initialize the API with the given data path, language and OCR engine mode.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.Init", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1289
 *                     raise RuntimeError('Failed to initialize API')
 * 
 *     def GetInitLanguagesAsString(self):             # <<<<<<<<<<<<<<
 *         """Return the languages string used in the last valid initialization.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_31GetInitLanguagesAsString(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_30GetInitLanguagesAsString[] = "Return the languages string used in the last valid initialization.\n\n        If the last initialization specified \"deu+hin\" then that will be\n        returned. If hin loaded eng automatically as well, then that will\n        not be included in this list. To find the languages actually\n        loaded use :meth:`GetLoadedLanguages`.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_31GetInitLanguagesAsString(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetInitLanguagesAsString (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_30GetInitLanguagesAsString(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_30GetInitLanguagesAsString(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetInitLanguagesAsString", 0);

  /* "tesserocr.pyx":1297
 *         loaded use :meth:`GetLoadedLanguages`.
 *         """
 *         return self._baseapi.GetInitLanguagesAsString()             # <<<<<<<<<<<<<<
 * 
 *     def GetLoadedLanguages(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_self->_baseapi.GetInitLanguagesAsString()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1289
 *                     raise RuntimeError('Failed to initialize API')
 * 
 *     def GetInitLanguagesAsString(self):             # <<<<<<<<<<<<<<
 *         """Return the languages string used in the last valid initialization.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetInitLanguagesAsString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1299
 *         return self._baseapi.GetInitLanguagesAsString()
 * 
 *     def GetLoadedLanguages(self):             # <<<<<<<<<<<<<<
 *         """Return the loaded languages as a list of STRINGs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_33GetLoadedLanguages(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_32GetLoadedLanguages[] = "Return the loaded languages as a list of STRINGs.\n\n        Includes all languages loaded by the last Init, including those loaded\n        as dependencies of other loaded languages.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_33GetLoadedLanguages(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetLoadedLanguages (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_32GetLoadedLanguages(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_32GetLoadedLanguages(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  GenericVector<STRING>  __pyx_v_langs;
  int __pyx_v_i;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetLoadedLanguages", 0);

  /* "tesserocr.pyx":1306
 *         """
 *         cdef GenericVector[STRING] langs
 *         self._baseapi.GetLoadedLanguagesAsVector(&langs)             # <<<<<<<<<<<<<<
 *         return [langs[i].string() for i in xrange(langs.size())]
 * 
 */
  __pyx_v_self->_baseapi.GetLoadedLanguagesAsVector((&__pyx_v_langs));

  /* "tesserocr.pyx":1307
 *         cdef GenericVector[STRING] langs
 *         self._baseapi.GetLoadedLanguagesAsVector(&langs)
 *         return [langs[i].string() for i in xrange(langs.size())]             # <<<<<<<<<<<<<<
 * 
 *     def GetAvailableLanguages(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_v_langs.size();
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
    __pyx_v_i = __pyx_t_3;
    __pyx_t_4 = __Pyx_PyUnicode_FromString((__pyx_v_langs[__pyx_v_i]).string()); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_4))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1299
 *         return self._baseapi.GetInitLanguagesAsString()
 * 
 *     def GetLoadedLanguages(self):             # <<<<<<<<<<<<<<
 *         """Return the loaded languages as a list of STRINGs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetLoadedLanguages", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1309
 *         return [langs[i].string() for i in xrange(langs.size())]
 * 
 *     def GetAvailableLanguages(self):             # <<<<<<<<<<<<<<
 *         """Return list of available languages in the init data path"""
 *         cdef:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_35GetAvailableLanguages(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_34GetAvailableLanguages[] = "Return list of available languages in the init data path";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_35GetAvailableLanguages(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetAvailableLanguages (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_34GetAvailableLanguages(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_34GetAvailableLanguages(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  GenericVector<STRING>  __pyx_v_v;
  int __pyx_v_i;
  PyObject *__pyx_v_langs = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetAvailableLanguages", 0);

  /* "tesserocr.pyx":1314
 *             GenericVector[STRING] v
 *             int i
 *         langs = []             # <<<<<<<<<<<<<<
 *         self._baseapi.GetAvailableLanguagesAsVector(&v)
 *         langs = [v[i].string() for i in xrange(v.size())]
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_langs = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":1315
 *             int i
 *         langs = []
 *         self._baseapi.GetAvailableLanguagesAsVector(&v)             # <<<<<<<<<<<<<<
 *         langs = [v[i].string() for i in xrange(v.size())]
 *         return langs
 */
  __pyx_v_self->_baseapi.GetAvailableLanguagesAsVector((&__pyx_v_v));

  /* "tesserocr.pyx":1316
 *         langs = []
 *         self._baseapi.GetAvailableLanguagesAsVector(&v)
 *         langs = [v[i].string() for i in xrange(v.size())]             # <<<<<<<<<<<<<<
 *         return langs
 * 
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_v_v.size();
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
    __pyx_v_i = __pyx_t_3;
    __pyx_t_4 = __Pyx_PyUnicode_FromString((__pyx_v_v[__pyx_v_i]).string()); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_4))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF_SET(__pyx_v_langs, ((PyObject*)__pyx_t_1));
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":1317
 *         self._baseapi.GetAvailableLanguagesAsVector(&v)
 *         langs = [v[i].string() for i in xrange(v.size())]
 *         return langs             # <<<<<<<<<<<<<<
 * 
 *     def InitForAnalysePage(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_langs);
  __pyx_r = __pyx_v_langs;
  goto __pyx_L0;

  /* "tesserocr.pyx":1309
 *         return [langs[i].string() for i in xrange(langs.size())]
 * 
 *     def GetAvailableLanguages(self):             # <<<<<<<<<<<<<<
 *         """Return list of available languages in the init data path"""
 *         cdef:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetAvailableLanguages", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_langs);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1319
 *         return langs
 * 
 *     def InitForAnalysePage(self):             # <<<<<<<<<<<<<<
 *         """Init only for page layout analysis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_37InitForAnalysePage(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_36InitForAnalysePage[] = "Init only for page layout analysis.\n\n        Use only for calls to :meth:`SetImage` and :meth:`AnalysePage`.\n        Calls that attempt recognition will generate an error.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_37InitForAnalysePage(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("InitForAnalysePage (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_36InitForAnalysePage(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_36InitForAnalysePage(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("InitForAnalysePage", 0);

  /* "tesserocr.pyx":1325
 *         Calls that attempt recognition will generate an error.
 *         """
 *         self._baseapi.InitForAnalysePage()             # <<<<<<<<<<<<<<
 * 
 *     def ReadConfigFile(self, cchar_t *filename):
 */
  __pyx_v_self->_baseapi.InitForAnalysePage();

  /* "tesserocr.pyx":1319
 *         return langs
 * 
 *     def InitForAnalysePage(self):             # <<<<<<<<<<<<<<
 *         """Init only for page layout analysis.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1327
 *         self._baseapi.InitForAnalysePage()
 * 
 *     def ReadConfigFile(self, cchar_t *filename):             # <<<<<<<<<<<<<<
 *         """Read a "config" file containing a set of param, value pairs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_39ReadConfigFile(PyObject *__pyx_v_self, PyObject *__pyx_arg_filename); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_38ReadConfigFile[] = "Read a \"config\" file containing a set of param, value pairs.\n\n        Searches the standard places: tessdata/configs, tessdata/tessconfigs.\n\n        Args:\n            filename: config file name. Also accepts relative or absolute path name.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_39ReadConfigFile(PyObject *__pyx_v_self, PyObject *__pyx_arg_filename) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_filename;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ReadConfigFile (wrapper)", 0);
  assert(__pyx_arg_filename); {
    __pyx_v_filename = __Pyx_PyObject_AsString(__pyx_arg_filename); if (unlikely((!__pyx_v_filename) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1327; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.ReadConfigFile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_38ReadConfigFile(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_filename));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_38ReadConfigFile(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_filename) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ReadConfigFile", 0);

  /* "tesserocr.pyx":1335
 *             filename: config file name. Also accepts relative or absolute path name.
 *         """
 *         self._baseapi.ReadConfigFile(filename)             # <<<<<<<<<<<<<<
 * 
 *     def SetPageSegMode(self, PageSegMode psm):
 */
  __pyx_v_self->_baseapi.ReadConfigFile(__pyx_v_filename);

  /* "tesserocr.pyx":1327
 *         self._baseapi.InitForAnalysePage()
 * 
 *     def ReadConfigFile(self, cchar_t *filename):             # <<<<<<<<<<<<<<
 *         """Read a "config" file containing a set of param, value pairs.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1337
 *         self._baseapi.ReadConfigFile(filename)
 * 
 *     def SetPageSegMode(self, PageSegMode psm):             # <<<<<<<<<<<<<<
 *         """Set page segmentation mode.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_41SetPageSegMode(PyObject *__pyx_v_self, PyObject *__pyx_arg_psm); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_40SetPageSegMode[] = "Set page segmentation mode.\n\n        Args:\n            psm (int): page segmentation mode.\n                See :class:`PSM` for all available psm options.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_41SetPageSegMode(PyObject *__pyx_v_self, PyObject *__pyx_arg_psm) {
  enum tesseract::PageSegMode __pyx_v_psm;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetPageSegMode (wrapper)", 0);
  assert(__pyx_arg_psm); {
    __pyx_v_psm = ((enum tesseract::PageSegMode)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageSegMode(__pyx_arg_psm)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1337; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetPageSegMode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_40SetPageSegMode(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((enum tesseract::PageSegMode)__pyx_v_psm));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_40SetPageSegMode(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, enum tesseract::PageSegMode __pyx_v_psm) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetPageSegMode", 0);

  /* "tesserocr.pyx":1344
 *                 See :class:`PSM` for all available psm options.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._baseapi.SetPageSegMode(psm)
 * 
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1345
 *         """
 *         with nogil:
 *             self._baseapi.SetPageSegMode(psm)             # <<<<<<<<<<<<<<
 * 
 *     def GetPageSegMode(self):
 */
        __pyx_v_self->_baseapi.SetPageSegMode(__pyx_v_psm);
      }

      /* "tesserocr.pyx":1344
 *                 See :class:`PSM` for all available psm options.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._baseapi.SetPageSegMode(psm)
 * 
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1337
 *         self._baseapi.ReadConfigFile(filename)
 * 
 *     def SetPageSegMode(self, PageSegMode psm):             # <<<<<<<<<<<<<<
 *         """Set page segmentation mode.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1347
 *             self._baseapi.SetPageSegMode(psm)
 * 
 *     def GetPageSegMode(self):             # <<<<<<<<<<<<<<
 *         """Return the current page segmentation mode."""
 *         return self._baseapi.GetPageSegMode()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_43GetPageSegMode(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_42GetPageSegMode[] = "Return the current page segmentation mode.";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_43GetPageSegMode(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetPageSegMode (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_42GetPageSegMode(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_42GetPageSegMode(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetPageSegMode", 0);

  /* "tesserocr.pyx":1349
 *     def GetPageSegMode(self):
 *         """Return the current page segmentation mode."""
 *         return self._baseapi.GetPageSegMode()             # <<<<<<<<<<<<<<
 * 
 *     def TesseractRect(self, cuchar_t* imagedata,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(__pyx_v_self->_baseapi.GetPageSegMode()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1347
 *             self._baseapi.SetPageSegMode(psm)
 * 
 *     def GetPageSegMode(self):             # <<<<<<<<<<<<<<
 *         """Return the current page segmentation mode."""
 *         return self._baseapi.GetPageSegMode()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetPageSegMode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1351
 *         return self._baseapi.GetPageSegMode()
 * 
 *     def TesseractRect(self, cuchar_t* imagedata,             # <<<<<<<<<<<<<<
 *                       int bytes_per_pixel, int bytes_per_line,
 *                       int left, int top, int width, int height):
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_45TesseractRect(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_44TesseractRect[] = "Recognize a rectangle from an image and return the result as a string.\n\n        May be called many times for a single Init.\n        Currently has no error checking.\n\n        .. note::\n\n            `TesseractRect` is the simplified convenience interface. For advanced\n            uses, use :meth:`SetImage`, (optionally) :meth:`SetRectangle`,\n            :meth:`Recognize`, and one or more of the `Get*Text` methods below.\n\n        Args:\n            imagedata (str): Raw image bytes.\n            bytes_per_pixel (int): bytes per pixel.\n                Greyscale of 8 and color of 24 or 32 bits per pixel may be given.\n                Palette color images will not work properly and must be converted to\n                24 bit.\n                Binary images of 1 bit per pixel may also be given but they must be\n                byte packed with the MSB of the first byte being the first pixel, and a\n                1 represents WHITE. For binary images set bytes_per_pixel=0.\n            bytes_per_line (int): bytes per line.\n            left (int): left rectangle ordonate.\n            top (int): top rectangle ordonate.\n            width (int): image width.\n            height (int): image height.\n\n        Returns:\n            unicode: The recognized text as UTF8.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_45TesseractRect(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cuchar_t *__pyx_v_imagedata;
  int __pyx_v_bytes_per_pixel;
  int __pyx_v_bytes_per_line;
  int __pyx_v_left;
  int __pyx_v_top;
  int __pyx_v_width;
  int __pyx_v_height;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TesseractRect (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_imagedata,&__pyx_n_s_bytes_per_pixel,&__pyx_n_s_bytes_per_line,&__pyx_n_s_left,&__pyx_n_s_top,&__pyx_n_s_width,&__pyx_n_s_height,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_imagedata)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bytes_per_pixel)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TesseractRect", 1, 7, 7, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bytes_per_line)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TesseractRect", 1, 7, 7, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TesseractRect", 1, 7, 7, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (likely((values[4] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_top)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TesseractRect", 1, 7, 7, 4); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  5:
        if (likely((values[5] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_width)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TesseractRect", 1, 7, 7, 5); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  6:
        if (likely((values[6] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_height)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TesseractRect", 1, 7, 7, 6); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "TesseractRect") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 7) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
      values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
      values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
    }
    __pyx_v_imagedata = __Pyx_PyObject_AsUString(values[0]); if (unlikely((!__pyx_v_imagedata) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_bytes_per_pixel = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_bytes_per_pixel == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1352; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_bytes_per_line = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_bytes_per_line == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1352; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_left = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_left == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_top = __Pyx_PyInt_As_int(values[4]); if (unlikely((__pyx_v_top == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_width = __Pyx_PyInt_As_int(values[5]); if (unlikely((__pyx_v_width == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_height = __Pyx_PyInt_As_int(values[6]); if (unlikely((__pyx_v_height == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("TesseractRect", 1, 7, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1351; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.TesseractRect", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_44TesseractRect(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_imagedata, __pyx_v_bytes_per_pixel, __pyx_v_bytes_per_line, __pyx_v_left, __pyx_v_top, __pyx_v_width, __pyx_v_height);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_44TesseractRect(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cuchar_t *__pyx_v_imagedata, int __pyx_v_bytes_per_pixel, int __pyx_v_bytes_per_line, int __pyx_v_left, int __pyx_v_top, int __pyx_v_width, int __pyx_v_height) {
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TesseractRect", 0);

  /* "tesserocr.pyx":1384
 *         """
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.TesseractRect(imagedata, bytes_per_pixel, bytes_per_line,
 *                                                left, top, width, height)
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1385
 *         cdef char *text
 *         with nogil:
 *             text = self._baseapi.TesseractRect(imagedata, bytes_per_pixel, bytes_per_line,             # <<<<<<<<<<<<<<
 *                                                left, top, width, height)
 *             if text == NULL:
 */
        __pyx_v_text = __pyx_v_self->_baseapi.TesseractRect(__pyx_v_imagedata, __pyx_v_bytes_per_pixel, __pyx_v_bytes_per_line, __pyx_v_left, __pyx_v_top, __pyx_v_width, __pyx_v_height);

        /* "tesserocr.pyx":1387
 *             text = self._baseapi.TesseractRect(imagedata, bytes_per_pixel, bytes_per_line,
 *                                                left, top, width, height)
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize image')
 */
        __pyx_t_1 = ((__pyx_v_text == NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":1388
 *                                                left, top, width, height)
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize image')
 *         return _free_str(text)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":1389
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize image')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1389; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1389; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":1388
 *                                                left, top, width, height)
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize image')
 *         return _free_str(text)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":1387
 *             text = self._baseapi.TesseractRect(imagedata, bytes_per_pixel, bytes_per_line,
 *                                                left, top, width, height)
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize image')
 */
        }
      }

      /* "tesserocr.pyx":1384
 *         """
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.TesseractRect(imagedata, bytes_per_pixel, bytes_per_line,
 *                                                left, top, width, height)
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1390
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize image')
 *         return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 *     def ClearAdaptiveClassifier(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1351
 *         return self._baseapi.GetPageSegMode()
 * 
 *     def TesseractRect(self, cuchar_t* imagedata,             # <<<<<<<<<<<<<<
 *                       int bytes_per_pixel, int bytes_per_line,
 *                       int left, int top, int width, int height):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.TesseractRect", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1392
 *         return _free_str(text)
 * 
 *     def ClearAdaptiveClassifier(self):             # <<<<<<<<<<<<<<
 *         """Call between pages or documents etc to free up memory and forget
 *         adaptive data.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_47ClearAdaptiveClassifier(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_46ClearAdaptiveClassifier[] = "Call between pages or documents etc to free up memory and forget\n        adaptive data.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_47ClearAdaptiveClassifier(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ClearAdaptiveClassifier (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_46ClearAdaptiveClassifier(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_46ClearAdaptiveClassifier(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ClearAdaptiveClassifier", 0);

  /* "tesserocr.pyx":1396
 *         adaptive data.
 *         """
 *         self._baseapi.ClearAdaptiveClassifier()             # <<<<<<<<<<<<<<
 * 
 *     def SetImageBytes(self, cuchar_t *imagedata, int width, int height,
 */
  __pyx_v_self->_baseapi.ClearAdaptiveClassifier();

  /* "tesserocr.pyx":1392
 *         return _free_str(text)
 * 
 *     def ClearAdaptiveClassifier(self):             # <<<<<<<<<<<<<<
 *         """Call between pages or documents etc to free up memory and forget
 *         adaptive data.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1398
 *         self._baseapi.ClearAdaptiveClassifier()
 * 
 *     def SetImageBytes(self, cuchar_t *imagedata, int width, int height,             # <<<<<<<<<<<<<<
 *                       int bytes_per_pixel, int bytes_per_line):
 *         """Provide an image for Tesseract to recognize.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_49SetImageBytes(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_48SetImageBytes[] = "Provide an image for Tesseract to recognize.\n\n        Format is as :meth:`TesseractRect` above. Does not copy the image buffer, or take\n        ownership. The source image may be destroyed after Recognize is called,\n        either explicitly or implicitly via one of the `Get*Text` methods.\n\n        This method clears all recognition results, and sets the rectangle to the\n        full image, so it may be followed immediately by a :meth:`GetUTF8Text`, and it\n        will automatically perform recognition.\n\n        Args:\n            imagedata (str): Raw image bytes.\n            width (int): image width.\n            height (int): image height.\n            bytes_per_pixel (int): bytes per pixel.\n                Greyscale of 8 and color of 24 or 32 bits per pixel may be given.\n                Palette color images will not work properly and must be converted to\n                24 bit.\n                Binary images of 1 bit per pixel may also be given but they must be\n                byte packed with the MSB of the first byte being the first pixel, and a\n                1 represents WHITE. For binary images set bytes_per_pixel=0.\n            bytes_per_line (int): bytes per line.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_49SetImageBytes(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cuchar_t *__pyx_v_imagedata;
  int __pyx_v_width;
  int __pyx_v_height;
  int __pyx_v_bytes_per_pixel;
  int __pyx_v_bytes_per_line;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetImageBytes (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_imagedata,&__pyx_n_s_width,&__pyx_n_s_height,&__pyx_n_s_bytes_per_pixel,&__pyx_n_s_bytes_per_line,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_imagedata)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_width)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetImageBytes", 1, 5, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_height)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetImageBytes", 1, 5, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bytes_per_pixel)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetImageBytes", 1, 5, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (likely((values[4] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bytes_per_line)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetImageBytes", 1, 5, 5, 4); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SetImageBytes") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
    }
    __pyx_v_imagedata = __Pyx_PyObject_AsUString(values[0]); if (unlikely((!__pyx_v_imagedata) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_width = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_width == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_height = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_height == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_bytes_per_pixel = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_bytes_per_pixel == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1399; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_bytes_per_line = __Pyx_PyInt_As_int(values[4]); if (unlikely((__pyx_v_bytes_per_line == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1399; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetImageBytes", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetImageBytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_48SetImageBytes(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_imagedata, __pyx_v_width, __pyx_v_height, __pyx_v_bytes_per_pixel, __pyx_v_bytes_per_line);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_48SetImageBytes(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cuchar_t *__pyx_v_imagedata, int __pyx_v_width, int __pyx_v_height, int __pyx_v_bytes_per_pixel, int __pyx_v_bytes_per_line) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetImageBytes", 0);

  /* "tesserocr.pyx":1423
 *             bytes_per_line (int): bytes per line.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             self._baseapi.SetImage(imagedata, width, height, bytes_per_pixel, bytes_per_line)
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1424
 *         """
 *         with nogil:
 *             self._destroy_pix()             # <<<<<<<<<<<<<<
 *             self._baseapi.SetImage(imagedata, width, height, bytes_per_pixel, bytes_per_line)
 * 
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

        /* "tesserocr.pyx":1425
 *         with nogil:
 *             self._destroy_pix()
 *             self._baseapi.SetImage(imagedata, width, height, bytes_per_pixel, bytes_per_line)             # <<<<<<<<<<<<<<
 * 
 *     def SetImage(self, image):
 */
        __pyx_v_self->_baseapi.SetImage(__pyx_v_imagedata, __pyx_v_width, __pyx_v_height, __pyx_v_bytes_per_pixel, __pyx_v_bytes_per_line);
      }

      /* "tesserocr.pyx":1423
 *             bytes_per_line (int): bytes per line.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             self._baseapi.SetImage(imagedata, width, height, bytes_per_pixel, bytes_per_line)
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1398
 *         self._baseapi.ClearAdaptiveClassifier()
 * 
 *     def SetImageBytes(self, cuchar_t *imagedata, int width, int height,             # <<<<<<<<<<<<<<
 *                       int bytes_per_pixel, int bytes_per_line):
 *         """Provide an image for Tesseract to recognize.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1427
 *             self._baseapi.SetImage(imagedata, width, height, bytes_per_pixel, bytes_per_line)
 * 
 *     def SetImage(self, image):             # <<<<<<<<<<<<<<
 *         """Provide an image for Tesseract to recognize.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_51SetImage(PyObject *__pyx_v_self, PyObject *__pyx_v_image); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_50SetImage[] = "Provide an image for Tesseract to recognize.\n\n        This method can be called multiple times after :meth:`Init`.\n\n        Args:\n            image (:class:PIL.Image): Image object.\n\n        Raises:\n            :exc:`RuntimeError`: If for any reason the api failed\n                to load the given image.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_51SetImage(PyObject *__pyx_v_self, PyObject *__pyx_v_image) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetImage (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_50SetImage(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((PyObject *)__pyx_v_image));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_50SetImage(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, PyObject *__pyx_v_image) {
  __pyx_t_9tesseract_cuchar_t *__pyx_v_buff;
  size_t __pyx_v_size;
  PyObject *__pyx_v_raw = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __pyx_t_9tesseract_cuchar_t *__pyx_t_2;
  Py_ssize_t __pyx_t_3;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SetImage", 0);

  /* "tesserocr.pyx":1444
 *             str raw
 * 
 *         raw = _image_buffer(image)             # <<<<<<<<<<<<<<
 *         buff = raw
 *         size = len(raw)
 */
  __pyx_t_1 = __pyx_f_9tesserocr__image_buffer(__pyx_v_image); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_raw = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":1445
 * 
 *         raw = _image_buffer(image)
 *         buff = raw             # <<<<<<<<<<<<<<
 *         size = len(raw)
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_AsUString(__pyx_v_raw); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_buff = __pyx_t_2;

  /* "tesserocr.pyx":1446
 *         raw = _image_buffer(image)
 *         buff = raw
 *         size = len(raw)             # <<<<<<<<<<<<<<
 * 
 *         with nogil:
 */
  __pyx_t_3 = PyObject_Length(__pyx_v_raw); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1446; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_size = __pyx_t_3;

  /* "tesserocr.pyx":1448
 *         size = len(raw)
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             self._pix = pixReadMemBmp(buff, size)
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1449
 * 
 *         with nogil:
 *             self._destroy_pix()             # <<<<<<<<<<<<<<
 *             self._pix = pixReadMemBmp(buff, size)
 *             if self._pix == NULL:
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

        /* "tesserocr.pyx":1450
 *         with nogil:
 *             self._destroy_pix()
 *             self._pix = pixReadMemBmp(buff, size)             # <<<<<<<<<<<<<<
 *             if self._pix == NULL:
 *                 with gil:
 */
        __pyx_v_self->_pix = pixReadMemBmp(__pyx_v_buff, __pyx_v_size);

        /* "tesserocr.pyx":1451
 *             self._destroy_pix()
 *             self._pix = pixReadMemBmp(buff, size)
 *             if self._pix == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Error reading image')
 */
        __pyx_t_4 = ((__pyx_v_self->_pix == NULL) != 0);
        if (__pyx_t_4) {

          /* "tesserocr.pyx":1452
 *             self._pix = pixReadMemBmp(buff, size)
 *             if self._pix == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Error reading image')
 *             self._baseapi.SetImage(self._pix)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":1453
 *             if self._pix == NULL:
 *                 with gil:
 *                     raise RuntimeError('Error reading image')             # <<<<<<<<<<<<<<
 *             self._baseapi.SetImage(self._pix)
 * 
 */
                __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1453; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_1);
                __Pyx_Raise(__pyx_t_1, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1453; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":1452
 *             self._pix = pixReadMemBmp(buff, size)
 *             if self._pix == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Error reading image')
 *             self._baseapi.SetImage(self._pix)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":1451
 *             self._destroy_pix()
 *             self._pix = pixReadMemBmp(buff, size)
 *             if self._pix == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Error reading image')
 */
        }

        /* "tesserocr.pyx":1454
 *                 with gil:
 *                     raise RuntimeError('Error reading image')
 *             self._baseapi.SetImage(self._pix)             # <<<<<<<<<<<<<<
 * 
 *     def SetImageFile(self, cchar_t *filename):
 */
        __pyx_v_self->_baseapi.SetImage(__pyx_v_self->_pix);
      }

      /* "tesserocr.pyx":1448
 *         size = len(raw)
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             self._pix = pixReadMemBmp(buff, size)
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1427
 *             self._baseapi.SetImage(imagedata, width, height, bytes_per_pixel, bytes_per_line)
 * 
 *     def SetImage(self, image):             # <<<<<<<<<<<<<<
 *         """Provide an image for Tesseract to recognize.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetImage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_raw);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1456
 *             self._baseapi.SetImage(self._pix)
 * 
 *     def SetImageFile(self, cchar_t *filename):             # <<<<<<<<<<<<<<
 *         """Set image from file for Tesserac to recognize.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_53SetImageFile(PyObject *__pyx_v_self, PyObject *__pyx_arg_filename); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_52SetImageFile[] = "Set image from file for Tesserac to recognize.\n\n        Args:\n            filename (str): Image file relative or absolute path.\n\n        Raises:\n            :exc:`RuntimeError`: If for any reason the api failed\n                to load the given image.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_53SetImageFile(PyObject *__pyx_v_self, PyObject *__pyx_arg_filename) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_filename;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetImageFile (wrapper)", 0);
  assert(__pyx_arg_filename); {
    __pyx_v_filename = __Pyx_PyObject_AsString(__pyx_arg_filename); if (unlikely((!__pyx_v_filename) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1456; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetImageFile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_52SetImageFile(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_filename));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_52SetImageFile(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_filename) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SetImageFile", 0);

  /* "tesserocr.pyx":1466
 *                 to load the given image.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             self._pix = pixRead(filename)
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1467
 *         """
 *         with nogil:
 *             self._destroy_pix()             # <<<<<<<<<<<<<<
 *             self._pix = pixRead(filename)
 *             if self._pix == NULL:
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

        /* "tesserocr.pyx":1468
 *         with nogil:
 *             self._destroy_pix()
 *             self._pix = pixRead(filename)             # <<<<<<<<<<<<<<
 *             if self._pix == NULL:
 *                 with gil:
 */
        __pyx_v_self->_pix = pixRead(__pyx_v_filename);

        /* "tesserocr.pyx":1469
 *             self._destroy_pix()
 *             self._pix = pixRead(filename)
 *             if self._pix == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Error reading image')
 */
        __pyx_t_1 = ((__pyx_v_self->_pix == NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":1470
 *             self._pix = pixRead(filename)
 *             if self._pix == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Error reading image')
 *             self._baseapi.SetImage(self._pix)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":1471
 *             if self._pix == NULL:
 *                 with gil:
 *                     raise RuntimeError('Error reading image')             # <<<<<<<<<<<<<<
 *             self._baseapi.SetImage(self._pix)
 * 
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1471; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1471; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":1470
 *             self._pix = pixRead(filename)
 *             if self._pix == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Error reading image')
 *             self._baseapi.SetImage(self._pix)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":1469
 *             self._destroy_pix()
 *             self._pix = pixRead(filename)
 *             if self._pix == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Error reading image')
 */
        }

        /* "tesserocr.pyx":1472
 *                 with gil:
 *                     raise RuntimeError('Error reading image')
 *             self._baseapi.SetImage(self._pix)             # <<<<<<<<<<<<<<
 * 
 *     def SetSourceResolution(self, int ppi):
 */
        __pyx_v_self->_baseapi.SetImage(__pyx_v_self->_pix);
      }

      /* "tesserocr.pyx":1466
 *                 to load the given image.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             self._pix = pixRead(filename)
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1456
 *             self._baseapi.SetImage(self._pix)
 * 
 *     def SetImageFile(self, cchar_t *filename):             # <<<<<<<<<<<<<<
 *         """Set image from file for Tesserac to recognize.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetImageFile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1474
 *             self._baseapi.SetImage(self._pix)
 * 
 *     def SetSourceResolution(self, int ppi):             # <<<<<<<<<<<<<<
 *         """Set the resolution of the source image in pixels per inch so font size
 *         information can be calculated in results.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_55SetSourceResolution(PyObject *__pyx_v_self, PyObject *__pyx_arg_ppi); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_54SetSourceResolution[] = "Set the resolution of the source image in pixels per inch so font size\n        information can be calculated in results.\n\n        Call this after :meth:`SetImage`.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_55SetSourceResolution(PyObject *__pyx_v_self, PyObject *__pyx_arg_ppi) {
  int __pyx_v_ppi;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetSourceResolution (wrapper)", 0);
  assert(__pyx_arg_ppi); {
    __pyx_v_ppi = __Pyx_PyInt_As_int(__pyx_arg_ppi); if (unlikely((__pyx_v_ppi == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1474; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetSourceResolution", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_54SetSourceResolution(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((int)__pyx_v_ppi));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_54SetSourceResolution(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_ppi) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetSourceResolution", 0);

  /* "tesserocr.pyx":1480
 *         Call this after :meth:`SetImage`.
 *         """
 *         self._baseapi.SetSourceResolution(ppi)             # <<<<<<<<<<<<<<
 * 
 *     def SetRectangle(self, int left, int top, int width, int height):
 */
  __pyx_v_self->_baseapi.SetSourceResolution(__pyx_v_ppi);

  /* "tesserocr.pyx":1474
 *             self._baseapi.SetImage(self._pix)
 * 
 *     def SetSourceResolution(self, int ppi):             # <<<<<<<<<<<<<<
 *         """Set the resolution of the source image in pixels per inch so font size
 *         information can be calculated in results.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1482
 *         self._baseapi.SetSourceResolution(ppi)
 * 
 *     def SetRectangle(self, int left, int top, int width, int height):             # <<<<<<<<<<<<<<
 *         """Restrict recognition to a sub-rectangle of the image. Call after :meth:`SetImage`.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_57SetRectangle(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_56SetRectangle[] = "Restrict recognition to a sub-rectangle of the image. Call after :meth:`SetImage`.\n\n        Each SetRectangle clears the recogntion results so multiple rectangles\n        can be recognized with the same image.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_57SetRectangle(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_left;
  int __pyx_v_top;
  int __pyx_v_width;
  int __pyx_v_height;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetRectangle (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_left,&__pyx_n_s_top,&__pyx_n_s_width,&__pyx_n_s_height,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_top)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetRectangle", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_width)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetRectangle", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_height)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SetRectangle", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SetRectangle") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_left = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_left == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_top = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_top == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_width = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_width == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_height = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_height == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetRectangle", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.SetRectangle", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_56SetRectangle(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_left, __pyx_v_top, __pyx_v_width, __pyx_v_height);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_56SetRectangle(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_left, int __pyx_v_top, int __pyx_v_width, int __pyx_v_height) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SetRectangle", 0);

  /* "tesserocr.pyx":1488
 *         can be recognized with the same image.
 *         """
 *         self._baseapi.SetRectangle(left, top, width, height)             # <<<<<<<<<<<<<<
 * 
 *     def GetThresholdedImage(self):
 */
  __pyx_v_self->_baseapi.SetRectangle(__pyx_v_left, __pyx_v_top, __pyx_v_width, __pyx_v_height);

  /* "tesserocr.pyx":1482
 *         self._baseapi.SetSourceResolution(ppi)
 * 
 *     def SetRectangle(self, int left, int top, int width, int height):             # <<<<<<<<<<<<<<
 *         """Restrict recognition to a sub-rectangle of the image. Call after :meth:`SetImage`.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1490
 *         self._baseapi.SetRectangle(left, top, width, height)
 * 
 *     def GetThresholdedImage(self):             # <<<<<<<<<<<<<<
 *         """Return a copy of the internal thresholded image from Tesseract.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_59GetThresholdedImage(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_58GetThresholdedImage[] = "Return a copy of the internal thresholded image from Tesseract.\n\n        May be called any time after SetImage.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_59GetThresholdedImage(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetThresholdedImage (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_58GetThresholdedImage(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_58GetThresholdedImage(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  struct Pix *__pyx_v_pix;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  char const *__pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetThresholdedImage", 0);

  /* "tesserocr.pyx":1495
 *         May be called any time after SetImage.
 *         """
 *         cdef Pix *pix = self._baseapi.GetThresholdedImage()             # <<<<<<<<<<<<<<
 * 
 *         if pix == NULL:
 */
  __pyx_v_pix = __pyx_v_self->_baseapi.GetThresholdedImage();

  /* "tesserocr.pyx":1497
 *         cdef Pix *pix = self._baseapi.GetThresholdedImage()
 * 
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             return None
 * 
 */
  __pyx_t_1 = ((__pyx_v_pix == NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1498
 * 
 *         if pix == NULL:
 *             return None             # <<<<<<<<<<<<<<
 * 
 *         try:
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":1497
 *         cdef Pix *pix = self._baseapi.GetThresholdedImage()
 * 
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             return None
 * 
 */
  }

  /* "tesserocr.pyx":1500
 *             return None
 * 
 *         try:             # <<<<<<<<<<<<<<
 *             return _pix_to_image(pix)
 *         finally:
 */
  /*try:*/ {

    /* "tesserocr.pyx":1501
 * 
 *         try:
 *             return _pix_to_image(pix)             # <<<<<<<<<<<<<<
 *         finally:
 *             pixDestroy(&pix)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __pyx_f_9tesserocr__pix_to_image(__pyx_v_pix); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1501; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L4_return;
  }

  /* "tesserocr.pyx":1503
 *             return _pix_to_image(pix)
 *         finally:
 *             pixDestroy(&pix)             # <<<<<<<<<<<<<<
 * 
 *     def GetRegions(self):
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L5_error:;
      __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8) < 0)) __Pyx_ErrFetch(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __pyx_t_3 = __pyx_lineno; __pyx_t_4 = __pyx_clineno; __pyx_t_5 = __pyx_filename;
      {
        pixDestroy((&__pyx_v_pix));
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
      }
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ErrRestore(__pyx_t_6, __pyx_t_7, __pyx_t_8);
      __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0;
      __pyx_lineno = __pyx_t_3; __pyx_clineno = __pyx_t_4; __pyx_filename = __pyx_t_5;
      goto __pyx_L1_error;
    }
    __pyx_L4_return: {
      __pyx_t_11 = __pyx_r;
      __pyx_r = 0;
      pixDestroy((&__pyx_v_pix));
      __pyx_r = __pyx_t_11;
      __pyx_t_11 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":1490
 *         self._baseapi.SetRectangle(left, top, width, height)
 * 
 *     def GetThresholdedImage(self):             # <<<<<<<<<<<<<<
 *         """Return a copy of the internal thresholded image from Tesseract.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetThresholdedImage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1505
 *             pixDestroy(&pix)
 * 
 *     def GetRegions(self):             # <<<<<<<<<<<<<<
 *         """Get the result of page layout analysis as a list of
 *         image, box bounds {x, y, width, height} tuples in reading order.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_61GetRegions(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_60GetRegions[] = "Get the result of page layout analysis as a list of\n        image, box bounds {x, y, width, height} tuples in reading order.\n\n        Can be called before or after :meth:`Recognize`.\n\n        Returns:\n            list: List of tuples containing the following values respectively::\n\n                image (:class:`PIL.Image`): Image object.\n                bounding box (dict): dict with x, y, w, h keys.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_61GetRegions(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetRegions (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_60GetRegions(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_60GetRegions(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  struct Pixa *__pyx_v_pixa;
  struct Boxa *__pyx_v_boxa;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  char const *__pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetRegions", 0);

  /* "tesserocr.pyx":1520
 *             Pixa *pixa
 *             Boxa *boxa
 *         boxa = self._baseapi.GetRegions(&pixa)             # <<<<<<<<<<<<<<
 *         try:
 *             return pixa_to_list(pixa)
 */
  __pyx_v_boxa = __pyx_v_self->_baseapi.GetRegions((&__pyx_v_pixa));

  /* "tesserocr.pyx":1521
 *             Boxa *boxa
 *         boxa = self._baseapi.GetRegions(&pixa)
 *         try:             # <<<<<<<<<<<<<<
 *             return pixa_to_list(pixa)
 *         finally:
 */
  /*try:*/ {

    /* "tesserocr.pyx":1522
 *         boxa = self._baseapi.GetRegions(&pixa)
 *         try:
 *             return pixa_to_list(pixa)             # <<<<<<<<<<<<<<
 *         finally:
 *             boxaDestroy(&boxa)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __pyx_f_9tesserocr_pixa_to_list(__pyx_v_pixa); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1522; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L3_return;
  }

  /* "tesserocr.pyx":1524
 *             return pixa_to_list(pixa)
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L4_error:;
      __pyx_t_5 = 0; __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0)) __Pyx_ErrFetch(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_5);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __pyx_t_2 = __pyx_lineno; __pyx_t_3 = __pyx_clineno; __pyx_t_4 = __pyx_filename;
      {
        boxaDestroy((&__pyx_v_boxa));

        /* "tesserocr.pyx":1525
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetTextlines(self, const bool raw_image=False, const int raw_padding=0,
 */
        pixaDestroy((&__pyx_v_pixa));
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      }
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_ErrRestore(__pyx_t_5, __pyx_t_6, __pyx_t_7);
      __pyx_t_5 = 0; __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0;
      __pyx_lineno = __pyx_t_2; __pyx_clineno = __pyx_t_3; __pyx_filename = __pyx_t_4;
      goto __pyx_L1_error;
    }
    __pyx_L3_return: {
      __pyx_t_10 = __pyx_r;
      __pyx_r = 0;

      /* "tesserocr.pyx":1524
 *             return pixa_to_list(pixa)
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
      boxaDestroy((&__pyx_v_boxa));

      /* "tesserocr.pyx":1525
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetTextlines(self, const bool raw_image=False, const int raw_padding=0,
 */
      pixaDestroy((&__pyx_v_pixa));
      __pyx_r = __pyx_t_10;
      __pyx_t_10 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":1505
 *             pixDestroy(&pix)
 * 
 *     def GetRegions(self):             # <<<<<<<<<<<<<<
 *         """Get the result of page layout analysis as a list of
 *         image, box bounds {x, y, width, height} tuples in reading order.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetRegions", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1527
 *             pixaDestroy(&pixa)
 * 
 *     def GetTextlines(self, const bool raw_image=False, const int raw_padding=0,             # <<<<<<<<<<<<<<
 *                      const bool blockids=True, const bool paraids=False):
 *         """Get the textlines as a list of image, box bounds
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_63GetTextlines(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_62GetTextlines[] = "Get the textlines as a list of image, box bounds\n        {x, y, width, height} tuples in reading order.\n\n        Can be called before or after :meth:`Recognize`.\n\n        Args:\n            raw_image (bool): If ``True``, then extract from the original image\n                instead of the thresholded image and pad by `raw_padding` pixels.\n            raw_padding (int): Padding pixels.\n\n        Kwargs:\n            blockids (bool): If ``True`` (default), the block-id of each line is also\n                included in the returned tuples (`None` otherwise).\n            paraids (bool): If ``True``, the paragraph-id of each line within its block is\n                also included in the returned tuples (`None` otherwise). Default is ``False``.\n\n        Returns:\n            list: List of tuples containing the following values respectively::\n\n                image (:class:`PIL.Image`): Image object.\n                bounding box (dict): dict with x, y, w, h keys.\n                block id (int): textline block id (if blockids is ``True``). ``None`` otherwise.\n                paragraph id (int): textline paragraph id within its block (if paraids is True).\n                    ``None`` otherwise.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_63GetTextlines(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  bool __pyx_v_raw_image;
  int __pyx_v_raw_padding;
  bool __pyx_v_blockids;
  bool __pyx_v_paraids;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetTextlines (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_raw_image,&__pyx_n_s_raw_padding,&__pyx_n_s_blockids,&__pyx_n_s_paraids,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_raw_image);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_raw_padding);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_blockids);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_paraids);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "GetTextlines") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1527; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_raw_image = __Pyx_PyObject_IsTrue(values[0]); if (unlikely((__pyx_v_raw_image == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1527; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_raw_image = ((bool)0);
    }
    if (values[1]) {
      __pyx_v_raw_padding = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_raw_padding == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1527; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_raw_padding = ((int)0);
    }
    if (values[2]) {
      __pyx_v_blockids = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_blockids == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1528; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "tesserocr.pyx":1528
 * 
 *     def GetTextlines(self, const bool raw_image=False, const int raw_padding=0,
 *                      const bool blockids=True, const bool paraids=False):             # <<<<<<<<<<<<<<
 *         """Get the textlines as a list of image, box bounds
 *         {x, y, width, height} tuples in reading order.
 */
      __pyx_v_blockids = ((bool)1);
    }
    if (values[3]) {
      __pyx_v_paraids = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_paraids == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1528; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_paraids = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("GetTextlines", 0, 0, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1527; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetTextlines", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_62GetTextlines(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_raw_image, __pyx_v_raw_padding, __pyx_v_blockids, __pyx_v_paraids);

  /* "tesserocr.pyx":1527
 *             pixaDestroy(&pixa)
 * 
 *     def GetTextlines(self, const bool raw_image=False, const int raw_padding=0,             # <<<<<<<<<<<<<<
 *                      const bool blockids=True, const bool paraids=False):
 *         """Get the textlines as a list of image, box bounds
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_62GetTextlines(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, bool __pyx_v_raw_image, int __pyx_v_raw_padding, bool __pyx_v_blockids, bool __pyx_v_paraids) {
  struct Pixa *__pyx_v_pixa;
  struct Boxa *__pyx_v_boxa;
  int *__pyx_v__blockids;
  int *__pyx_v__paraids;
  PyObject *__pyx_v_pixa_list = NULL;
  PyObject *__pyx_v_blockids_ = NULL;
  PyObject *__pyx_v_paraids_ = NULL;
  int __pyx_v_bid;
  int __pyx_v_pid;
  PyObject *__pyx_v_n = NULL;
  PyObject *__pyx_v_p = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int *__pyx_t_3;
  int *__pyx_t_4;
  int *__pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  PyObject *(*__pyx_t_9)(PyObject *);
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  int __pyx_t_13;
  int __pyx_t_14;
  char const *__pyx_t_15;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetTextlines", 0);

  /* "tesserocr.pyx":1559
 *             int *_blockids
 *             int *_paraids
 *         if not blockids:             # <<<<<<<<<<<<<<
 *             _blockids = NULL
 *         if not paraids:
 */
  __pyx_t_1 = ((!(__pyx_v_blockids != 0)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1560
 *             int *_paraids
 *         if not blockids:
 *             _blockids = NULL             # <<<<<<<<<<<<<<
 *         if not paraids:
 *             _paraids = NULL
 */
    __pyx_v__blockids = NULL;

    /* "tesserocr.pyx":1559
 *             int *_blockids
 *             int *_paraids
 *         if not blockids:             # <<<<<<<<<<<<<<
 *             _blockids = NULL
 *         if not paraids:
 */
  }

  /* "tesserocr.pyx":1561
 *         if not blockids:
 *             _blockids = NULL
 *         if not paraids:             # <<<<<<<<<<<<<<
 *             _paraids = NULL
 *         boxa = self._baseapi.GetTextlines(raw_image, raw_padding, &pixa, &_blockids, &_paraids)
 */
  __pyx_t_1 = ((!(__pyx_v_paraids != 0)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1562
 *             _blockids = NULL
 *         if not paraids:
 *             _paraids = NULL             # <<<<<<<<<<<<<<
 *         boxa = self._baseapi.GetTextlines(raw_image, raw_padding, &pixa, &_blockids, &_paraids)
 *         try:
 */
    __pyx_v__paraids = NULL;

    /* "tesserocr.pyx":1561
 *         if not blockids:
 *             _blockids = NULL
 *         if not paraids:             # <<<<<<<<<<<<<<
 *             _paraids = NULL
 *         boxa = self._baseapi.GetTextlines(raw_image, raw_padding, &pixa, &_blockids, &_paraids)
 */
  }

  /* "tesserocr.pyx":1563
 *         if not paraids:
 *             _paraids = NULL
 *         boxa = self._baseapi.GetTextlines(raw_image, raw_padding, &pixa, &_blockids, &_paraids)             # <<<<<<<<<<<<<<
 *         try:
 *             pixa_list = pixa_to_list(pixa)
 */
  __pyx_v_boxa = __pyx_v_self->_baseapi.GetTextlines(__pyx_v_raw_image, __pyx_v_raw_padding, (&__pyx_v_pixa), (&__pyx_v__blockids), (&__pyx_v__paraids));

  /* "tesserocr.pyx":1564
 *             _paraids = NULL
 *         boxa = self._baseapi.GetTextlines(raw_image, raw_padding, &pixa, &_blockids, &_paraids)
 *         try:             # <<<<<<<<<<<<<<
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:
 */
  /*try:*/ {

    /* "tesserocr.pyx":1565
 *         boxa = self._baseapi.GetTextlines(raw_image, raw_padding, &pixa, &_blockids, &_paraids)
 *         try:
 *             pixa_list = pixa_to_list(pixa)             # <<<<<<<<<<<<<<
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 */
    __pyx_t_2 = __pyx_f_9tesserocr_pixa_to_list(__pyx_v_pixa); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1565; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_v_pixa_list = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "tesserocr.pyx":1566
 *         try:
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:             # <<<<<<<<<<<<<<
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)
 */
    __pyx_t_1 = (__pyx_v_blockids != 0);
    if (__pyx_t_1) {

      /* "tesserocr.pyx":1567
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]             # <<<<<<<<<<<<<<
 *                 free(_blockids)
 *             else:
 */
      __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1567; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = (__pyx_v__blockids + __pyx_v_pixa->n);
      for (__pyx_t_5 = __pyx_v__blockids; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
        __pyx_t_3 = __pyx_t_5;
        __pyx_v_bid = (__pyx_t_3[0]);
        __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_bid); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1567; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
        __Pyx_GOTREF(__pyx_t_6);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1567; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
      __pyx_v_blockids_ = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;

      /* "tesserocr.pyx":1568
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)             # <<<<<<<<<<<<<<
 *             else:
 *                 blockids_ = [None] * pixa.n
 */
      free(__pyx_v__blockids);

      /* "tesserocr.pyx":1566
 *         try:
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:             # <<<<<<<<<<<<<<
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)
 */
      goto __pyx_L8;
    }

    /* "tesserocr.pyx":1570
 *                 free(_blockids)
 *             else:
 *                 blockids_ = [None] * pixa.n             # <<<<<<<<<<<<<<
 * 
 *             if paraids:
 */
    /*else*/ {
      __pyx_t_2 = PyList_New(1 * ((__pyx_v_pixa->n<0) ? 0:__pyx_v_pixa->n)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1570; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_2);
      { Py_ssize_t __pyx_temp;
        for (__pyx_temp=0; __pyx_temp < __pyx_v_pixa->n; __pyx_temp++) {
          __Pyx_INCREF(Py_None);
          __Pyx_GIVEREF(Py_None);
          PyList_SET_ITEM(__pyx_t_2, __pyx_temp, Py_None);
        }
      }
      __pyx_v_blockids_ = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;
    }
    __pyx_L8:;

    /* "tesserocr.pyx":1572
 *                 blockids_ = [None] * pixa.n
 * 
 *             if paraids:             # <<<<<<<<<<<<<<
 *                 paraids_ = [pid for pid in _paraids[:pixa.n]]
 *                 free(_paraids)
 */
    __pyx_t_1 = (__pyx_v_paraids != 0);
    if (__pyx_t_1) {

      /* "tesserocr.pyx":1573
 * 
 *             if paraids:
 *                 paraids_ = [pid for pid in _paraids[:pixa.n]]             # <<<<<<<<<<<<<<
 *                 free(_paraids)
 *             else:
 */
      __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1573; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = (__pyx_v__paraids + __pyx_v_pixa->n);
      for (__pyx_t_5 = __pyx_v__paraids; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
        __pyx_t_3 = __pyx_t_5;
        __pyx_v_pid = (__pyx_t_3[0]);
        __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_pid); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1573; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
        __Pyx_GOTREF(__pyx_t_6);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1573; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
      __pyx_v_paraids_ = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;

      /* "tesserocr.pyx":1574
 *             if paraids:
 *                 paraids_ = [pid for pid in _paraids[:pixa.n]]
 *                 free(_paraids)             # <<<<<<<<<<<<<<
 *             else:
 *                 paraids_ = [None] * pixa.n
 */
      free(__pyx_v__paraids);

      /* "tesserocr.pyx":1572
 *                 blockids_ = [None] * pixa.n
 * 
 *             if paraids:             # <<<<<<<<<<<<<<
 *                 paraids_ = [pid for pid in _paraids[:pixa.n]]
 *                 free(_paraids)
 */
      goto __pyx_L11;
    }

    /* "tesserocr.pyx":1576
 *                 free(_paraids)
 *             else:
 *                 paraids_ = [None] * pixa.n             # <<<<<<<<<<<<<<
 * 
 *             return [p + (blockids_[n], paraids_[n]) for n, p in enumerate(pixa_list)]
 */
    /*else*/ {
      __pyx_t_2 = PyList_New(1 * ((__pyx_v_pixa->n<0) ? 0:__pyx_v_pixa->n)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_2);
      { Py_ssize_t __pyx_temp;
        for (__pyx_temp=0; __pyx_temp < __pyx_v_pixa->n; __pyx_temp++) {
          __Pyx_INCREF(Py_None);
          __Pyx_GIVEREF(Py_None);
          PyList_SET_ITEM(__pyx_t_2, __pyx_temp, Py_None);
        }
      }
      __pyx_v_paraids_ = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;
    }
    __pyx_L11:;

    /* "tesserocr.pyx":1578
 *                 paraids_ = [None] * pixa.n
 * 
 *             return [p + (blockids_[n], paraids_[n]) for n, p in enumerate(pixa_list)]             # <<<<<<<<<<<<<<
 *         finally:
 *             boxaDestroy(&boxa)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_int_0);
    __pyx_t_6 = __pyx_int_0;
    if (likely(PyList_CheckExact(__pyx_v_pixa_list)) || PyTuple_CheckExact(__pyx_v_pixa_list)) {
      __pyx_t_7 = __pyx_v_pixa_list; __Pyx_INCREF(__pyx_t_7); __pyx_t_8 = 0;
      __pyx_t_9 = NULL;
    } else {
      __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_pixa_list); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_9 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
    }
    for (;;) {
      if (likely(!__pyx_t_9)) {
        if (likely(PyList_CheckExact(__pyx_t_7))) {
          if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_10 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_10); __pyx_t_8++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          #else
          __pyx_t_10 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          __Pyx_GOTREF(__pyx_t_10);
          #endif
        } else {
          if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_10 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_10); __pyx_t_8++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          #else
          __pyx_t_10 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          __Pyx_GOTREF(__pyx_t_10);
          #endif
        }
      } else {
        __pyx_t_10 = __pyx_t_9(__pyx_t_7);
        if (unlikely(!__pyx_t_10)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_10);
      }
      __Pyx_XDECREF_SET(__pyx_v_p, __pyx_t_10);
      __pyx_t_10 = 0;
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_XDECREF_SET(__pyx_v_n, __pyx_t_6);
      __pyx_t_10 = __Pyx_PyInt_AddObjC(__pyx_t_6, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_10);
      __Pyx_DECREF(__pyx_t_6);
      __pyx_t_6 = __pyx_t_10;
      __pyx_t_10 = 0;
      __pyx_t_10 = PyObject_GetItem(__pyx_v_blockids_, __pyx_v_n); if (unlikely(__pyx_t_10 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;};
      __Pyx_GOTREF(__pyx_t_10);
      __pyx_t_11 = PyObject_GetItem(__pyx_v_paraids_, __pyx_v_n); if (unlikely(__pyx_t_11 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;};
      __Pyx_GOTREF(__pyx_t_11);
      __pyx_t_12 = PyTuple_New(2); if (unlikely(!__pyx_t_12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_12);
      __Pyx_GIVEREF(__pyx_t_10);
      PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_10);
      __Pyx_GIVEREF(__pyx_t_11);
      PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_t_11);
      __pyx_t_10 = 0;
      __pyx_t_11 = 0;
      __pyx_t_11 = PyNumber_Add(__pyx_v_p, __pyx_t_12); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_11);
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_11))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1578; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L5_return;
  }

  /* "tesserocr.pyx":1580
 *             return [p + (blockids_[n], paraids_[n]) for n, p in enumerate(pixa_list)]
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L6_error:;
      __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18) < 0)) __Pyx_ErrFetch(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18);
      __Pyx_XGOTREF(__pyx_t_16);
      __Pyx_XGOTREF(__pyx_t_17);
      __Pyx_XGOTREF(__pyx_t_18);
      __Pyx_XGOTREF(__pyx_t_19);
      __Pyx_XGOTREF(__pyx_t_20);
      __Pyx_XGOTREF(__pyx_t_21);
      __pyx_t_13 = __pyx_lineno; __pyx_t_14 = __pyx_clineno; __pyx_t_15 = __pyx_filename;
      {
        boxaDestroy((&__pyx_v_boxa));

        /* "tesserocr.pyx":1581
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetStrips(self, blockids=True):
 */
        pixaDestroy((&__pyx_v_pixa));
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_19);
        __Pyx_XGIVEREF(__pyx_t_20);
        __Pyx_XGIVEREF(__pyx_t_21);
        __Pyx_ExceptionReset(__pyx_t_19, __pyx_t_20, __pyx_t_21);
      }
      __Pyx_XGIVEREF(__pyx_t_16);
      __Pyx_XGIVEREF(__pyx_t_17);
      __Pyx_XGIVEREF(__pyx_t_18);
      __Pyx_ErrRestore(__pyx_t_16, __pyx_t_17, __pyx_t_18);
      __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
      __pyx_lineno = __pyx_t_13; __pyx_clineno = __pyx_t_14; __pyx_filename = __pyx_t_15;
      goto __pyx_L1_error;
    }
    __pyx_L5_return: {
      __pyx_t_21 = __pyx_r;
      __pyx_r = 0;

      /* "tesserocr.pyx":1580
 *             return [p + (blockids_[n], paraids_[n]) for n, p in enumerate(pixa_list)]
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
      boxaDestroy((&__pyx_v_boxa));

      /* "tesserocr.pyx":1581
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetStrips(self, blockids=True):
 */
      pixaDestroy((&__pyx_v_pixa));
      __pyx_r = __pyx_t_21;
      __pyx_t_21 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":1527
 *             pixaDestroy(&pixa)
 * 
 *     def GetTextlines(self, const bool raw_image=False, const int raw_padding=0,             # <<<<<<<<<<<<<<
 *                      const bool blockids=True, const bool paraids=False):
 *         """Get the textlines as a list of image, box bounds
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetTextlines", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_pixa_list);
  __Pyx_XDECREF(__pyx_v_blockids_);
  __Pyx_XDECREF(__pyx_v_paraids_);
  __Pyx_XDECREF(__pyx_v_n);
  __Pyx_XDECREF(__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1583
 *             pixaDestroy(&pixa)
 * 
 *     def GetStrips(self, blockids=True):             # <<<<<<<<<<<<<<
 *         """Get the textlines and strips of image regions as a list
 *         of image, box bounds {x, y, width, height} tuples in reading order.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_65GetStrips(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_64GetStrips[] = "Get the textlines and strips of image regions as a list\n        of image, box bounds {x, y, width, height} tuples in reading order.\n\n        Enables downstream handling of non-rectangular regions.\n\n        Can be called before or after :meth:`Recognize`.\n\n        Kwargs:\n            blockids (bool): If ``True`` (default), the block-id of each line is also\n                included in the returned tuples.\n        Returns:\n            list: List of tuples containing the following values respectively::\n                image (:class:`PIL.Image`): Image object.\n                bounding box (dict): dict with x, y, w, h keys.\n                block id (int): textline block id (if blockids is ``True``). ``None`` otherwise.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_65GetStrips(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_blockids = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetStrips (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_blockids,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_blockids);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "GetStrips") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1583; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_blockids = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("GetStrips", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1583; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetStrips", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_64GetStrips(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_blockids);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_64GetStrips(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, PyObject *__pyx_v_blockids) {
  struct Pixa *__pyx_v_pixa;
  struct Boxa *__pyx_v_boxa;
  int *__pyx_v__blockids;
  PyObject *__pyx_v_pixa_list = NULL;
  PyObject *__pyx_v_blockids_ = NULL;
  int __pyx_v_bid;
  PyObject *__pyx_v_n = NULL;
  PyObject *__pyx_v_p = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int *__pyx_t_4;
  int *__pyx_t_5;
  int *__pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  Py_ssize_t __pyx_t_9;
  PyObject *(*__pyx_t_10)(PyObject *);
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  int __pyx_t_13;
  int __pyx_t_14;
  char const *__pyx_t_15;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetStrips", 0);

  /* "tesserocr.pyx":1604
 *             Boxa *boxa
 *             int *_blockids
 *         if not blockids:             # <<<<<<<<<<<<<<
 *             _blockids = NULL
 *         boxa = self._baseapi.GetStrips(&pixa, &_blockids)
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_blockids); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = ((!__pyx_t_1) != 0);
  if (__pyx_t_2) {

    /* "tesserocr.pyx":1605
 *             int *_blockids
 *         if not blockids:
 *             _blockids = NULL             # <<<<<<<<<<<<<<
 *         boxa = self._baseapi.GetStrips(&pixa, &_blockids)
 *         try:
 */
    __pyx_v__blockids = NULL;

    /* "tesserocr.pyx":1604
 *             Boxa *boxa
 *             int *_blockids
 *         if not blockids:             # <<<<<<<<<<<<<<
 *             _blockids = NULL
 *         boxa = self._baseapi.GetStrips(&pixa, &_blockids)
 */
  }

  /* "tesserocr.pyx":1606
 *         if not blockids:
 *             _blockids = NULL
 *         boxa = self._baseapi.GetStrips(&pixa, &_blockids)             # <<<<<<<<<<<<<<
 *         try:
 *             pixa_list = pixa_to_list(pixa)
 */
  __pyx_v_boxa = __pyx_v_self->_baseapi.GetStrips((&__pyx_v_pixa), (&__pyx_v__blockids));

  /* "tesserocr.pyx":1607
 *             _blockids = NULL
 *         boxa = self._baseapi.GetStrips(&pixa, &_blockids)
 *         try:             # <<<<<<<<<<<<<<
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:
 */
  /*try:*/ {

    /* "tesserocr.pyx":1608
 *         boxa = self._baseapi.GetStrips(&pixa, &_blockids)
 *         try:
 *             pixa_list = pixa_to_list(pixa)             # <<<<<<<<<<<<<<
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 */
    __pyx_t_3 = __pyx_f_9tesserocr_pixa_to_list(__pyx_v_pixa); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1608; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_pixa_list = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "tesserocr.pyx":1609
 *         try:
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:             # <<<<<<<<<<<<<<
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)
 */
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_blockids); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1609; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    if (__pyx_t_2) {

      /* "tesserocr.pyx":1610
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]             # <<<<<<<<<<<<<<
 *                 free(_blockids)
 *             else:
 */
      __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1610; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = (__pyx_v__blockids + __pyx_v_pixa->n);
      for (__pyx_t_6 = __pyx_v__blockids; __pyx_t_6 < __pyx_t_5; __pyx_t_6++) {
        __pyx_t_4 = __pyx_t_6;
        __pyx_v_bid = (__pyx_t_4[0]);
        __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_bid); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1610; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_7);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_7))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1610; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      }
      __pyx_v_blockids_ = ((PyObject*)__pyx_t_3);
      __pyx_t_3 = 0;

      /* "tesserocr.pyx":1611
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)             # <<<<<<<<<<<<<<
 *             else:
 *                 blockids_ = [None] * pixa.n
 */
      free(__pyx_v__blockids);

      /* "tesserocr.pyx":1609
 *         try:
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:             # <<<<<<<<<<<<<<
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)
 */
      goto __pyx_L7;
    }

    /* "tesserocr.pyx":1613
 *                 free(_blockids)
 *             else:
 *                 blockids_ = [None] * pixa.n             # <<<<<<<<<<<<<<
 * 
 *             return [p + (blockids_[n], ) for n, p in enumerate(pixa_list)]
 */
    /*else*/ {
      __pyx_t_3 = PyList_New(1 * ((__pyx_v_pixa->n<0) ? 0:__pyx_v_pixa->n)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1613; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_3);
      { Py_ssize_t __pyx_temp;
        for (__pyx_temp=0; __pyx_temp < __pyx_v_pixa->n; __pyx_temp++) {
          __Pyx_INCREF(Py_None);
          __Pyx_GIVEREF(Py_None);
          PyList_SET_ITEM(__pyx_t_3, __pyx_temp, Py_None);
        }
      }
      __pyx_v_blockids_ = ((PyObject*)__pyx_t_3);
      __pyx_t_3 = 0;
    }
    __pyx_L7:;

    /* "tesserocr.pyx":1615
 *                 blockids_ = [None] * pixa.n
 * 
 *             return [p + (blockids_[n], ) for n, p in enumerate(pixa_list)]             # <<<<<<<<<<<<<<
 *         finally:
 *             boxaDestroy(&boxa)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_int_0);
    __pyx_t_7 = __pyx_int_0;
    if (likely(PyList_CheckExact(__pyx_v_pixa_list)) || PyTuple_CheckExact(__pyx_v_pixa_list)) {
      __pyx_t_8 = __pyx_v_pixa_list; __Pyx_INCREF(__pyx_t_8); __pyx_t_9 = 0;
      __pyx_t_10 = NULL;
    } else {
      __pyx_t_9 = -1; __pyx_t_8 = PyObject_GetIter(__pyx_v_pixa_list); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_10 = Py_TYPE(__pyx_t_8)->tp_iternext; if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
    }
    for (;;) {
      if (likely(!__pyx_t_10)) {
        if (likely(PyList_CheckExact(__pyx_t_8))) {
          if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_8)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_11 = PyList_GET_ITEM(__pyx_t_8, __pyx_t_9); __Pyx_INCREF(__pyx_t_11); __pyx_t_9++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          #else
          __pyx_t_11 = PySequence_ITEM(__pyx_t_8, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_GOTREF(__pyx_t_11);
          #endif
        } else {
          if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_8)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_11 = PyTuple_GET_ITEM(__pyx_t_8, __pyx_t_9); __Pyx_INCREF(__pyx_t_11); __pyx_t_9++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          #else
          __pyx_t_11 = PySequence_ITEM(__pyx_t_8, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_GOTREF(__pyx_t_11);
          #endif
        }
      } else {
        __pyx_t_11 = __pyx_t_10(__pyx_t_8);
        if (unlikely(!__pyx_t_11)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_11);
      }
      __Pyx_XDECREF_SET(__pyx_v_p, __pyx_t_11);
      __pyx_t_11 = 0;
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_XDECREF_SET(__pyx_v_n, __pyx_t_7);
      __pyx_t_11 = __Pyx_PyInt_AddObjC(__pyx_t_7, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_11);
      __Pyx_DECREF(__pyx_t_7);
      __pyx_t_7 = __pyx_t_11;
      __pyx_t_11 = 0;
      __pyx_t_11 = PyObject_GetItem(__pyx_v_blockids_, __pyx_v_n); if (unlikely(__pyx_t_11 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;};
      __Pyx_GOTREF(__pyx_t_11);
      __pyx_t_12 = PyTuple_New(1); if (unlikely(!__pyx_t_12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_12);
      __Pyx_GIVEREF(__pyx_t_11);
      PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_11);
      __pyx_t_11 = 0;
      __pyx_t_11 = PyNumber_Add(__pyx_v_p, __pyx_t_12); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_11);
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_11))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    }
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L4_return;
  }

  /* "tesserocr.pyx":1617
 *             return [p + (blockids_[n], ) for n, p in enumerate(pixa_list)]
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L5_error:;
      __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18) < 0)) __Pyx_ErrFetch(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18);
      __Pyx_XGOTREF(__pyx_t_16);
      __Pyx_XGOTREF(__pyx_t_17);
      __Pyx_XGOTREF(__pyx_t_18);
      __Pyx_XGOTREF(__pyx_t_19);
      __Pyx_XGOTREF(__pyx_t_20);
      __Pyx_XGOTREF(__pyx_t_21);
      __pyx_t_13 = __pyx_lineno; __pyx_t_14 = __pyx_clineno; __pyx_t_15 = __pyx_filename;
      {
        boxaDestroy((&__pyx_v_boxa));

        /* "tesserocr.pyx":1618
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetWords(self):
 */
        pixaDestroy((&__pyx_v_pixa));
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_19);
        __Pyx_XGIVEREF(__pyx_t_20);
        __Pyx_XGIVEREF(__pyx_t_21);
        __Pyx_ExceptionReset(__pyx_t_19, __pyx_t_20, __pyx_t_21);
      }
      __Pyx_XGIVEREF(__pyx_t_16);
      __Pyx_XGIVEREF(__pyx_t_17);
      __Pyx_XGIVEREF(__pyx_t_18);
      __Pyx_ErrRestore(__pyx_t_16, __pyx_t_17, __pyx_t_18);
      __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
      __pyx_lineno = __pyx_t_13; __pyx_clineno = __pyx_t_14; __pyx_filename = __pyx_t_15;
      goto __pyx_L1_error;
    }
    __pyx_L4_return: {
      __pyx_t_21 = __pyx_r;
      __pyx_r = 0;

      /* "tesserocr.pyx":1617
 *             return [p + (blockids_[n], ) for n, p in enumerate(pixa_list)]
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
      boxaDestroy((&__pyx_v_boxa));

      /* "tesserocr.pyx":1618
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetWords(self):
 */
      pixaDestroy((&__pyx_v_pixa));
      __pyx_r = __pyx_t_21;
      __pyx_t_21 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":1583
 *             pixaDestroy(&pixa)
 * 
 *     def GetStrips(self, blockids=True):             # <<<<<<<<<<<<<<
 *         """Get the textlines and strips of image regions as a list
 *         of image, box bounds {x, y, width, height} tuples in reading order.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetStrips", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_pixa_list);
  __Pyx_XDECREF(__pyx_v_blockids_);
  __Pyx_XDECREF(__pyx_v_n);
  __Pyx_XDECREF(__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1620
 *             pixaDestroy(&pixa)
 * 
 *     def GetWords(self):             # <<<<<<<<<<<<<<
 *         """Get the words as a list of image, box bounds
 *         {x, y, width, height} tuples in reading order.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_67GetWords(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_66GetWords[] = "Get the words as a list of image, box bounds\n        {x, y, width, height} tuples in reading order.\n\n        Can be called before or after :meth:`Recognize`.\n\n        Returns:\n            list: List of tuples containing the following values respectively::\n                image (:class:`PIL.Image`): Image object.\n                bounding box (dict): dict with x, y, w, h keys.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_67GetWords(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetWords (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_66GetWords(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_66GetWords(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  struct Boxa *__pyx_v_boxa;
  struct Pixa *__pyx_v_pixa;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  char const *__pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetWords", 0);

  /* "tesserocr.pyx":1634
 *             Boxa *boxa
 *             Pixa *pixa
 *         boxa = self._baseapi.GetWords(&pixa)             # <<<<<<<<<<<<<<
 *         try:
 *             return pixa_to_list(pixa)
 */
  __pyx_v_boxa = __pyx_v_self->_baseapi.GetWords((&__pyx_v_pixa));

  /* "tesserocr.pyx":1635
 *             Pixa *pixa
 *         boxa = self._baseapi.GetWords(&pixa)
 *         try:             # <<<<<<<<<<<<<<
 *             return pixa_to_list(pixa)
 *         finally:
 */
  /*try:*/ {

    /* "tesserocr.pyx":1636
 *         boxa = self._baseapi.GetWords(&pixa)
 *         try:
 *             return pixa_to_list(pixa)             # <<<<<<<<<<<<<<
 *         finally:
 *             boxaDestroy(&boxa)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __pyx_f_9tesserocr_pixa_to_list(__pyx_v_pixa); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1636; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L3_return;
  }

  /* "tesserocr.pyx":1638
 *             return pixa_to_list(pixa)
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L4_error:;
      __pyx_t_5 = 0; __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0)) __Pyx_ErrFetch(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_5);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __pyx_t_2 = __pyx_lineno; __pyx_t_3 = __pyx_clineno; __pyx_t_4 = __pyx_filename;
      {
        boxaDestroy((&__pyx_v_boxa));

        /* "tesserocr.pyx":1639
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetConnectedComponents(self):
 */
        pixaDestroy((&__pyx_v_pixa));
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      }
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_ErrRestore(__pyx_t_5, __pyx_t_6, __pyx_t_7);
      __pyx_t_5 = 0; __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0;
      __pyx_lineno = __pyx_t_2; __pyx_clineno = __pyx_t_3; __pyx_filename = __pyx_t_4;
      goto __pyx_L1_error;
    }
    __pyx_L3_return: {
      __pyx_t_10 = __pyx_r;
      __pyx_r = 0;

      /* "tesserocr.pyx":1638
 *             return pixa_to_list(pixa)
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
      boxaDestroy((&__pyx_v_boxa));

      /* "tesserocr.pyx":1639
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetConnectedComponents(self):
 */
      pixaDestroy((&__pyx_v_pixa));
      __pyx_r = __pyx_t_10;
      __pyx_t_10 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":1620
 *             pixaDestroy(&pixa)
 * 
 *     def GetWords(self):             # <<<<<<<<<<<<<<
 *         """Get the words as a list of image, box bounds
 *         {x, y, width, height} tuples in reading order.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetWords", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1641
 *             pixaDestroy(&pixa)
 * 
 *     def GetConnectedComponents(self):             # <<<<<<<<<<<<<<
 *         """Gets the individual connected (text) components (created
 *         after pages segmentation step, but before recognition)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_69GetConnectedComponents(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_68GetConnectedComponents[] = "Gets the individual connected (text) components (created\n        after pages segmentation step, but before recognition)\n        as a list of image, box bounds {x, y, width, height} tuples\n        in reading order.\n\n        Can be called before or after :meth:`Recognize`.\n\n        Returns:\n            list: List of tuples containing the following values respectively:\n\n                image (:class:`PIL.Image`): Image object.\n                bounding box (dict): dict with x, y, w, h keys.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_69GetConnectedComponents(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetConnectedComponents (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_68GetConnectedComponents(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_68GetConnectedComponents(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  struct Boxa *__pyx_v_boxa;
  struct Pixa *__pyx_v_pixa;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  char const *__pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetConnectedComponents", 0);

  /* "tesserocr.pyx":1658
 *             Boxa *boxa
 *             Pixa *pixa
 *         boxa = self._baseapi.GetConnectedComponents(&pixa)             # <<<<<<<<<<<<<<
 *         try:
 *             return pixa_to_list(pixa)
 */
  __pyx_v_boxa = __pyx_v_self->_baseapi.GetConnectedComponents((&__pyx_v_pixa));

  /* "tesserocr.pyx":1659
 *             Pixa *pixa
 *         boxa = self._baseapi.GetConnectedComponents(&pixa)
 *         try:             # <<<<<<<<<<<<<<
 *             return pixa_to_list(pixa)
 *         finally:
 */
  /*try:*/ {

    /* "tesserocr.pyx":1660
 *         boxa = self._baseapi.GetConnectedComponents(&pixa)
 *         try:
 *             return pixa_to_list(pixa)             # <<<<<<<<<<<<<<
 *         finally:
 *             boxaDestroy(&boxa)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __pyx_f_9tesserocr_pixa_to_list(__pyx_v_pixa); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1660; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L3_return;
  }

  /* "tesserocr.pyx":1662
 *             return pixa_to_list(pixa)
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L4_error:;
      __pyx_t_5 = 0; __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0)) __Pyx_ErrFetch(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_5);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __pyx_t_2 = __pyx_lineno; __pyx_t_3 = __pyx_clineno; __pyx_t_4 = __pyx_filename;
      {
        boxaDestroy((&__pyx_v_boxa));

        /* "tesserocr.pyx":1663
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetComponentImages(self, const PageIteratorLevel level,
 */
        pixaDestroy((&__pyx_v_pixa));
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      }
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_ErrRestore(__pyx_t_5, __pyx_t_6, __pyx_t_7);
      __pyx_t_5 = 0; __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0;
      __pyx_lineno = __pyx_t_2; __pyx_clineno = __pyx_t_3; __pyx_filename = __pyx_t_4;
      goto __pyx_L1_error;
    }
    __pyx_L3_return: {
      __pyx_t_10 = __pyx_r;
      __pyx_r = 0;

      /* "tesserocr.pyx":1662
 *             return pixa_to_list(pixa)
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
      boxaDestroy((&__pyx_v_boxa));

      /* "tesserocr.pyx":1663
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetComponentImages(self, const PageIteratorLevel level,
 */
      pixaDestroy((&__pyx_v_pixa));
      __pyx_r = __pyx_t_10;
      __pyx_t_10 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":1641
 *             pixaDestroy(&pixa)
 * 
 *     def GetConnectedComponents(self):             # <<<<<<<<<<<<<<
 *         """Gets the individual connected (text) components (created
 *         after pages segmentation step, but before recognition)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetConnectedComponents", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1665
 *             pixaDestroy(&pixa)
 * 
 *     def GetComponentImages(self, const PageIteratorLevel level,             # <<<<<<<<<<<<<<
 *                            const bool text_only, const bool raw_image=False,
 *                            const int raw_padding=0,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_71GetComponentImages(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_70GetComponentImages[] = "Get the given level kind of components (block, textline, word etc.) as a\n        list of image, box bounds {x, y, width, height} tuples in reading order.\n\n        Can be called before or after :meth:`Recognize`.\n\n        Args:\n            level (int): Iterator level. See :class:`RIL`.\n            text_only (bool): If ``True``, then only text components are returned.\n\n        Kwargs:\n            raw_image (bool): If ``True``, then portions of the original image are extracted\n                instead of the thresholded image and padded with `raw_padding`. Defaults to\n                ``False``.\n            raw_padding (int): Image padding pixels. Defaults to 0.\n            blockids (bool): If ``True``, the block-id of each component is also included\n                in the returned tuples (`None` otherwise). Defaults to ``True``.\n            paraids (bool): If ``True``, the paragraph-id of each component with its block\n                is also included in the returned tuples.\n\n        Returns:\n            list: List of tuples containing the following values respectively::\n\n                image (:class:`PIL.Image`): Image object.\n                bounding box (dict): dict with x, y, w, h keys.\n                block id (int): textline block id (if blockids is ``True``). ``None`` otherwise.\n                paragraph id (int): textline paragraph id within its block (if paraids is True).\n                    ``None`` otherwise.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_71GetComponentImages(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum tesseract::PageIteratorLevel __pyx_v_level;
  bool __pyx_v_text_only;
  bool __pyx_v_raw_image;
  int __pyx_v_raw_padding;
  bool __pyx_v_blockids;
  bool __pyx_v_paraids;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetComponentImages (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_level,&__pyx_n_s_text_only,&__pyx_n_s_raw_image,&__pyx_n_s_raw_padding,&__pyx_n_s_blockids,&__pyx_n_s_paraids,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_level)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_text_only)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("GetComponentImages", 0, 2, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1665; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_raw_image);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_raw_padding);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_blockids);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_paraids);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "GetComponentImages") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1665; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_level = ((enum tesseract::PageIteratorLevel)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(values[0])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1665; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_text_only = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_text_only == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1666; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[2]) {
      __pyx_v_raw_image = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_raw_image == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1666; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "tesserocr.pyx":1666
 * 
 *     def GetComponentImages(self, const PageIteratorLevel level,
 *                            const bool text_only, const bool raw_image=False,             # <<<<<<<<<<<<<<
 *                            const int raw_padding=0,
 *                            const bool blockids=True, const bool paraids=False):
 */
      __pyx_v_raw_image = ((bool)0);
    }
    if (values[3]) {
      __pyx_v_raw_padding = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_raw_padding == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1667; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_raw_padding = ((int)0);
    }
    if (values[4]) {
      __pyx_v_blockids = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_blockids == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1668; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "tesserocr.pyx":1668
 *                            const bool text_only, const bool raw_image=False,
 *                            const int raw_padding=0,
 *                            const bool blockids=True, const bool paraids=False):             # <<<<<<<<<<<<<<
 *         """Get the given level kind of components (block, textline, word etc.) as a
 *         list of image, box bounds {x, y, width, height} tuples in reading order.
 */
      __pyx_v_blockids = ((bool)1);
    }
    if (values[5]) {
      __pyx_v_paraids = __Pyx_PyObject_IsTrue(values[5]); if (unlikely((__pyx_v_paraids == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1668; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_paraids = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("GetComponentImages", 0, 2, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1665; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetComponentImages", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_70GetComponentImages(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_level, __pyx_v_text_only, __pyx_v_raw_image, __pyx_v_raw_padding, __pyx_v_blockids, __pyx_v_paraids);

  /* "tesserocr.pyx":1665
 *             pixaDestroy(&pixa)
 * 
 *     def GetComponentImages(self, const PageIteratorLevel level,             # <<<<<<<<<<<<<<
 *                            const bool text_only, const bool raw_image=False,
 *                            const int raw_padding=0,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_70GetComponentImages(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, enum tesseract::PageIteratorLevel __pyx_v_level, bool __pyx_v_text_only, bool __pyx_v_raw_image, int __pyx_v_raw_padding, bool __pyx_v_blockids, bool __pyx_v_paraids) {
  struct Boxa *__pyx_v_boxa;
  struct Pixa *__pyx_v_pixa;
  int *__pyx_v__blockids;
  int *__pyx_v__paraids;
  PyObject *__pyx_v_pixa_list = NULL;
  PyObject *__pyx_v_blockids_ = NULL;
  PyObject *__pyx_v_paraids_ = NULL;
  int __pyx_v_bid;
  int __pyx_v_pid;
  PyObject *__pyx_v_n = NULL;
  PyObject *__pyx_v_p = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int *__pyx_t_3;
  int *__pyx_t_4;
  int *__pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  PyObject *(*__pyx_t_9)(PyObject *);
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  int __pyx_t_13;
  int __pyx_t_14;
  char const *__pyx_t_15;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetComponentImages", 0);

  /* "tesserocr.pyx":1702
 *             int *_blockids
 *             int *_paraids
 *         if not blockids:             # <<<<<<<<<<<<<<
 *             _blockids = NULL
 *         if not paraids:
 */
  __pyx_t_1 = ((!(__pyx_v_blockids != 0)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1703
 *             int *_paraids
 *         if not blockids:
 *             _blockids = NULL             # <<<<<<<<<<<<<<
 *         if not paraids:
 *             _paraids = NULL
 */
    __pyx_v__blockids = NULL;

    /* "tesserocr.pyx":1702
 *             int *_blockids
 *             int *_paraids
 *         if not blockids:             # <<<<<<<<<<<<<<
 *             _blockids = NULL
 *         if not paraids:
 */
  }

  /* "tesserocr.pyx":1704
 *         if not blockids:
 *             _blockids = NULL
 *         if not paraids:             # <<<<<<<<<<<<<<
 *             _paraids = NULL
 *         boxa = self._baseapi.GetComponentImages(level, text_only, raw_image, raw_padding,
 */
  __pyx_t_1 = ((!(__pyx_v_paraids != 0)) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1705
 *             _blockids = NULL
 *         if not paraids:
 *             _paraids = NULL             # <<<<<<<<<<<<<<
 *         boxa = self._baseapi.GetComponentImages(level, text_only, raw_image, raw_padding,
 *                                                 &pixa, &_blockids, &_paraids)
 */
    __pyx_v__paraids = NULL;

    /* "tesserocr.pyx":1704
 *         if not blockids:
 *             _blockids = NULL
 *         if not paraids:             # <<<<<<<<<<<<<<
 *             _paraids = NULL
 *         boxa = self._baseapi.GetComponentImages(level, text_only, raw_image, raw_padding,
 */
  }

  /* "tesserocr.pyx":1706
 *         if not paraids:
 *             _paraids = NULL
 *         boxa = self._baseapi.GetComponentImages(level, text_only, raw_image, raw_padding,             # <<<<<<<<<<<<<<
 *                                                 &pixa, &_blockids, &_paraids)
 *         try:
 */
  __pyx_v_boxa = __pyx_v_self->_baseapi.GetComponentImages(__pyx_v_level, __pyx_v_text_only, __pyx_v_raw_image, __pyx_v_raw_padding, (&__pyx_v_pixa), (&__pyx_v__blockids), (&__pyx_v__paraids));

  /* "tesserocr.pyx":1708
 *         boxa = self._baseapi.GetComponentImages(level, text_only, raw_image, raw_padding,
 *                                                 &pixa, &_blockids, &_paraids)
 *         try:             # <<<<<<<<<<<<<<
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:
 */
  /*try:*/ {

    /* "tesserocr.pyx":1709
 *                                                 &pixa, &_blockids, &_paraids)
 *         try:
 *             pixa_list = pixa_to_list(pixa)             # <<<<<<<<<<<<<<
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 */
    __pyx_t_2 = __pyx_f_9tesserocr_pixa_to_list(__pyx_v_pixa); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1709; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_v_pixa_list = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "tesserocr.pyx":1710
 *         try:
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:             # <<<<<<<<<<<<<<
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)
 */
    __pyx_t_1 = (__pyx_v_blockids != 0);
    if (__pyx_t_1) {

      /* "tesserocr.pyx":1711
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]             # <<<<<<<<<<<<<<
 *                 free(_blockids)
 *             else:
 */
      __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1711; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = (__pyx_v__blockids + __pyx_v_pixa->n);
      for (__pyx_t_5 = __pyx_v__blockids; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
        __pyx_t_3 = __pyx_t_5;
        __pyx_v_bid = (__pyx_t_3[0]);
        __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_bid); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1711; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
        __Pyx_GOTREF(__pyx_t_6);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1711; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
      __pyx_v_blockids_ = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;

      /* "tesserocr.pyx":1712
 *             if blockids:
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)             # <<<<<<<<<<<<<<
 *             else:
 *                 blockids_ = [None] * pixa.n
 */
      free(__pyx_v__blockids);

      /* "tesserocr.pyx":1710
 *         try:
 *             pixa_list = pixa_to_list(pixa)
 *             if blockids:             # <<<<<<<<<<<<<<
 *                 blockids_ = [bid for bid in _blockids[:pixa.n]]
 *                 free(_blockids)
 */
      goto __pyx_L8;
    }

    /* "tesserocr.pyx":1714
 *                 free(_blockids)
 *             else:
 *                 blockids_ = [None] * pixa.n             # <<<<<<<<<<<<<<
 * 
 *             if paraids:
 */
    /*else*/ {
      __pyx_t_2 = PyList_New(1 * ((__pyx_v_pixa->n<0) ? 0:__pyx_v_pixa->n)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1714; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_2);
      { Py_ssize_t __pyx_temp;
        for (__pyx_temp=0; __pyx_temp < __pyx_v_pixa->n; __pyx_temp++) {
          __Pyx_INCREF(Py_None);
          __Pyx_GIVEREF(Py_None);
          PyList_SET_ITEM(__pyx_t_2, __pyx_temp, Py_None);
        }
      }
      __pyx_v_blockids_ = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;
    }
    __pyx_L8:;

    /* "tesserocr.pyx":1716
 *                 blockids_ = [None] * pixa.n
 * 
 *             if paraids:             # <<<<<<<<<<<<<<
 *                 paraids_ = [pid for pid in _paraids[:pixa.n]]
 *                 free(_paraids)
 */
    __pyx_t_1 = (__pyx_v_paraids != 0);
    if (__pyx_t_1) {

      /* "tesserocr.pyx":1717
 * 
 *             if paraids:
 *                 paraids_ = [pid for pid in _paraids[:pixa.n]]             # <<<<<<<<<<<<<<
 *                 free(_paraids)
 *             else:
 */
      __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1717; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = (__pyx_v__paraids + __pyx_v_pixa->n);
      for (__pyx_t_5 = __pyx_v__paraids; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
        __pyx_t_3 = __pyx_t_5;
        __pyx_v_pid = (__pyx_t_3[0]);
        __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_pid); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1717; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
        __Pyx_GOTREF(__pyx_t_6);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1717; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
      __pyx_v_paraids_ = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;

      /* "tesserocr.pyx":1718
 *             if paraids:
 *                 paraids_ = [pid for pid in _paraids[:pixa.n]]
 *                 free(_paraids)             # <<<<<<<<<<<<<<
 *             else:
 *                 paraids_ = [None] * pixa.n
 */
      free(__pyx_v__paraids);

      /* "tesserocr.pyx":1716
 *                 blockids_ = [None] * pixa.n
 * 
 *             if paraids:             # <<<<<<<<<<<<<<
 *                 paraids_ = [pid for pid in _paraids[:pixa.n]]
 *                 free(_paraids)
 */
      goto __pyx_L11;
    }

    /* "tesserocr.pyx":1720
 *                 free(_paraids)
 *             else:
 *                 paraids_ = [None] * pixa.n             # <<<<<<<<<<<<<<
 * 
 *             return [p + (blockids_[n], paraids_[n]) for n, p in enumerate(pixa_list)]
 */
    /*else*/ {
      __pyx_t_2 = PyList_New(1 * ((__pyx_v_pixa->n<0) ? 0:__pyx_v_pixa->n)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1720; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_2);
      { Py_ssize_t __pyx_temp;
        for (__pyx_temp=0; __pyx_temp < __pyx_v_pixa->n; __pyx_temp++) {
          __Pyx_INCREF(Py_None);
          __Pyx_GIVEREF(Py_None);
          PyList_SET_ITEM(__pyx_t_2, __pyx_temp, Py_None);
        }
      }
      __pyx_v_paraids_ = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;
    }
    __pyx_L11:;

    /* "tesserocr.pyx":1722
 *                 paraids_ = [None] * pixa.n
 * 
 *             return [p + (blockids_[n], paraids_[n]) for n, p in enumerate(pixa_list)]             # <<<<<<<<<<<<<<
 *         finally:
 *             boxaDestroy(&boxa)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_int_0);
    __pyx_t_6 = __pyx_int_0;
    if (likely(PyList_CheckExact(__pyx_v_pixa_list)) || PyTuple_CheckExact(__pyx_v_pixa_list)) {
      __pyx_t_7 = __pyx_v_pixa_list; __Pyx_INCREF(__pyx_t_7); __pyx_t_8 = 0;
      __pyx_t_9 = NULL;
    } else {
      __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_pixa_list); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_9 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
    }
    for (;;) {
      if (likely(!__pyx_t_9)) {
        if (likely(PyList_CheckExact(__pyx_t_7))) {
          if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_10 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_10); __pyx_t_8++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          #else
          __pyx_t_10 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          __Pyx_GOTREF(__pyx_t_10);
          #endif
        } else {
          if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_10 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_10); __pyx_t_8++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          #else
          __pyx_t_10 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          __Pyx_GOTREF(__pyx_t_10);
          #endif
        }
      } else {
        __pyx_t_10 = __pyx_t_9(__pyx_t_7);
        if (unlikely(!__pyx_t_10)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_10);
      }
      __Pyx_XDECREF_SET(__pyx_v_p, __pyx_t_10);
      __pyx_t_10 = 0;
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_XDECREF_SET(__pyx_v_n, __pyx_t_6);
      __pyx_t_10 = __Pyx_PyInt_AddObjC(__pyx_t_6, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_10);
      __Pyx_DECREF(__pyx_t_6);
      __pyx_t_6 = __pyx_t_10;
      __pyx_t_10 = 0;
      __pyx_t_10 = PyObject_GetItem(__pyx_v_blockids_, __pyx_v_n); if (unlikely(__pyx_t_10 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;};
      __Pyx_GOTREF(__pyx_t_10);
      __pyx_t_11 = PyObject_GetItem(__pyx_v_paraids_, __pyx_v_n); if (unlikely(__pyx_t_11 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;};
      __Pyx_GOTREF(__pyx_t_11);
      __pyx_t_12 = PyTuple_New(2); if (unlikely(!__pyx_t_12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_12);
      __Pyx_GIVEREF(__pyx_t_10);
      PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_10);
      __Pyx_GIVEREF(__pyx_t_11);
      PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_t_11);
      __pyx_t_10 = 0;
      __pyx_t_11 = 0;
      __pyx_t_11 = PyNumber_Add(__pyx_v_p, __pyx_t_12); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_11);
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_11))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L5_return;
  }

  /* "tesserocr.pyx":1724
 *             return [p + (blockids_[n], paraids_[n]) for n, p in enumerate(pixa_list)]
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
  /*finally:*/ {
    /*exception exit:*/{
      __pyx_L6_error:;
      __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18) < 0)) __Pyx_ErrFetch(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18);
      __Pyx_XGOTREF(__pyx_t_16);
      __Pyx_XGOTREF(__pyx_t_17);
      __Pyx_XGOTREF(__pyx_t_18);
      __Pyx_XGOTREF(__pyx_t_19);
      __Pyx_XGOTREF(__pyx_t_20);
      __Pyx_XGOTREF(__pyx_t_21);
      __pyx_t_13 = __pyx_lineno; __pyx_t_14 = __pyx_clineno; __pyx_t_15 = __pyx_filename;
      {
        boxaDestroy((&__pyx_v_boxa));

        /* "tesserocr.pyx":1725
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetThresholdedImageScaleFactor(self):
 */
        pixaDestroy((&__pyx_v_pixa));
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_19);
        __Pyx_XGIVEREF(__pyx_t_20);
        __Pyx_XGIVEREF(__pyx_t_21);
        __Pyx_ExceptionReset(__pyx_t_19, __pyx_t_20, __pyx_t_21);
      }
      __Pyx_XGIVEREF(__pyx_t_16);
      __Pyx_XGIVEREF(__pyx_t_17);
      __Pyx_XGIVEREF(__pyx_t_18);
      __Pyx_ErrRestore(__pyx_t_16, __pyx_t_17, __pyx_t_18);
      __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
      __pyx_lineno = __pyx_t_13; __pyx_clineno = __pyx_t_14; __pyx_filename = __pyx_t_15;
      goto __pyx_L1_error;
    }
    __pyx_L5_return: {
      __pyx_t_21 = __pyx_r;
      __pyx_r = 0;

      /* "tesserocr.pyx":1724
 *             return [p + (blockids_[n], paraids_[n]) for n, p in enumerate(pixa_list)]
 *         finally:
 *             boxaDestroy(&boxa)             # <<<<<<<<<<<<<<
 *             pixaDestroy(&pixa)
 * 
 */
      boxaDestroy((&__pyx_v_boxa));

      /* "tesserocr.pyx":1725
 *         finally:
 *             boxaDestroy(&boxa)
 *             pixaDestroy(&pixa)             # <<<<<<<<<<<<<<
 * 
 *     def GetThresholdedImageScaleFactor(self):
 */
      pixaDestroy((&__pyx_v_pixa));
      __pyx_r = __pyx_t_21;
      __pyx_t_21 = 0;
      goto __pyx_L0;
    }
  }

  /* "tesserocr.pyx":1665
 *             pixaDestroy(&pixa)
 * 
 *     def GetComponentImages(self, const PageIteratorLevel level,             # <<<<<<<<<<<<<<
 *                            const bool text_only, const bool raw_image=False,
 *                            const int raw_padding=0,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetComponentImages", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_pixa_list);
  __Pyx_XDECREF(__pyx_v_blockids_);
  __Pyx_XDECREF(__pyx_v_paraids_);
  __Pyx_XDECREF(__pyx_v_n);
  __Pyx_XDECREF(__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1727
 *             pixaDestroy(&pixa)
 * 
 *     def GetThresholdedImageScaleFactor(self):             # <<<<<<<<<<<<<<
 *         """Return the scale factor of the thresholded image that would be returned by
 *         GetThresholdedImage().
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_73GetThresholdedImageScaleFactor(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_72GetThresholdedImageScaleFactor[] = "Return the scale factor of the thresholded image that would be returned by\n        GetThresholdedImage().\n\n        Returns:\n            int: 0 if no thresholder has been set.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_73GetThresholdedImageScaleFactor(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetThresholdedImageScaleFactor (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_72GetThresholdedImageScaleFactor(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_72GetThresholdedImageScaleFactor(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetThresholdedImageScaleFactor", 0);

  /* "tesserocr.pyx":1734
 *             int: 0 if no thresholder has been set.
 *         """
 *         return self._baseapi.GetThresholdedImageScaleFactor()             # <<<<<<<<<<<<<<
 * 
 *     def AnalyseLayout(self, bool merge_similar_words=False):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_baseapi.GetThresholdedImageScaleFactor()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1727
 *             pixaDestroy(&pixa)
 * 
 *     def GetThresholdedImageScaleFactor(self):             # <<<<<<<<<<<<<<
 *         """Return the scale factor of the thresholded image that would be returned by
 *         GetThresholdedImage().
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetThresholdedImageScaleFactor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1736
 *         return self._baseapi.GetThresholdedImageScaleFactor()
 * 
 *     def AnalyseLayout(self, bool merge_similar_words=False):             # <<<<<<<<<<<<<<
 *         """Runs page layout analysis in the mode set by :meth:`SetPageSegMode`.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_75AnalyseLayout(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_74AnalyseLayout[] = "Runs page layout analysis in the mode set by :meth:`SetPageSegMode`.\n\n        May optionally be called prior to :meth:`Recognize` to get access to just\n        the page layout results. Returns a :class:`PyPageIterator` iterator to the results.\n\n        Kwargs:\n            merge_similar_words (bool): If ``True``, words are combined where suitable\n            for use with a line recognizer. Use if you want to use AnalyseLayout to find the\n            textlines, and then want to process textline fragments with an external\n            line recognizer.\n        Returns:\n            :class:`PyPageIterator`: Page iterator or `None` on error or an empty page.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_75AnalyseLayout(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  bool __pyx_v_merge_similar_words;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("AnalyseLayout (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_merge_similar_words,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_merge_similar_words);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "AnalyseLayout") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1736; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_merge_similar_words = __Pyx_PyObject_IsTrue(values[0]); if (unlikely((__pyx_v_merge_similar_words == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1736; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_merge_similar_words = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("AnalyseLayout", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1736; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.AnalyseLayout", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_74AnalyseLayout(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_merge_similar_words);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_74AnalyseLayout(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, bool __pyx_v_merge_similar_words) {
  tesseract::PageIterator *__pyx_v_piter;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("AnalyseLayout", 0);

  /* "tesserocr.pyx":1751
 *         """
 *         cdef PageIterator *piter
 *         piter = self._baseapi.AnalyseLayout(merge_similar_words)             # <<<<<<<<<<<<<<
 *         if piter == NULL:
 *             return None
 */
  __pyx_v_piter = __pyx_v_self->_baseapi.AnalyseLayout(__pyx_v_merge_similar_words);

  /* "tesserocr.pyx":1752
 *         cdef PageIterator *piter
 *         piter = self._baseapi.AnalyseLayout(merge_similar_words)
 *         if piter == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return PyPageIterator.createPageIterator(piter)
 */
  __pyx_t_1 = ((__pyx_v_piter == NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1753
 *         piter = self._baseapi.AnalyseLayout(merge_similar_words)
 *         if piter == NULL:
 *             return None             # <<<<<<<<<<<<<<
 *         return PyPageIterator.createPageIterator(piter)
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "tesserocr.pyx":1752
 *         cdef PageIterator *piter
 *         piter = self._baseapi.AnalyseLayout(merge_similar_words)
 *         if piter == NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return PyPageIterator.createPageIterator(piter)
 */
  }

  /* "tesserocr.pyx":1754
 *         if piter == NULL:
 *             return None
 *         return PyPageIterator.createPageIterator(piter)             # <<<<<<<<<<<<<<
 * 
 *     def Recognize(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = ((PyObject *)__pyx_f_9tesserocr_14PyPageIterator_createPageIterator(__pyx_v_piter)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1754; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1736
 *         return self._baseapi.GetThresholdedImageScaleFactor()
 * 
 *     def AnalyseLayout(self, bool merge_similar_words=False):             # <<<<<<<<<<<<<<
 *         """Runs page layout analysis in the mode set by :meth:`SetPageSegMode`.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.AnalyseLayout", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1756
 *         return PyPageIterator.createPageIterator(piter)
 * 
 *     def Recognize(self):             # <<<<<<<<<<<<<<
 *         """Recognize the image from :meth:`SetImage`, generating Tesseract
 *         internal structures. Returns ``True`` on success.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_77Recognize(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_76Recognize[] = "Recognize the image from :meth:`SetImage`, generating Tesseract\n        internal structures. Returns ``True`` on success.\n\n        Optional. The `Get*Text` methods below will call :meth:`Recognize` if needed.\n\n        After :meth:`Recognize`, the output is kept internally until the next :meth:`SetImage`.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_77Recognize(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Recognize (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_76Recognize(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_76Recognize(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  ETEXT_DESC __pyx_v_monitor;
  int __pyx_v_res;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Recognize", 0);

  /* "tesserocr.pyx":1767
 *             ETEXT_DESC monitor
 *             int res
 *         with nogil:             # <<<<<<<<<<<<<<
 *             res = self._baseapi.Recognize(&monitor)
 *         return res == 0
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1768
 *             int res
 *         with nogil:
 *             res = self._baseapi.Recognize(&monitor)             # <<<<<<<<<<<<<<
 *         return res == 0
 * 
 */
        __pyx_v_res = __pyx_v_self->_baseapi.Recognize((&__pyx_v_monitor));
      }

      /* "tesserocr.pyx":1767
 *             ETEXT_DESC monitor
 *             int res
 *         with nogil:             # <<<<<<<<<<<<<<
 *             res = self._baseapi.Recognize(&monitor)
 *         return res == 0
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1769
 *         with nogil:
 *             res = self._baseapi.Recognize(&monitor)
 *         return res == 0             # <<<<<<<<<<<<<<
 * 
 *     """Methods to retrieve information after :meth:`SetImage`,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong((__pyx_v_res == 0)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1756
 *         return PyPageIterator.createPageIterator(piter)
 * 
 *     def Recognize(self):             # <<<<<<<<<<<<<<
 *         """Recognize the image from :meth:`SetImage`, generating Tesseract
 *         internal structures. Returns ``True`` on success.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.Recognize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1774
 *     :meth:`Recognize` or :meth:`TesseractRect`. (:meth:`Recognize` is called implicitly if needed.)"""
 * 
 *     def RecognizeForChopTest(self):             # <<<<<<<<<<<<<<
 *         """Variant on :meth:`Recognize` used for testing chopper."""
 *         cdef:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_79RecognizeForChopTest(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_78RecognizeForChopTest[] = "Variant on :meth:`Recognize` used for testing chopper.";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_79RecognizeForChopTest(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("RecognizeForChopTest (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_78RecognizeForChopTest(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_78RecognizeForChopTest(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  ETEXT_DESC __pyx_v_monitor;
  int __pyx_v_res;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("RecognizeForChopTest", 0);

  /* "tesserocr.pyx":1779
 *             ETEXT_DESC monitor
 *             int res
 *         with nogil:             # <<<<<<<<<<<<<<
 *             res = self._baseapi.RecognizeForChopTest(&monitor)
 *         return res == 0
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1780
 *             int res
 *         with nogil:
 *             res = self._baseapi.RecognizeForChopTest(&monitor)             # <<<<<<<<<<<<<<
 *         return res == 0
 * 
 */
        __pyx_v_res = __pyx_v_self->_baseapi.RecognizeForChopTest((&__pyx_v_monitor));
      }

      /* "tesserocr.pyx":1779
 *             ETEXT_DESC monitor
 *             int res
 *         with nogil:             # <<<<<<<<<<<<<<
 *             res = self._baseapi.RecognizeForChopTest(&monitor)
 *         return res == 0
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1781
 *         with nogil:
 *             res = self._baseapi.RecognizeForChopTest(&monitor)
 *         return res == 0             # <<<<<<<<<<<<<<
 * 
 *     cdef TessResultRenderer *_get_renderer(self, cchar_t *outputbase):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong((__pyx_v_res == 0)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1781; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1774
 *     :meth:`Recognize` or :meth:`TesseractRect`. (:meth:`Recognize` is called implicitly if needed.)"""
 * 
 *     def RecognizeForChopTest(self):             # <<<<<<<<<<<<<<
 *         """Variant on :meth:`Recognize` used for testing chopper."""
 *         cdef:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.RecognizeForChopTest", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1783
 *         return res == 0
 * 
 *     cdef TessResultRenderer *_get_renderer(self, cchar_t *outputbase):             # <<<<<<<<<<<<<<
 *         cdef:
 *             bool b
 */

static tesseract::TessResultRenderer *__pyx_f_9tesserocr_13PyTessBaseAPI__get_renderer(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_outputbase) {
  bool __pyx_v_b;
  bool __pyx_v_font_info;
  tesseract::TessResultRenderer *__pyx_v_temp;
  tesseract::TessResultRenderer *__pyx_v_renderer;
  tesseract::TessResultRenderer *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  tesseract::TessHOcrRenderer *__pyx_t_2;
  tesseract::TessPDFRenderer *__pyx_t_3;
  tesseract::TessUnlvRenderer *__pyx_t_4;
  tesseract::TessBoxTextRenderer *__pyx_t_5;
  tesseract::TessTextRenderer *__pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_get_renderer", 0);

  /* "tesserocr.pyx":1788
 *             bool font_info
 *             TessResultRenderer *temp
 *             TessResultRenderer *renderer = NULL             # <<<<<<<<<<<<<<
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_hocr", &b)
 */
  __pyx_v_renderer = NULL;

  /* "tesserocr.pyx":1790
 *             TessResultRenderer *renderer = NULL
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_hocr", &b)             # <<<<<<<<<<<<<<
 *         if b:
 *             self._baseapi.GetBoolVariable("hocr_font_info", &font_info)
 */
  __pyx_v_self->_baseapi.GetBoolVariable(__pyx_k_tessedit_create_hocr, (&__pyx_v_b));

  /* "tesserocr.pyx":1791
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_hocr", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             self._baseapi.GetBoolVariable("hocr_font_info", &font_info)
 *             renderer = new TessHOcrRenderer(outputbase, font_info)
 */
  __pyx_t_1 = (__pyx_v_b != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1792
 *         self._baseapi.GetBoolVariable("tessedit_create_hocr", &b)
 *         if b:
 *             self._baseapi.GetBoolVariable("hocr_font_info", &font_info)             # <<<<<<<<<<<<<<
 *             renderer = new TessHOcrRenderer(outputbase, font_info)
 * 
 */
    __pyx_v_self->_baseapi.GetBoolVariable(__pyx_k_hocr_font_info, (&__pyx_v_font_info));

    /* "tesserocr.pyx":1793
 *         if b:
 *             self._baseapi.GetBoolVariable("hocr_font_info", &font_info)
 *             renderer = new TessHOcrRenderer(outputbase, font_info)             # <<<<<<<<<<<<<<
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_pdf", &b)
 */
    try {
      __pyx_t_2 = new tesseract::TessHOcrRenderer(__pyx_v_outputbase, __pyx_v_font_info);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1793; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_v_renderer = __pyx_t_2;

    /* "tesserocr.pyx":1791
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_hocr", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             self._baseapi.GetBoolVariable("hocr_font_info", &font_info)
 *             renderer = new TessHOcrRenderer(outputbase, font_info)
 */
  }

  /* "tesserocr.pyx":1795
 *             renderer = new TessHOcrRenderer(outputbase, font_info)
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_pdf", &b)             # <<<<<<<<<<<<<<
 *         if b:
 *             temp = new TessPDFRenderer(outputbase, self._baseapi.GetDatapath())
 */
  __pyx_v_self->_baseapi.GetBoolVariable(__pyx_k_tessedit_create_pdf, (&__pyx_v_b));

  /* "tesserocr.pyx":1796
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_pdf", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             temp = new TessPDFRenderer(outputbase, self._baseapi.GetDatapath())
 *             if renderer == NULL:
 */
  __pyx_t_1 = (__pyx_v_b != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1797
 *         self._baseapi.GetBoolVariable("tessedit_create_pdf", &b)
 *         if b:
 *             temp = new TessPDFRenderer(outputbase, self._baseapi.GetDatapath())             # <<<<<<<<<<<<<<
 *             if renderer == NULL:
 *                 renderer = temp
 */
    try {
      __pyx_t_3 = new tesseract::TessPDFRenderer(__pyx_v_outputbase, __pyx_v_self->_baseapi.GetDatapath());
    } catch(...) {
      __Pyx_CppExn2PyErr();
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1797; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_v_temp = __pyx_t_3;

    /* "tesserocr.pyx":1798
 *         if b:
 *             temp = new TessPDFRenderer(outputbase, self._baseapi.GetDatapath())
 *             if renderer == NULL:             # <<<<<<<<<<<<<<
 *                 renderer = temp
 *             else:
 */
    __pyx_t_1 = ((__pyx_v_renderer == NULL) != 0);
    if (__pyx_t_1) {

      /* "tesserocr.pyx":1799
 *             temp = new TessPDFRenderer(outputbase, self._baseapi.GetDatapath())
 *             if renderer == NULL:
 *                 renderer = temp             # <<<<<<<<<<<<<<
 *             else:
 *                 renderer.insert(temp)
 */
      __pyx_v_renderer = __pyx_v_temp;

      /* "tesserocr.pyx":1798
 *         if b:
 *             temp = new TessPDFRenderer(outputbase, self._baseapi.GetDatapath())
 *             if renderer == NULL:             # <<<<<<<<<<<<<<
 *                 renderer = temp
 *             else:
 */
      goto __pyx_L5;
    }

    /* "tesserocr.pyx":1801
 *                 renderer = temp
 *             else:
 *                 renderer.insert(temp)             # <<<<<<<<<<<<<<
 * 
 *         self._baseapi.GetBoolVariable("tessedit_write_unlv", &b)
 */
    /*else*/ {
      __pyx_v_renderer->insert(__pyx_v_temp);
    }
    __pyx_L5:;

    /* "tesserocr.pyx":1796
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_pdf", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             temp = new TessPDFRenderer(outputbase, self._baseapi.GetDatapath())
 *             if renderer == NULL:
 */
  }

  /* "tesserocr.pyx":1803
 *                 renderer.insert(temp)
 * 
 *         self._baseapi.GetBoolVariable("tessedit_write_unlv", &b)             # <<<<<<<<<<<<<<
 *         if b:
 *             temp = new TessUnlvRenderer(outputbase)
 */
  __pyx_v_self->_baseapi.GetBoolVariable(__pyx_k_tessedit_write_unlv, (&__pyx_v_b));

  /* "tesserocr.pyx":1804
 * 
 *         self._baseapi.GetBoolVariable("tessedit_write_unlv", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             temp = new TessUnlvRenderer(outputbase)
 *             if renderer == NULL:
 */
  __pyx_t_1 = (__pyx_v_b != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1805
 *         self._baseapi.GetBoolVariable("tessedit_write_unlv", &b)
 *         if b:
 *             temp = new TessUnlvRenderer(outputbase)             # <<<<<<<<<<<<<<
 *             if renderer == NULL:
 *                 renderer = temp
 */
    try {
      __pyx_t_4 = new tesseract::TessUnlvRenderer(__pyx_v_outputbase);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1805; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_v_temp = __pyx_t_4;

    /* "tesserocr.pyx":1806
 *         if b:
 *             temp = new TessUnlvRenderer(outputbase)
 *             if renderer == NULL:             # <<<<<<<<<<<<<<
 *                 renderer = temp
 *             else:
 */
    __pyx_t_1 = ((__pyx_v_renderer == NULL) != 0);
    if (__pyx_t_1) {

      /* "tesserocr.pyx":1807
 *             temp = new TessUnlvRenderer(outputbase)
 *             if renderer == NULL:
 *                 renderer = temp             # <<<<<<<<<<<<<<
 *             else:
 *                 renderer.insert(temp)
 */
      __pyx_v_renderer = __pyx_v_temp;

      /* "tesserocr.pyx":1806
 *         if b:
 *             temp = new TessUnlvRenderer(outputbase)
 *             if renderer == NULL:             # <<<<<<<<<<<<<<
 *                 renderer = temp
 *             else:
 */
      goto __pyx_L7;
    }

    /* "tesserocr.pyx":1809
 *                 renderer = temp
 *             else:
 *                 renderer.insert(temp)             # <<<<<<<<<<<<<<
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_boxfile", &b)
 */
    /*else*/ {
      __pyx_v_renderer->insert(__pyx_v_temp);
    }
    __pyx_L7:;

    /* "tesserocr.pyx":1804
 * 
 *         self._baseapi.GetBoolVariable("tessedit_write_unlv", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             temp = new TessUnlvRenderer(outputbase)
 *             if renderer == NULL:
 */
  }

  /* "tesserocr.pyx":1811
 *                 renderer.insert(temp)
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_boxfile", &b)             # <<<<<<<<<<<<<<
 *         if b:
 *             temp = new TessBoxTextRenderer(outputbase)
 */
  __pyx_v_self->_baseapi.GetBoolVariable(__pyx_k_tessedit_create_boxfile, (&__pyx_v_b));

  /* "tesserocr.pyx":1812
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_boxfile", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             temp = new TessBoxTextRenderer(outputbase)
 *             if renderer == NULL:
 */
  __pyx_t_1 = (__pyx_v_b != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1813
 *         self._baseapi.GetBoolVariable("tessedit_create_boxfile", &b)
 *         if b:
 *             temp = new TessBoxTextRenderer(outputbase)             # <<<<<<<<<<<<<<
 *             if renderer == NULL:
 *                 renderer = temp
 */
    try {
      __pyx_t_5 = new tesseract::TessBoxTextRenderer(__pyx_v_outputbase);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_v_temp = __pyx_t_5;

    /* "tesserocr.pyx":1814
 *         if b:
 *             temp = new TessBoxTextRenderer(outputbase)
 *             if renderer == NULL:             # <<<<<<<<<<<<<<
 *                 renderer = temp
 *             else:
 */
    __pyx_t_1 = ((__pyx_v_renderer == NULL) != 0);
    if (__pyx_t_1) {

      /* "tesserocr.pyx":1815
 *             temp = new TessBoxTextRenderer(outputbase)
 *             if renderer == NULL:
 *                 renderer = temp             # <<<<<<<<<<<<<<
 *             else:
 *                 renderer.insert(temp)
 */
      __pyx_v_renderer = __pyx_v_temp;

      /* "tesserocr.pyx":1814
 *         if b:
 *             temp = new TessBoxTextRenderer(outputbase)
 *             if renderer == NULL:             # <<<<<<<<<<<<<<
 *                 renderer = temp
 *             else:
 */
      goto __pyx_L9;
    }

    /* "tesserocr.pyx":1817
 *                 renderer = temp
 *             else:
 *                 renderer.insert(temp)             # <<<<<<<<<<<<<<
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_txt", &b)
 */
    /*else*/ {
      __pyx_v_renderer->insert(__pyx_v_temp);
    }
    __pyx_L9:;

    /* "tesserocr.pyx":1812
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_boxfile", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             temp = new TessBoxTextRenderer(outputbase)
 *             if renderer == NULL:
 */
  }

  /* "tesserocr.pyx":1819
 *                 renderer.insert(temp)
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_txt", &b)             # <<<<<<<<<<<<<<
 *         if b:
 *             temp = new TessTextRenderer(outputbase)
 */
  __pyx_v_self->_baseapi.GetBoolVariable(__pyx_k_tessedit_create_txt, (&__pyx_v_b));

  /* "tesserocr.pyx":1820
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_txt", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             temp = new TessTextRenderer(outputbase)
 *             if renderer == NULL:
 */
  __pyx_t_1 = (__pyx_v_b != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1821
 *         self._baseapi.GetBoolVariable("tessedit_create_txt", &b)
 *         if b:
 *             temp = new TessTextRenderer(outputbase)             # <<<<<<<<<<<<<<
 *             if renderer == NULL:
 *                 renderer = temp
 */
    try {
      __pyx_t_6 = new tesseract::TessTextRenderer(__pyx_v_outputbase);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_v_temp = __pyx_t_6;

    /* "tesserocr.pyx":1822
 *         if b:
 *             temp = new TessTextRenderer(outputbase)
 *             if renderer == NULL:             # <<<<<<<<<<<<<<
 *                 renderer = temp
 *             else:
 */
    __pyx_t_1 = ((__pyx_v_renderer == NULL) != 0);
    if (__pyx_t_1) {

      /* "tesserocr.pyx":1823
 *             temp = new TessTextRenderer(outputbase)
 *             if renderer == NULL:
 *                 renderer = temp             # <<<<<<<<<<<<<<
 *             else:
 *                 renderer.insert(temp)
 */
      __pyx_v_renderer = __pyx_v_temp;

      /* "tesserocr.pyx":1822
 *         if b:
 *             temp = new TessTextRenderer(outputbase)
 *             if renderer == NULL:             # <<<<<<<<<<<<<<
 *                 renderer = temp
 *             else:
 */
      goto __pyx_L11;
    }

    /* "tesserocr.pyx":1825
 *                 renderer = temp
 *             else:
 *                 renderer.insert(temp)             # <<<<<<<<<<<<<<
 * 
 *         return renderer
 */
    /*else*/ {
      __pyx_v_renderer->insert(__pyx_v_temp);
    }
    __pyx_L11:;

    /* "tesserocr.pyx":1820
 * 
 *         self._baseapi.GetBoolVariable("tessedit_create_txt", &b)
 *         if b:             # <<<<<<<<<<<<<<
 *             temp = new TessTextRenderer(outputbase)
 *             if renderer == NULL:
 */
  }

  /* "tesserocr.pyx":1827
 *                 renderer.insert(temp)
 * 
 *         return renderer             # <<<<<<<<<<<<<<
 * 
 *     def ProcessPages(self, cchar_t *outputbase, cchar_t *filename,
 */
  __pyx_r = __pyx_v_renderer;
  goto __pyx_L0;

  /* "tesserocr.pyx":1783
 *         return res == 0
 * 
 *     cdef TessResultRenderer *_get_renderer(self, cchar_t *outputbase):             # <<<<<<<<<<<<<<
 *         cdef:
 *             bool b
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("tesserocr.PyTessBaseAPI._get_renderer", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1829
 *         return renderer
 * 
 *     def ProcessPages(self, cchar_t *outputbase, cchar_t *filename,             # <<<<<<<<<<<<<<
 *                      cchar_t *retry_config=NULL, int timeout=0):
 *         """Turns images into symbolic text.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_81ProcessPages(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_80ProcessPages[] = "Turns images into symbolic text.\n\n        Set at least one of the following variables to enable renderers\n        before calling this method::\n\n            tessedit_create_hocr (bool): hOCR Renderer\n                if ``font_info`` is ``True`` then it'll be included in the output.\n            tessedit_create_pdf (bool): PDF Renderer\n            tessedit_write_unlv (bool): UNLV Renderer\n            tessedit_create_boxfile (bool): Box Text Renderer\n            tessedit_create_txt (bool): Text Renderer\n\n        .. note:\n\n            If tessedit_page_number variable is non-negative, will only process that\n            single page. Works for multi-page tiff file, or filelist.\n\n        Args:\n            outputbase (str): The name of the output file excluding\n                extension. For example, \"/path/to/chocolate-chip-cookie-recipe\".\n            filename (str): Can point to a single image, a multi-page TIFF,\n                or a plain text list of image filenames.\n\n        Kwargs:\n            retry_config (str): Is useful for debugging. If specified, you can fall\n                back to an alternate configuration if a page fails for some reason.\n            timeout (int): Terminates processing if any single page\n                takes too long (`timeout` milliseconds). Defaults to 0 (unlimited).\n\n        Returns:\n            bool: True if successful, False on error.\n\n        Raises:\n            :exc:`RuntimeError`: If no renderers enabled in api variables.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_81ProcessPages(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_outputbase;
  __pyx_t_9tesseract_cchar_t *__pyx_v_filename;
  __pyx_t_9tesseract_cchar_t *__pyx_v_retry_config;
  int __pyx_v_timeout;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ProcessPages (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_outputbase,&__pyx_n_s_filename,&__pyx_n_s_retry_config,&__pyx_n_s_timeout,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_outputbase)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_filename)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ProcessPages", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1829; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_retry_config);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_timeout);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ProcessPages") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1829; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_outputbase = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_outputbase) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1829; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_filename = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_filename) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1829; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[2]) {
      __pyx_v_retry_config = __Pyx_PyObject_AsString(values[2]); if (unlikely((!__pyx_v_retry_config) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1830; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "tesserocr.pyx":1830
 * 
 *     def ProcessPages(self, cchar_t *outputbase, cchar_t *filename,
 *                      cchar_t *retry_config=NULL, int timeout=0):             # <<<<<<<<<<<<<<
 *         """Turns images into symbolic text.
 * 
 */
      __pyx_v_retry_config = ((__pyx_t_9tesseract_cchar_t *)NULL);
    }
    if (values[3]) {
      __pyx_v_timeout = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_timeout == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1830; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeout = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ProcessPages", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1829; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.ProcessPages", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_80ProcessPages(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_outputbase, __pyx_v_filename, __pyx_v_retry_config, __pyx_v_timeout);

  /* "tesserocr.pyx":1829
 *         return renderer
 * 
 *     def ProcessPages(self, cchar_t *outputbase, cchar_t *filename,             # <<<<<<<<<<<<<<
 *                      cchar_t *retry_config=NULL, int timeout=0):
 *         """Turns images into symbolic text.
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_80ProcessPages(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_outputbase, __pyx_t_9tesseract_cchar_t *__pyx_v_filename, __pyx_t_9tesseract_cchar_t *__pyx_v_retry_config, int __pyx_v_timeout) {
  tesseract::TessResultRenderer *__pyx_v_renderer;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ProcessPages", 0);

  /* "tesserocr.pyx":1866
 *             :exc:`RuntimeError`: If no renderers enabled in api variables.
 *         """
 *         cdef TessResultRenderer *renderer = self._get_renderer(outputbase)             # <<<<<<<<<<<<<<
 *         if renderer != NULL:
 *             try:
 */
  __pyx_v_renderer = ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_get_renderer(__pyx_v_self, __pyx_v_outputbase);

  /* "tesserocr.pyx":1867
 *         """
 *         cdef TessResultRenderer *renderer = self._get_renderer(outputbase)
 *         if renderer != NULL:             # <<<<<<<<<<<<<<
 *             try:
 *                 return self._baseapi.ProcessPages(filename, retry_config, timeout, renderer)
 */
  __pyx_t_1 = ((__pyx_v_renderer != NULL) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":1868
 *         cdef TessResultRenderer *renderer = self._get_renderer(outputbase)
 *         if renderer != NULL:
 *             try:             # <<<<<<<<<<<<<<
 *                 return self._baseapi.ProcessPages(filename, retry_config, timeout, renderer)
 *             except:
 */
    {
      __Pyx_ExceptionSave(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4);
      __Pyx_XGOTREF(__pyx_t_2);
      __Pyx_XGOTREF(__pyx_t_3);
      __Pyx_XGOTREF(__pyx_t_4);
      /*try:*/ {

        /* "tesserocr.pyx":1869
 *         if renderer != NULL:
 *             try:
 *                 return self._baseapi.ProcessPages(filename, retry_config, timeout, renderer)             # <<<<<<<<<<<<<<
 *             except:
 *                 del renderer
 */
        __Pyx_XDECREF(__pyx_r);
        __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_self->_baseapi.ProcessPages(__pyx_v_filename, __pyx_v_retry_config, __pyx_v_timeout, __pyx_v_renderer)); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1869; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_r = __pyx_t_5;
        __pyx_t_5 = 0;
        goto __pyx_L8_try_return;

        /* "tesserocr.pyx":1868
 *         cdef TessResultRenderer *renderer = self._get_renderer(outputbase)
 *         if renderer != NULL:
 *             try:             # <<<<<<<<<<<<<<
 *                 return self._baseapi.ProcessPages(filename, retry_config, timeout, renderer)
 *             except:
 */
      }
      __pyx_L4_error:;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "tesserocr.pyx":1870
 *             try:
 *                 return self._baseapi.ProcessPages(filename, retry_config, timeout, renderer)
 *             except:             # <<<<<<<<<<<<<<
 *                 del renderer
 *         raise RuntimeError('No renderers enabled')
 */
      /*except:*/ {
        __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.ProcessPages", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1870; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GOTREF(__pyx_t_7);

        /* "tesserocr.pyx":1871
 *                 return self._baseapi.ProcessPages(filename, retry_config, timeout, renderer)
 *             except:
 *                 del renderer             # <<<<<<<<<<<<<<
 *         raise RuntimeError('No renderers enabled')
 * 
 */
        delete __pyx_v_renderer;
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        goto __pyx_L5_exception_handled;
      }
      __pyx_L6_except_error:;

      /* "tesserocr.pyx":1868
 *         cdef TessResultRenderer *renderer = self._get_renderer(outputbase)
 *         if renderer != NULL:
 *             try:             # <<<<<<<<<<<<<<
 *                 return self._baseapi.ProcessPages(filename, retry_config, timeout, renderer)
 *             except:
 */
      __Pyx_XGIVEREF(__pyx_t_2);
      __Pyx_XGIVEREF(__pyx_t_3);
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
      goto __pyx_L1_error;
      __pyx_L8_try_return:;
      __Pyx_XGIVEREF(__pyx_t_2);
      __Pyx_XGIVEREF(__pyx_t_3);
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
      goto __pyx_L0;
      __pyx_L5_exception_handled:;
      __Pyx_XGIVEREF(__pyx_t_2);
      __Pyx_XGIVEREF(__pyx_t_3);
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
    }

    /* "tesserocr.pyx":1867
 *         """
 *         cdef TessResultRenderer *renderer = self._get_renderer(outputbase)
 *         if renderer != NULL:             # <<<<<<<<<<<<<<
 *             try:
 *                 return self._baseapi.ProcessPages(filename, retry_config, timeout, renderer)
 */
  }

  /* "tesserocr.pyx":1872
 *             except:
 *                 del renderer
 *         raise RuntimeError('No renderers enabled')             # <<<<<<<<<<<<<<
 * 
 *     def ProcessPage(self, cchar_t *outputbase, image, int page_index, cchar_t *filename,
 */
  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1872; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_Raise(__pyx_t_7, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1872; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1829
 *         return renderer
 * 
 *     def ProcessPages(self, cchar_t *outputbase, cchar_t *filename,             # <<<<<<<<<<<<<<
 *                      cchar_t *retry_config=NULL, int timeout=0):
 *         """Turns images into symbolic text.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.ProcessPages", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1874
 *         raise RuntimeError('No renderers enabled')
 * 
 *     def ProcessPage(self, cchar_t *outputbase, image, int page_index, cchar_t *filename,             # <<<<<<<<<<<<<<
 *                     cchar_t *retry_config=NULL, int timeout=0):
 *         """Turn a single image into symbolic text.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_83ProcessPage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_82ProcessPage[] = "Turn a single image into symbolic text.\n\n        See :meth:`ProcessPages` for desciptions of the keyword arguments\n        and all other details.\n\n        Args:\n            outputbase (str): The name of the output file excluding\n                extension. For example, \"/path/to/chocolate-chip-cookie-recipe\".\n            image (:class:`PIL.Image`): The image processed.\n            page_index (int): Page index (metadata).\n            filename (str): `filename` and `page_index` are metadata\n                used by side-effect processes, such as reading a box\n                file or formatting as hOCR.\n\n        Raises:\n            RuntimeError: If `image` is invalid or no renderers are enabled.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_83ProcessPage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_outputbase;
  PyObject *__pyx_v_image = 0;
  int __pyx_v_page_index;
  __pyx_t_9tesseract_cchar_t *__pyx_v_filename;
  __pyx_t_9tesseract_cchar_t *__pyx_v_retry_config;
  int __pyx_v_timeout;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ProcessPage (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_outputbase,&__pyx_n_s_image,&__pyx_n_s_page_index,&__pyx_n_s_filename,&__pyx_n_s_retry_config,&__pyx_n_s_timeout,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_outputbase)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_image)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ProcessPage", 0, 4, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1874; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_page_index)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ProcessPage", 0, 4, 6, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1874; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_filename)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ProcessPage", 0, 4, 6, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1874; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_retry_config);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_timeout);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ProcessPage") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1874; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_outputbase = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_outputbase) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1874; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_image = values[1];
    __pyx_v_page_index = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_page_index == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1874; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_filename = __Pyx_PyObject_AsString(values[3]); if (unlikely((!__pyx_v_filename) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1874; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[4]) {
      __pyx_v_retry_config = __Pyx_PyObject_AsString(values[4]); if (unlikely((!__pyx_v_retry_config) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1875; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "tesserocr.pyx":1875
 * 
 *     def ProcessPage(self, cchar_t *outputbase, image, int page_index, cchar_t *filename,
 *                     cchar_t *retry_config=NULL, int timeout=0):             # <<<<<<<<<<<<<<
 *         """Turn a single image into symbolic text.
 * 
 */
      __pyx_v_retry_config = ((__pyx_t_9tesseract_cchar_t *)NULL);
    }
    if (values[5]) {
      __pyx_v_timeout = __Pyx_PyInt_As_int(values[5]); if (unlikely((__pyx_v_timeout == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1875; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeout = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ProcessPage", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1874; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.ProcessPage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_82ProcessPage(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_outputbase, __pyx_v_image, __pyx_v_page_index, __pyx_v_filename, __pyx_v_retry_config, __pyx_v_timeout);

  /* "tesserocr.pyx":1874
 *         raise RuntimeError('No renderers enabled')
 * 
 *     def ProcessPage(self, cchar_t *outputbase, image, int page_index, cchar_t *filename,             # <<<<<<<<<<<<<<
 *                     cchar_t *retry_config=NULL, int timeout=0):
 *         """Turn a single image into symbolic text.
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_82ProcessPage(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_outputbase, PyObject *__pyx_v_image, int __pyx_v_page_index, __pyx_t_9tesseract_cchar_t *__pyx_v_filename, __pyx_t_9tesseract_cchar_t *__pyx_v_retry_config, int __pyx_v_timeout) {
  tesseract::TessResultRenderer *__pyx_v_renderer;
  __pyx_t_9tesseract_cuchar_t *__pyx_v_buff;
  size_t __pyx_v_size;
  struct Pix *__pyx_v_pix;
  PyObject *__pyx_v_raw = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  __pyx_t_9tesseract_cuchar_t *__pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  char const *__pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ProcessPage", 0);

  /* "tesserocr.pyx":1894
 *         """
 *         cdef:
 *             TessResultRenderer *renderer = self._get_renderer(outputbase)             # <<<<<<<<<<<<<<
 *             cuchar_t *buff
 *             size_t size
 */
  __pyx_v_renderer = ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_get_renderer(__pyx_v_self, __pyx_v_outputbase);

  /* "tesserocr.pyx":1898
 *             size_t size
 *             Pix *pix
 *         raw = _image_buffer(image)             # <<<<<<<<<<<<<<
 *         size = len(raw)
 *         buff = raw
 */
  __pyx_t_1 = __pyx_f_9tesserocr__image_buffer(__pyx_v_image); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1898; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_raw = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":1899
 *             Pix *pix
 *         raw = _image_buffer(image)
 *         size = len(raw)             # <<<<<<<<<<<<<<
 *         buff = raw
 *         pix = pixReadMemBmp(buff, size)
 */
  __pyx_t_2 = PyObject_Length(__pyx_v_raw); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1899; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_size = __pyx_t_2;

  /* "tesserocr.pyx":1900
 *         raw = _image_buffer(image)
 *         size = len(raw)
 *         buff = raw             # <<<<<<<<<<<<<<
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:
 */
  __pyx_t_3 = __Pyx_PyObject_AsUString(__pyx_v_raw); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1900; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_buff = __pyx_t_3;

  /* "tesserocr.pyx":1901
 *         size = len(raw)
 *         buff = raw
 *         pix = pixReadMemBmp(buff, size)             # <<<<<<<<<<<<<<
 *         if pix == NULL:
 *             raise RuntimeError('Failed to read image')
 */
  __pyx_v_pix = pixReadMemBmp(__pyx_v_buff, __pyx_v_size);

  /* "tesserocr.pyx":1902
 *         buff = raw
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             raise RuntimeError('Failed to read image')
 *         if renderer != NULL:
 */
  __pyx_t_4 = ((__pyx_v_pix == NULL) != 0);
  if (__pyx_t_4) {

    /* "tesserocr.pyx":1903
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:
 *             raise RuntimeError('Failed to read image')             # <<<<<<<<<<<<<<
 *         if renderer != NULL:
 *             try:
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1903; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1903; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

    /* "tesserocr.pyx":1902
 *         buff = raw
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             raise RuntimeError('Failed to read image')
 *         if renderer != NULL:
 */
  }

  /* "tesserocr.pyx":1904
 *         if pix == NULL:
 *             raise RuntimeError('Failed to read image')
 *         if renderer != NULL:             # <<<<<<<<<<<<<<
 *             try:
 *                 return self._baseapi.ProcessPage(pix, page_index, filename, retry_config, timeout, renderer)
 */
  __pyx_t_4 = ((__pyx_v_renderer != NULL) != 0);
  if (__pyx_t_4) {

    /* "tesserocr.pyx":1905
 *             raise RuntimeError('Failed to read image')
 *         if renderer != NULL:
 *             try:             # <<<<<<<<<<<<<<
 *                 return self._baseapi.ProcessPage(pix, page_index, filename, retry_config, timeout, renderer)
 *             finally:
 */
    /*try:*/ {

      /* "tesserocr.pyx":1906
 *         if renderer != NULL:
 *             try:
 *                 return self._baseapi.ProcessPage(pix, page_index, filename, retry_config, timeout, renderer)             # <<<<<<<<<<<<<<
 *             finally:
 *                 pixDestroy(&pix)
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_baseapi.ProcessPage(__pyx_v_pix, __pyx_v_page_index, __pyx_v_filename, __pyx_v_retry_config, __pyx_v_timeout, __pyx_v_renderer)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1906; __pyx_clineno = __LINE__; goto __pyx_L6_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L5_return;
    }

    /* "tesserocr.pyx":1908
 *                 return self._baseapi.ProcessPage(pix, page_index, filename, retry_config, timeout, renderer)
 *             finally:
 *                 pixDestroy(&pix)             # <<<<<<<<<<<<<<
 *                 del renderer
 *         raise RuntimeError('No renderers enabled')
 */
    /*finally:*/ {
      /*exception exit:*/{
        __pyx_L6_error:;
        __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0;
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
        if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10) < 0)) __Pyx_ErrFetch(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
        __Pyx_XGOTREF(__pyx_t_8);
        __Pyx_XGOTREF(__pyx_t_9);
        __Pyx_XGOTREF(__pyx_t_10);
        __Pyx_XGOTREF(__pyx_t_11);
        __Pyx_XGOTREF(__pyx_t_12);
        __Pyx_XGOTREF(__pyx_t_13);
        __pyx_t_5 = __pyx_lineno; __pyx_t_6 = __pyx_clineno; __pyx_t_7 = __pyx_filename;
        {
          pixDestroy((&__pyx_v_pix));

          /* "tesserocr.pyx":1909
 *             finally:
 *                 pixDestroy(&pix)
 *                 del renderer             # <<<<<<<<<<<<<<
 *         raise RuntimeError('No renderers enabled')
 * 
 */
          delete __pyx_v_renderer;
        }
        if (PY_MAJOR_VERSION >= 3) {
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_XGIVEREF(__pyx_t_13);
          __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);
        }
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_ErrRestore(__pyx_t_8, __pyx_t_9, __pyx_t_10);
        __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0;
        __pyx_lineno = __pyx_t_5; __pyx_clineno = __pyx_t_6; __pyx_filename = __pyx_t_7;
        goto __pyx_L1_error;
      }
      __pyx_L5_return: {
        __pyx_t_13 = __pyx_r;
        __pyx_r = 0;

        /* "tesserocr.pyx":1908
 *                 return self._baseapi.ProcessPage(pix, page_index, filename, retry_config, timeout, renderer)
 *             finally:
 *                 pixDestroy(&pix)             # <<<<<<<<<<<<<<
 *                 del renderer
 *         raise RuntimeError('No renderers enabled')
 */
        pixDestroy((&__pyx_v_pix));

        /* "tesserocr.pyx":1909
 *             finally:
 *                 pixDestroy(&pix)
 *                 del renderer             # <<<<<<<<<<<<<<
 *         raise RuntimeError('No renderers enabled')
 * 
 */
        delete __pyx_v_renderer;
        __pyx_r = __pyx_t_13;
        __pyx_t_13 = 0;
        goto __pyx_L0;
      }
    }

    /* "tesserocr.pyx":1904
 *         if pix == NULL:
 *             raise RuntimeError('Failed to read image')
 *         if renderer != NULL:             # <<<<<<<<<<<<<<
 *             try:
 *                 return self._baseapi.ProcessPage(pix, page_index, filename, retry_config, timeout, renderer)
 */
  }

  /* "tesserocr.pyx":1910
 *                 pixDestroy(&pix)
 *                 del renderer
 *         raise RuntimeError('No renderers enabled')             # <<<<<<<<<<<<<<
 * 
 *     def GetIterator(self):
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1874
 *         raise RuntimeError('No renderers enabled')
 * 
 *     def ProcessPage(self, cchar_t *outputbase, image, int page_index, cchar_t *filename,             # <<<<<<<<<<<<<<
 *                     cchar_t *retry_config=NULL, int timeout=0):
 *         """Turn a single image into symbolic text.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.ProcessPage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_raw);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1912
 *         raise RuntimeError('No renderers enabled')
 * 
 *     def GetIterator(self):             # <<<<<<<<<<<<<<
 *         """Get a reading-order iterator to the results of :meth:`LayoutAnalysis` and/or
 *         :meth:`Recognize`.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_85GetIterator(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_84GetIterator[] = "Get a reading-order iterator to the results of :meth:`LayoutAnalysis` and/or\n        :meth:`Recognize`.\n\n        Returns:\n            :class:`PyResultIterator`: reading-order iterator.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_85GetIterator(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetIterator (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_84GetIterator(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_84GetIterator(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  tesseract::ResultIterator *__pyx_v_iterator;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetIterator", 0);

  /* "tesserocr.pyx":1919
 *             :class:`PyResultIterator`: reading-order iterator.
 *         """
 *         cdef ResultIterator *iterator = self._baseapi.GetIterator()             # <<<<<<<<<<<<<<
 *         return PyResultIterator.createResultIterator(iterator)
 * 
 */
  __pyx_v_iterator = __pyx_v_self->_baseapi.GetIterator();

  /* "tesserocr.pyx":1920
 *         """
 *         cdef ResultIterator *iterator = self._baseapi.GetIterator()
 *         return PyResultIterator.createResultIterator(iterator)             # <<<<<<<<<<<<<<
 * 
 *     def GetUTF8Text(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_9tesserocr_16PyResultIterator_createResultIterator(__pyx_v_iterator)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1920; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1912
 *         raise RuntimeError('No renderers enabled')
 * 
 *     def GetIterator(self):             # <<<<<<<<<<<<<<
 *         """Get a reading-order iterator to the results of :meth:`LayoutAnalysis` and/or
 *         :meth:`Recognize`.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetIterator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1922
 *         return PyResultIterator.createResultIterator(iterator)
 * 
 *     def GetUTF8Text(self):             # <<<<<<<<<<<<<<
 *         """Return the recognized text coded as UTF-8 from the image."""
 *         cdef char *text
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_87GetUTF8Text(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_86GetUTF8Text[] = "Return the recognized text coded as UTF-8 from the image.";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_87GetUTF8Text(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetUTF8Text (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_86GetUTF8Text(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_86GetUTF8Text(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetUTF8Text", 0);

  /* "tesserocr.pyx":1925
 *         """Return the recognized text coded as UTF-8 from the image."""
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.GetUTF8Text()
 *             self._destroy_pix()
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1926
 *         cdef char *text
 *         with nogil:
 *             text = self._baseapi.GetUTF8Text()             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             if text == NULL:
 */
        __pyx_v_text = __pyx_v_self->_baseapi.GetUTF8Text();

        /* "tesserocr.pyx":1927
 *         with nogil:
 *             text = self._baseapi.GetUTF8Text()
 *             self._destroy_pix()             # <<<<<<<<<<<<<<
 *             if text == NULL:
 *                 with gil:
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

        /* "tesserocr.pyx":1928
 *             text = self._baseapi.GetUTF8Text()
 *             self._destroy_pix()
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 */
        __pyx_t_1 = ((__pyx_v_text == NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":1929
 *             self._destroy_pix()
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":1930
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1930; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1930; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":1929
 *             self._destroy_pix()
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":1928
 *             text = self._baseapi.GetUTF8Text()
 *             self._destroy_pix()
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 */
        }
      }

      /* "tesserocr.pyx":1925
 *         """Return the recognized text coded as UTF-8 from the image."""
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.GetUTF8Text()
 *             self._destroy_pix()
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1931
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 *     def GetHOCRText(self, int page_number):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1931; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1922
 *         return PyResultIterator.createResultIterator(iterator)
 * 
 *     def GetUTF8Text(self):             # <<<<<<<<<<<<<<
 *         """Return the recognized text coded as UTF-8 from the image."""
 *         cdef char *text
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetUTF8Text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1933
 *         return _free_str(text)
 * 
 *     def GetHOCRText(self, int page_number):             # <<<<<<<<<<<<<<
 *         """Return a HTML-formatted string with hOCR markup from the internal
 *         data structures.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_89GetHOCRText(PyObject *__pyx_v_self, PyObject *__pyx_arg_page_number); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_88GetHOCRText[] = "Return a HTML-formatted string with hOCR markup from the internal\n        data structures.\n\n        Args:\n            page_number (int): Page number is 0-based but will appear in the output as 1-based.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_89GetHOCRText(PyObject *__pyx_v_self, PyObject *__pyx_arg_page_number) {
  int __pyx_v_page_number;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetHOCRText (wrapper)", 0);
  assert(__pyx_arg_page_number); {
    __pyx_v_page_number = __Pyx_PyInt_As_int(__pyx_arg_page_number); if (unlikely((__pyx_v_page_number == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1933; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetHOCRText", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_88GetHOCRText(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((int)__pyx_v_page_number));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_88GetHOCRText(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_page_number) {
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetHOCRText", 0);

  /* "tesserocr.pyx":1941
 *         """
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.GetHOCRText(page_number)
 *             self._destroy_pix()
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1942
 *         cdef char *text
 *         with nogil:
 *             text = self._baseapi.GetHOCRText(page_number)             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             if text == NULL:
 */
        __pyx_v_text = __pyx_v_self->_baseapi.GetHOCRText(__pyx_v_page_number);

        /* "tesserocr.pyx":1943
 *         with nogil:
 *             text = self._baseapi.GetHOCRText(page_number)
 *             self._destroy_pix()             # <<<<<<<<<<<<<<
 *             if text == NULL:
 *                 with gil:
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

        /* "tesserocr.pyx":1944
 *             text = self._baseapi.GetHOCRText(page_number)
 *             self._destroy_pix()
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 */
        __pyx_t_1 = ((__pyx_v_text == NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":1945
 *             self._destroy_pix()
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":1946
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1946; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1946; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":1945
 *             self._destroy_pix()
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":1944
 *             text = self._baseapi.GetHOCRText(page_number)
 *             self._destroy_pix()
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 */
        }
      }

      /* "tesserocr.pyx":1941
 *         """
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.GetHOCRText(page_number)
 *             self._destroy_pix()
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1947
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 *     def GetBoxText(self, int page_number):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1933
 *         return _free_str(text)
 * 
 *     def GetHOCRText(self, int page_number):             # <<<<<<<<<<<<<<
 *         """Return a HTML-formatted string with hOCR markup from the internal
 *         data structures.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetHOCRText", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1949
 *         return _free_str(text)
 * 
 *     def GetBoxText(self, int page_number):             # <<<<<<<<<<<<<<
 *         """Return recognized text coded in the same
 *         format as a box file used in training.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_91GetBoxText(PyObject *__pyx_v_self, PyObject *__pyx_arg_page_number); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_90GetBoxText[] = "Return recognized text coded in the same\n        format as a box file used in training.\n\n        Constructs coordinates in the original image - not just the rectangle.\n\n        Args:\n            page_number (int): Page number is a 0-based page index that will appear\n                in the box file.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_91GetBoxText(PyObject *__pyx_v_self, PyObject *__pyx_arg_page_number) {
  int __pyx_v_page_number;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetBoxText (wrapper)", 0);
  assert(__pyx_arg_page_number); {
    __pyx_v_page_number = __Pyx_PyInt_As_int(__pyx_arg_page_number); if (unlikely((__pyx_v_page_number == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1949; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetBoxText", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_90GetBoxText(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((int)__pyx_v_page_number));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_90GetBoxText(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_page_number) {
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetBoxText", 0);

  /* "tesserocr.pyx":1960
 *         """
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.GetBoxText(page_number)
 *             self._destroy_pix()
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1961
 *         cdef char *text
 *         with nogil:
 *             text = self._baseapi.GetBoxText(page_number)             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             if text == NULL:
 */
        __pyx_v_text = __pyx_v_self->_baseapi.GetBoxText(__pyx_v_page_number);

        /* "tesserocr.pyx":1962
 *         with nogil:
 *             text = self._baseapi.GetBoxText(page_number)
 *             self._destroy_pix()             # <<<<<<<<<<<<<<
 *             if text == NULL:
 *                 with gil:
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

        /* "tesserocr.pyx":1963
 *             text = self._baseapi.GetBoxText(page_number)
 *             self._destroy_pix()
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 */
        __pyx_t_1 = ((__pyx_v_text == NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":1964
 *             self._destroy_pix()
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":1965
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1965; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1965; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":1964
 *             self._destroy_pix()
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":1963
 *             text = self._baseapi.GetBoxText(page_number)
 *             self._destroy_pix()
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 */
        }
      }

      /* "tesserocr.pyx":1960
 *         """
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.GetBoxText(page_number)
 *             self._destroy_pix()
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1966
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 *     def GetUNLVText(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1966; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1949
 *         return _free_str(text)
 * 
 *     def GetBoxText(self, int page_number):             # <<<<<<<<<<<<<<
 *         """Return recognized text coded in the same
 *         format as a box file used in training.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetBoxText", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1968
 *         return _free_str(text)
 * 
 *     def GetUNLVText(self):             # <<<<<<<<<<<<<<
 *         """Return the recognized text coded as UNLV format Latin-1 with
 *         specific reject and suspect codes.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_93GetUNLVText(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_92GetUNLVText[] = "Return the recognized text coded as UNLV format Latin-1 with\n        specific reject and suspect codes.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_93GetUNLVText(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetUNLVText (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_92GetUNLVText(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_92GetUNLVText(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetUNLVText", 0);

  /* "tesserocr.pyx":1973
 *         """
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.GetUNLVText()
 *             self._destroy_pix()
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":1974
 *         cdef char *text
 *         with nogil:
 *             text = self._baseapi.GetUNLVText()             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             if text == NULL:
 */
        __pyx_v_text = __pyx_v_self->_baseapi.GetUNLVText();

        /* "tesserocr.pyx":1975
 *         with nogil:
 *             text = self._baseapi.GetUNLVText()
 *             self._destroy_pix()             # <<<<<<<<<<<<<<
 *             if text == NULL:
 *                 with gil:
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

        /* "tesserocr.pyx":1976
 *             text = self._baseapi.GetUNLVText()
 *             self._destroy_pix()
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 */
        __pyx_t_1 = ((__pyx_v_text == NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":1977
 *             self._destroy_pix()
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":1978
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1978; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1978; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":1977
 *             self._destroy_pix()
 *             if text == NULL:
 *                 with gil:             # <<<<<<<<<<<<<<
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":1976
 *             text = self._baseapi.GetUNLVText()
 *             self._destroy_pix()
 *             if text == NULL:             # <<<<<<<<<<<<<<
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 */
        }
      }

      /* "tesserocr.pyx":1973
 *         """
 *         cdef char *text
 *         with nogil:             # <<<<<<<<<<<<<<
 *             text = self._baseapi.GetUNLVText()
 *             self._destroy_pix()
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":1979
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')
 *         return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 *     def MeanTextConf(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1968
 *         return _free_str(text)
 * 
 *     def GetUNLVText(self):             # <<<<<<<<<<<<<<
 *         """Return the recognized text coded as UNLV format Latin-1 with
 *         specific reject and suspect codes.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetUNLVText", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1981
 *         return _free_str(text)
 * 
 *     def MeanTextConf(self):             # <<<<<<<<<<<<<<
 *         """Return the (average) confidence value between 0 and 100."""
 *         return self._baseapi.MeanTextConf()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_95MeanTextConf(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_94MeanTextConf[] = "Return the (average) confidence value between 0 and 100.";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_95MeanTextConf(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MeanTextConf (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_94MeanTextConf(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_94MeanTextConf(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MeanTextConf", 0);

  /* "tesserocr.pyx":1983
 *     def MeanTextConf(self):
 *         """Return the (average) confidence value between 0 and 100."""
 *         return self._baseapi.MeanTextConf()             # <<<<<<<<<<<<<<
 * 
 *     def AllWordConfidences(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_baseapi.MeanTextConf()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1983; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":1981
 *         return _free_str(text)
 * 
 *     def MeanTextConf(self):             # <<<<<<<<<<<<<<
 *         """Return the (average) confidence value between 0 and 100."""
 *         return self._baseapi.MeanTextConf()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.MeanTextConf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":1985
 *         return self._baseapi.MeanTextConf()
 * 
 *     def AllWordConfidences(self):             # <<<<<<<<<<<<<<
 *         """Return all word confidences (between 0 and 100) as a list.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_97AllWordConfidences(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_96AllWordConfidences[] = "Return all word confidences (between 0 and 100) as a list.\n\n        The number of confidences should correspond to the number of space-\n        delimited words in `GetUTF8Text`.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_97AllWordConfidences(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("AllWordConfidences (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_96AllWordConfidences(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_96AllWordConfidences(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  int *__pyx_v_confidences;
  int __pyx_v_confidence;
  size_t __pyx_v_i;
  PyObject *__pyx_v_confs = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("AllWordConfidences", 0);

  /* "tesserocr.pyx":1992
 *         """
 *         cdef:
 *             int *confidences = self._baseapi.AllWordConfidences()             # <<<<<<<<<<<<<<
 *             int confidence
 *             size_t i = 0
 */
  __pyx_v_confidences = __pyx_v_self->_baseapi.AllWordConfidences();

  /* "tesserocr.pyx":1994
 *             int *confidences = self._baseapi.AllWordConfidences()
 *             int confidence
 *             size_t i = 0             # <<<<<<<<<<<<<<
 * 
 *         confs = []
 */
  __pyx_v_i = 0;

  /* "tesserocr.pyx":1996
 *             size_t i = 0
 * 
 *         confs = []             # <<<<<<<<<<<<<<
 *         while confidences[i] != -1:
 *             confidence = confidences[i]
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1996; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_confs = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":1997
 * 
 *         confs = []
 *         while confidences[i] != -1:             # <<<<<<<<<<<<<<
 *             confidence = confidences[i]
 *             confs.append(confidence)
 */
  while (1) {
    __pyx_t_2 = (((__pyx_v_confidences[__pyx_v_i]) != -1L) != 0);
    if (!__pyx_t_2) break;

    /* "tesserocr.pyx":1998
 *         confs = []
 *         while confidences[i] != -1:
 *             confidence = confidences[i]             # <<<<<<<<<<<<<<
 *             confs.append(confidence)
 *             i += 1
 */
    __pyx_v_confidence = (__pyx_v_confidences[__pyx_v_i]);

    /* "tesserocr.pyx":1999
 *         while confidences[i] != -1:
 *             confidence = confidences[i]
 *             confs.append(confidence)             # <<<<<<<<<<<<<<
 *             i += 1
 *         free(confidences)
 */
    __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_confidence); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_PyList_Append(__pyx_v_confs, __pyx_t_1); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "tesserocr.pyx":2000
 *             confidence = confidences[i]
 *             confs.append(confidence)
 *             i += 1             # <<<<<<<<<<<<<<
 *         free(confidences)
 *         return confs
 */
    __pyx_v_i = (__pyx_v_i + 1);
  }

  /* "tesserocr.pyx":2001
 *             confs.append(confidence)
 *             i += 1
 *         free(confidences)             # <<<<<<<<<<<<<<
 *         return confs
 * 
 */
  free(__pyx_v_confidences);

  /* "tesserocr.pyx":2002
 *             i += 1
 *         free(confidences)
 *         return confs             # <<<<<<<<<<<<<<
 * 
 *     def MapWordConfidences(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_confs);
  __pyx_r = __pyx_v_confs;
  goto __pyx_L0;

  /* "tesserocr.pyx":1985
 *         return self._baseapi.MeanTextConf()
 * 
 *     def AllWordConfidences(self):             # <<<<<<<<<<<<<<
 *         """Return all word confidences (between 0 and 100) as a list.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.AllWordConfidences", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_confs);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2004
 *         return confs
 * 
 *     def MapWordConfidences(self):             # <<<<<<<<<<<<<<
 *         """Return list of word, confidence tuples"""
 *         return zip(self.GetUTF8Text().split(' '), self.AllWordConfidences())
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_99MapWordConfidences(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_98MapWordConfidences[] = "Return list of word, confidence tuples";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_99MapWordConfidences(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MapWordConfidences (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_98MapWordConfidences(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_98MapWordConfidences(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MapWordConfidences", 0);

  /* "tesserocr.pyx":2006
 *     def MapWordConfidences(self):
 *         """Return list of word, confidence tuples"""
 *         return zip(self.GetUTF8Text().split(' '), self.AllWordConfidences())             # <<<<<<<<<<<<<<
 * 
 *     def AdaptToWordStr(self, PageSegMode psm, cchar_t *word):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_GetUTF8Text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_split); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_AllWordConfidences); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (__pyx_t_4) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else {
    __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_zip, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2004
 *         return confs
 * 
 *     def MapWordConfidences(self):             # <<<<<<<<<<<<<<
 *         """Return list of word, confidence tuples"""
 *         return zip(self.GetUTF8Text().split(' '), self.AllWordConfidences())
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.MapWordConfidences", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2008
 *         return zip(self.GetUTF8Text().split(' '), self.AllWordConfidences())
 * 
 *     def AdaptToWordStr(self, PageSegMode psm, cchar_t *word):             # <<<<<<<<<<<<<<
 *         """Apply the given word to the adaptive classifier if possible.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_101AdaptToWordStr(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_100AdaptToWordStr[] = "Apply the given word to the adaptive classifier if possible.\n\n        Assumes that :meth:`SetImage` / :meth:`SetRectangle` have been used to set the image\n        to the given word.\n\n        Args:\n            psm (int): Should be :attr:`PSM.SINGLE_WORD` or\n                :attr:`PSM.CIRCLE_WORD`, as that will be used to control layout analysis.\n                The currently set PageSegMode is preserved.\n            word (str): The word must be SPACE-DELIMITED UTF-8 - l i k e t h i s , so it can\n                tell the boundaries of the graphemes.\n\n        Returns:\n            bool: ``False`` if adaption was not possible for some reason.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_101AdaptToWordStr(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum tesseract::PageSegMode __pyx_v_psm;
  __pyx_t_9tesseract_cchar_t *__pyx_v_word;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("AdaptToWordStr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_psm,&__pyx_n_s_word,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_psm)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_word)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AdaptToWordStr", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "AdaptToWordStr") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_psm = ((enum tesseract::PageSegMode)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageSegMode(values[0])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_word = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_word) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("AdaptToWordStr", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.AdaptToWordStr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_100AdaptToWordStr(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_psm, __pyx_v_word);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_100AdaptToWordStr(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, enum tesseract::PageSegMode __pyx_v_psm, __pyx_t_9tesseract_cchar_t *__pyx_v_word) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("AdaptToWordStr", 0);

  /* "tesserocr.pyx":2024
 *             bool: ``False`` if adaption was not possible for some reason.
 *         """
 *         return self._baseapi.AdaptToWordStr(psm, word)             # <<<<<<<<<<<<<<
 * 
 *     def Clear(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_baseapi.AdaptToWordStr(__pyx_v_psm, __pyx_v_word)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2024; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2008
 *         return zip(self.GetUTF8Text().split(' '), self.AllWordConfidences())
 * 
 *     def AdaptToWordStr(self, PageSegMode psm, cchar_t *word):             # <<<<<<<<<<<<<<
 *         """Apply the given word to the adaptive classifier if possible.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.AdaptToWordStr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2026
 *         return self._baseapi.AdaptToWordStr(psm, word)
 * 
 *     def Clear(self):             # <<<<<<<<<<<<<<
 *         """Free up recognition results and any stored image data, without actually
 *         freeing any recognition data that would be time-consuming to reload.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_103Clear(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_102Clear[] = "Free up recognition results and any stored image data, without actually\n        freeing any recognition data that would be time-consuming to reload.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_103Clear(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Clear (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_102Clear(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_102Clear(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Clear", 0);

  /* "tesserocr.pyx":2030
 *         freeing any recognition data that would be time-consuming to reload.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             self._baseapi.Clear()
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":2031
 *         """
 *         with nogil:
 *             self._destroy_pix()             # <<<<<<<<<<<<<<
 *             self._baseapi.Clear()
 * 
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_destroy_pix(__pyx_v_self);

        /* "tesserocr.pyx":2032
 *         with nogil:
 *             self._destroy_pix()
 *             self._baseapi.Clear()             # <<<<<<<<<<<<<<
 * 
 *     def End(self):
 */
        __pyx_v_self->_baseapi.Clear();
      }

      /* "tesserocr.pyx":2030
 *         freeing any recognition data that would be time-consuming to reload.
 *         """
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._destroy_pix()
 *             self._baseapi.Clear()
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":2026
 *         return self._baseapi.AdaptToWordStr(psm, word)
 * 
 *     def Clear(self):             # <<<<<<<<<<<<<<
 *         """Free up recognition results and any stored image data, without actually
 *         freeing any recognition data that would be time-consuming to reload.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2034
 *             self._baseapi.Clear()
 * 
 *     def End(self):             # <<<<<<<<<<<<<<
 *         """Close down tesseract and free up all memory."""
 *         with nogil:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_105End(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_104End[] = "Close down tesseract and free up all memory.";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_105End(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("End (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_104End(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_104End(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("End", 0);

  /* "tesserocr.pyx":2036
 *     def End(self):
 *         """Close down tesseract and free up all memory."""
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._end_api()
 * 
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":2037
 *         """Close down tesseract and free up all memory."""
 *         with nogil:
 *             self._end_api()             # <<<<<<<<<<<<<<
 * 
 *     def IsValidCharacter(self, cchar_t *character):
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_end_api(__pyx_v_self);
      }

      /* "tesserocr.pyx":2036
 *     def End(self):
 *         """Close down tesseract and free up all memory."""
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._end_api()
 * 
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":2034
 *             self._baseapi.Clear()
 * 
 *     def End(self):             # <<<<<<<<<<<<<<
 *         """Close down tesseract and free up all memory."""
 *         with nogil:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2039
 *             self._end_api()
 * 
 *     def IsValidCharacter(self, cchar_t *character):             # <<<<<<<<<<<<<<
 *         """Return True if character is defined in the UniCharset.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_107IsValidCharacter(PyObject *__pyx_v_self, PyObject *__pyx_arg_character); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_106IsValidCharacter[] = "Return True if character is defined in the UniCharset.\n\n        Args:\n            character: UTF-8 encoded character.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_107IsValidCharacter(PyObject *__pyx_v_self, PyObject *__pyx_arg_character) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_character;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("IsValidCharacter (wrapper)", 0);
  assert(__pyx_arg_character); {
    __pyx_v_character = __Pyx_PyObject_AsString(__pyx_arg_character); if (unlikely((!__pyx_v_character) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.IsValidCharacter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_106IsValidCharacter(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((__pyx_t_9tesseract_cchar_t *)__pyx_v_character));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_106IsValidCharacter(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, __pyx_t_9tesseract_cchar_t *__pyx_v_character) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("IsValidCharacter", 0);

  /* "tesserocr.pyx":2045
 *             character: UTF-8 encoded character.
 *         """
 *         return self._baseapi.IsValidCharacter(character)             # <<<<<<<<<<<<<<
 * 
 *     def GetTextDirection(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_baseapi.IsValidCharacter(__pyx_v_character)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2039
 *             self._end_api()
 * 
 *     def IsValidCharacter(self, cchar_t *character):             # <<<<<<<<<<<<<<
 *         """Return True if character is defined in the UniCharset.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.IsValidCharacter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2047
 *         return self._baseapi.IsValidCharacter(character)
 * 
 *     def GetTextDirection(self):             # <<<<<<<<<<<<<<
 *         """Get text direction.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_109GetTextDirection(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_108GetTextDirection[] = "Get text direction.\n\n        Returns:\n            tuple: offset and slop\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_109GetTextDirection(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetTextDirection (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_108GetTextDirection(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_108GetTextDirection(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  int __pyx_v_out_offset;
  float __pyx_v_out_slope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetTextDirection", 0);

  /* "tesserocr.pyx":2056
 *             int out_offset
 *             float out_slope
 *         self._baseapi.GetTextDirection(&out_offset, &out_slope)             # <<<<<<<<<<<<<<
 *         return out_offset, out_slope
 * 
 */
  __pyx_v_self->_baseapi.GetTextDirection((&__pyx_v_out_offset), (&__pyx_v_out_slope));

  /* "tesserocr.pyx":2057
 *             float out_slope
 *         self._baseapi.GetTextDirection(&out_offset, &out_slope)
 *         return out_offset, out_slope             # <<<<<<<<<<<<<<
 * 
 *     def GetUnichar(self, int unichar_id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_out_offset); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2057; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_out_slope); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2057; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2057; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2047
 *         return self._baseapi.IsValidCharacter(character)
 * 
 *     def GetTextDirection(self):             # <<<<<<<<<<<<<<
 *         """Get text direction.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetTextDirection", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2059
 *         return out_offset, out_slope
 * 
 *     def GetUnichar(self, int unichar_id):             # <<<<<<<<<<<<<<
 *         """Return the string form of the specified unichar.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_111GetUnichar(PyObject *__pyx_v_self, PyObject *__pyx_arg_unichar_id); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_110GetUnichar[] = "Return the string form of the specified unichar.\n\n        Args:\n            unichar_id (int): unichar id.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_111GetUnichar(PyObject *__pyx_v_self, PyObject *__pyx_arg_unichar_id) {
  int __pyx_v_unichar_id;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("GetUnichar (wrapper)", 0);
  assert(__pyx_arg_unichar_id); {
    __pyx_v_unichar_id = __Pyx_PyInt_As_int(__pyx_arg_unichar_id); if (unlikely((__pyx_v_unichar_id == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2059; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetUnichar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_110GetUnichar(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((int)__pyx_v_unichar_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_110GetUnichar(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, int __pyx_v_unichar_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("GetUnichar", 0);

  /* "tesserocr.pyx":2065
 *             unichar_id (int): unichar id.
 *         """
 *         return self._baseapi.GetUnichar(unichar_id)             # <<<<<<<<<<<<<<
 * 
 *     def oem(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_self->_baseapi.GetUnichar(__pyx_v_unichar_id)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2059
 *         return out_offset, out_slope
 * 
 *     def GetUnichar(self, int unichar_id):             # <<<<<<<<<<<<<<
 *         """Return the string form of the specified unichar.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.GetUnichar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2067
 *         return self._baseapi.GetUnichar(unichar_id)
 * 
 *     def oem(self):             # <<<<<<<<<<<<<<
 *         """Return the last set OCR engine mode."""
 *         return self._baseapi.oem()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_113oem(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_112oem[] = "Return the last set OCR engine mode.";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_113oem(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("oem (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_112oem(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_112oem(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("oem", 0);

  /* "tesserocr.pyx":2069
 *     def oem(self):
 *         """Return the last set OCR engine mode."""
 *         return self._baseapi.oem()             # <<<<<<<<<<<<<<
 * 
 *     def set_min_orientation_margin(self, double margin):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_enum__tesseract_3a__3a_OcrEngineMode(__pyx_v_self->_baseapi.oem()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2067
 *         return self._baseapi.GetUnichar(unichar_id)
 * 
 *     def oem(self):             # <<<<<<<<<<<<<<
 *         """Return the last set OCR engine mode."""
 *         return self._baseapi.oem()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.oem", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2071
 *         return self._baseapi.oem()
 * 
 *     def set_min_orientation_margin(self, double margin):             # <<<<<<<<<<<<<<
 *         """Set minimum orientation margin.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_115set_min_orientation_margin(PyObject *__pyx_v_self, PyObject *__pyx_arg_margin); /*proto*/
static char __pyx_doc_9tesserocr_13PyTessBaseAPI_114set_min_orientation_margin[] = "Set minimum orientation margin.\n\n        Args:\n            margin (float): orientation margin.\n        ";
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_115set_min_orientation_margin(PyObject *__pyx_v_self, PyObject *__pyx_arg_margin) {
  double __pyx_v_margin;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_min_orientation_margin (wrapper)", 0);
  assert(__pyx_arg_margin); {
    __pyx_v_margin = __pyx_PyFloat_AsDouble(__pyx_arg_margin); if (unlikely((__pyx_v_margin == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.set_min_orientation_margin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_114set_min_orientation_margin(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), ((double)__pyx_v_margin));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_114set_min_orientation_margin(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, double __pyx_v_margin) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_min_orientation_margin", 0);

  /* "tesserocr.pyx":2077
 *             margin (float): orientation margin.
 *         """
 *         self._baseapi.set_min_orientation_margin(margin)             # <<<<<<<<<<<<<<
 * 
 *     def __enter__(self):
 */
  __pyx_v_self->_baseapi.set_min_orientation_margin(__pyx_v_margin);

  /* "tesserocr.pyx":2071
 *         return self._baseapi.oem()
 * 
 *     def set_min_orientation_margin(self, double margin):             # <<<<<<<<<<<<<<
 *         """Set minimum orientation margin.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2079
 *         self._baseapi.set_min_orientation_margin(margin)
 * 
 *     def __enter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_117__enter__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_117__enter__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__enter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_116__enter__(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_116__enter__(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__enter__", 0);

  /* "tesserocr.pyx":2080
 * 
 *     def __enter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __exit__(self, exc_tp, exc_val, exc_tb):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "tesserocr.pyx":2079
 *         self._baseapi.set_min_orientation_margin(margin)
 * 
 *     def __enter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2082
 *         return self
 * 
 *     def __exit__(self, exc_tp, exc_val, exc_tb):             # <<<<<<<<<<<<<<
 *         with nogil:
 *             self._end_api()
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_119__exit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyObject *__pyx_pw_9tesserocr_13PyTessBaseAPI_119__exit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_exc_tp = 0;
  CYTHON_UNUSED PyObject *__pyx_v_exc_val = 0;
  CYTHON_UNUSED PyObject *__pyx_v_exc_tb = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__exit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_exc_tp,&__pyx_n_s_exc_val,&__pyx_n_s_exc_tb,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_exc_tp)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_exc_val)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2082; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_exc_tb)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2082; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__exit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2082; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_exc_tp = values[0];
    __pyx_v_exc_val = values[1];
    __pyx_v_exc_tb = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2082; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.PyTessBaseAPI.__exit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_13PyTessBaseAPI_118__exit__(((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)__pyx_v_self), __pyx_v_exc_tp, __pyx_v_exc_val, __pyx_v_exc_tb);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_13PyTessBaseAPI_118__exit__(struct __pyx_obj_9tesserocr_PyTessBaseAPI *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_exc_tp, CYTHON_UNUSED PyObject *__pyx_v_exc_val, CYTHON_UNUSED PyObject *__pyx_v_exc_tb) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__exit__", 0);

  /* "tesserocr.pyx":2083
 * 
 *     def __exit__(self, exc_tp, exc_val, exc_tb):
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._end_api()
 *         return False
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":2084
 *     def __exit__(self, exc_tp, exc_val, exc_tb):
 *         with nogil:
 *             self._end_api()             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
        ((struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI *)__pyx_v_self->__pyx_vtab)->_end_api(__pyx_v_self);
      }

      /* "tesserocr.pyx":2083
 * 
 *     def __exit__(self, exc_tp, exc_val, exc_tb):
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self._end_api()
 *         return False
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":2085
 *         with nogil:
 *             self._end_api()
 *         return False             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "tesserocr.pyx":2082
 *         return self
 * 
 *     def __exit__(self, exc_tp, exc_val, exc_tb):             # <<<<<<<<<<<<<<
 *         with nogil:
 *             self._end_api()
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2088
 * 
 * 
 * cdef char *_image_to_text(Pix *pix, cchar_t *lang, const PageSegMode pagesegmode,             # <<<<<<<<<<<<<<
 *                           cchar_t *path) nogil:
 *     cdef:
 */

static char *__pyx_f_9tesserocr__image_to_text(struct Pix *__pyx_v_pix, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::PageSegMode const __pyx_v_pagesegmode, __pyx_t_9tesseract_cchar_t *__pyx_v_path) {
  tesseract::TessBaseAPI __pyx_v_baseapi;
  char *__pyx_v_text;
  char *__pyx_r;
  int __pyx_t_1;

  /* "tesserocr.pyx":2094
 *         char *text
 * 
 *     if baseapi.Init(path, lang) == -1:             # <<<<<<<<<<<<<<
 *         return NULL
 * 
 */
  __pyx_t_1 = ((__pyx_v_baseapi.Init(__pyx_v_path, __pyx_v_lang) == -1L) != 0);
  if (__pyx_t_1) {

    /* "tesserocr.pyx":2095
 * 
 *     if baseapi.Init(path, lang) == -1:
 *         return NULL             # <<<<<<<<<<<<<<
 * 
 *     baseapi.SetPageSegMode(pagesegmode)
 */
    __pyx_r = NULL;
    goto __pyx_L0;

    /* "tesserocr.pyx":2094
 *         char *text
 * 
 *     if baseapi.Init(path, lang) == -1:             # <<<<<<<<<<<<<<
 *         return NULL
 * 
 */
  }

  /* "tesserocr.pyx":2097
 *         return NULL
 * 
 *     baseapi.SetPageSegMode(pagesegmode)             # <<<<<<<<<<<<<<
 *     baseapi.SetImage(pix)
 *     text = baseapi.GetUTF8Text()
 */
  __pyx_v_baseapi.SetPageSegMode(__pyx_v_pagesegmode);

  /* "tesserocr.pyx":2098
 * 
 *     baseapi.SetPageSegMode(pagesegmode)
 *     baseapi.SetImage(pix)             # <<<<<<<<<<<<<<
 *     text = baseapi.GetUTF8Text()
 *     pixDestroy(&pix)
 */
  __pyx_v_baseapi.SetImage(__pyx_v_pix);

  /* "tesserocr.pyx":2099
 *     baseapi.SetPageSegMode(pagesegmode)
 *     baseapi.SetImage(pix)
 *     text = baseapi.GetUTF8Text()             # <<<<<<<<<<<<<<
 *     pixDestroy(&pix)
 *     baseapi.End()
 */
  __pyx_v_text = __pyx_v_baseapi.GetUTF8Text();

  /* "tesserocr.pyx":2100
 *     baseapi.SetImage(pix)
 *     text = baseapi.GetUTF8Text()
 *     pixDestroy(&pix)             # <<<<<<<<<<<<<<
 *     baseapi.End()
 * 
 */
  pixDestroy((&__pyx_v_pix));

  /* "tesserocr.pyx":2101
 *     text = baseapi.GetUTF8Text()
 *     pixDestroy(&pix)
 *     baseapi.End()             # <<<<<<<<<<<<<<
 * 
 *     return text
 */
  __pyx_v_baseapi.End();

  /* "tesserocr.pyx":2103
 *     baseapi.End()
 * 
 *     return text             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_text;
  goto __pyx_L0;

  /* "tesserocr.pyx":2088
 * 
 * 
 * cdef char *_image_to_text(Pix *pix, cchar_t *lang, const PageSegMode pagesegmode,             # <<<<<<<<<<<<<<
 *                           cchar_t *path) nogil:
 *     cdef:
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "tesserocr.pyx":2106
 * 
 * 
 * def image_to_text(image, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                    cchar_t *path=_DEFAULT_PATH):
 *     """Recognize OCR text from an image object.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_7image_to_text(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_6image_to_text[] = "Recognize OCR text from an image object.\n\n    Args:\n        image (:class:`PIL.Image`): image to be processed.\n\n    Kwargs:\n        lang (str): An ISO 639-3 language string. Defaults to 'eng'.\n        psm (int): Page segmentation mode. Defaults to :attr:`PSM.AUTO`.\n            See :class:`PSM` for all available psm options.\n        path (str): The name of the parent directory of tessdata.\n            Must end in /.\n\n    Returns:\n        unicode: The text extracted from the image.\n\n    Raises:\n        :exc:`RuntimeError`: When image fails to be loaded or recognition fails.\n    ";
static PyMethodDef __pyx_mdef_9tesserocr_7image_to_text = {"image_to_text", (PyCFunction)__pyx_pw_9tesserocr_7image_to_text, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_6image_to_text};
static PyObject *__pyx_pw_9tesserocr_7image_to_text(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_image = 0;
  __pyx_t_9tesseract_cchar_t *__pyx_v_lang;
  enum tesseract::PageSegMode __pyx_v_psm;
  __pyx_t_9tesseract_cchar_t *__pyx_v_path;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("image_to_text (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_image,&__pyx_n_s_lang,&__pyx_n_s_psm,&__pyx_n_s_path,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_image)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lang);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_psm);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_path);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "image_to_text") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2106; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_image = values[0];
    if (values[1]) {
      __pyx_v_lang = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_lang) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2106; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_lang = __pyx_k__31;
    }
    if (values[2]) {
      __pyx_v_psm = ((enum tesseract::PageSegMode)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageSegMode(values[2])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2106; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_psm = __pyx_k__32;
    }
    if (values[3]) {
      __pyx_v_path = __Pyx_PyObject_AsString(values[3]); if (unlikely((!__pyx_v_path) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_path = __pyx_k__33;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("image_to_text", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2106; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.image_to_text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_6image_to_text(__pyx_self, __pyx_v_image, __pyx_v_lang, __pyx_v_psm, __pyx_v_path);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_6image_to_text(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_image, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::PageSegMode __pyx_v_psm, __pyx_t_9tesseract_cchar_t *__pyx_v_path) {
  struct Pix *__pyx_v_pix;
  __pyx_t_9tesseract_cuchar_t *__pyx_v_buff;
  size_t __pyx_v_size;
  char *__pyx_v_text;
  PyObject *__pyx_v_raw = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __pyx_t_9tesseract_cuchar_t *__pyx_t_2;
  Py_ssize_t __pyx_t_3;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("image_to_text", 0);

  /* "tesserocr.pyx":2133
 *         str raw
 * 
 *     raw = _image_buffer(image)             # <<<<<<<<<<<<<<
 *     buff = raw
 *     size = len(raw)
 */
  __pyx_t_1 = __pyx_f_9tesserocr__image_buffer(__pyx_v_image); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_raw = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":2134
 * 
 *     raw = _image_buffer(image)
 *     buff = raw             # <<<<<<<<<<<<<<
 *     size = len(raw)
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_AsUString(__pyx_v_raw); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_buff = __pyx_t_2;

  /* "tesserocr.pyx":2135
 *     raw = _image_buffer(image)
 *     buff = raw
 *     size = len(raw)             # <<<<<<<<<<<<<<
 * 
 *     with nogil:
 */
  __pyx_t_3 = PyObject_Length(__pyx_v_raw); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_size = __pyx_t_3;

  /* "tesserocr.pyx":2137
 *     size = len(raw)
 * 
 *     with nogil:             # <<<<<<<<<<<<<<
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":2138
 * 
 *     with nogil:
 *         pix = pixReadMemBmp(buff, size)             # <<<<<<<<<<<<<<
 *         if pix == NULL:
 *             with gil:
 */
        __pyx_v_pix = pixReadMemBmp(__pyx_v_buff, __pyx_v_size);

        /* "tesserocr.pyx":2139
 *     with nogil:
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')
 */
        __pyx_t_4 = ((__pyx_v_pix == NULL) != 0);
        if (__pyx_t_4) {

          /* "tesserocr.pyx":2140
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:
 *             with gil:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":2141
 *         if pix == NULL:
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')             # <<<<<<<<<<<<<<
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:
 */
                __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__34, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2141; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_1);
                __Pyx_Raise(__pyx_t_1, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2141; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":2140
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:
 *             with gil:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":2139
 *     with nogil:
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')
 */
        }

        /* "tesserocr.pyx":2142
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)             # <<<<<<<<<<<<<<
 *         if text == NULL:
 *             with gil:
 */
        __pyx_v_text = __pyx_f_9tesserocr__image_to_text(__pyx_v_pix, __pyx_v_lang, __pyx_v_psm, __pyx_v_path);

        /* "tesserocr.pyx":2143
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:             # <<<<<<<<<<<<<<
 *             with gil:
 *                 raise RuntimeError('Failed recognize picture')
 */
        __pyx_t_4 = ((__pyx_v_text == NULL) != 0);
        if (__pyx_t_4) {

          /* "tesserocr.pyx":2144
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:
 *             with gil:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError('Failed recognize picture')
 * 
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":2145
 *         if text == NULL:
 *             with gil:
 *                 raise RuntimeError('Failed recognize picture')             # <<<<<<<<<<<<<<
 * 
 *     return _free_str(text)
 */
                __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__35, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2145; __pyx_clineno = __LINE__; goto __pyx_L12_error;}
                __Pyx_GOTREF(__pyx_t_1);
                __Pyx_Raise(__pyx_t_1, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2145; __pyx_clineno = __LINE__; goto __pyx_L12_error;}
              }

              /* "tesserocr.pyx":2144
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:
 *             with gil:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError('Failed recognize picture')
 * 
 */
              /*finally:*/ {
                __pyx_L12_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":2143
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:             # <<<<<<<<<<<<<<
 *             with gil:
 *                 raise RuntimeError('Failed recognize picture')
 */
        }
      }

      /* "tesserocr.pyx":2137
 *     size = len(raw)
 * 
 *     with nogil:             # <<<<<<<<<<<<<<
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":2147
 *                 raise RuntimeError('Failed recognize picture')
 * 
 *     return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2106
 * 
 * 
 * def image_to_text(image, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                    cchar_t *path=_DEFAULT_PATH):
 *     """Recognize OCR text from an image object.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("tesserocr.image_to_text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_raw);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2150
 * 
 * 
 * def file_to_text(cchar_t *filename, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                  cchar_t *path=_DEFAULT_PATH):
 *     """Extract OCR text from an image file.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_9file_to_text(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_8file_to_text[] = "Extract OCR text from an image file.\n\n    Args:\n        filename (str): Image file relative or absolute path.\n\n    Kwargs:\n        lang (str): An ISO 639-3 language string. Defaults to 'eng'\n        psm (int): Page segmentation mode. Defaults to :attr:`PSM.AUTO`\n            See :class:`PSM` for all available psm options.\n        path (str): The name of the parent directory of tessdata.\n            Must end in /.\n\n    Returns:\n        unicode: The text extracted from the image.\n\n    Raises:\n        :exc:`RuntimeError`: When image fails to be loaded or recognition fails.\n    ";
static PyMethodDef __pyx_mdef_9tesserocr_9file_to_text = {"file_to_text", (PyCFunction)__pyx_pw_9tesserocr_9file_to_text, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_8file_to_text};
static PyObject *__pyx_pw_9tesserocr_9file_to_text(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_filename;
  __pyx_t_9tesseract_cchar_t *__pyx_v_lang;
  enum tesseract::PageSegMode __pyx_v_psm;
  __pyx_t_9tesseract_cchar_t *__pyx_v_path;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("file_to_text (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_filename,&__pyx_n_s_lang,&__pyx_n_s_psm,&__pyx_n_s_path,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_filename)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lang);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_psm);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_path);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "file_to_text") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_filename = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_filename) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[1]) {
      __pyx_v_lang = __Pyx_PyObject_AsString(values[1]); if (unlikely((!__pyx_v_lang) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_lang = __pyx_k__36;
    }
    if (values[2]) {
      __pyx_v_psm = ((enum tesseract::PageSegMode)__Pyx_PyInt_As_enum__tesseract_3a__3a_PageSegMode(values[2])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_psm = __pyx_k__37;
    }
    if (values[3]) {
      __pyx_v_path = __Pyx_PyObject_AsString(values[3]); if (unlikely((!__pyx_v_path) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2151; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_path = __pyx_k__38;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("file_to_text", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.file_to_text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_8file_to_text(__pyx_self, __pyx_v_filename, __pyx_v_lang, __pyx_v_psm, __pyx_v_path);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_8file_to_text(CYTHON_UNUSED PyObject *__pyx_self, __pyx_t_9tesseract_cchar_t *__pyx_v_filename, __pyx_t_9tesseract_cchar_t *__pyx_v_lang, enum tesseract::PageSegMode __pyx_v_psm, __pyx_t_9tesseract_cchar_t *__pyx_v_path) {
  struct Pix *__pyx_v_pix;
  char *__pyx_v_text;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("file_to_text", 0);

  /* "tesserocr.pyx":2174
 *         char *text
 * 
 *     with nogil:             # <<<<<<<<<<<<<<
 *         pix = pixRead(filename)
 *         if pix == NULL:
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "tesserocr.pyx":2175
 * 
 *     with nogil:
 *         pix = pixRead(filename)             # <<<<<<<<<<<<<<
 *         if pix == NULL:
 *             with gil:
 */
        __pyx_v_pix = pixRead(__pyx_v_filename);

        /* "tesserocr.pyx":2176
 *     with nogil:
 *         pix = pixRead(filename)
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')
 */
        __pyx_t_1 = ((__pyx_v_pix == NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":2177
 *         pix = pixRead(filename)
 *         if pix == NULL:
 *             with gil:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":2178
 *         if pix == NULL:
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')             # <<<<<<<<<<<<<<
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__39, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2178; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2178; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
              }

              /* "tesserocr.pyx":2177
 *         pix = pixRead(filename)
 *         if pix == NULL:
 *             with gil:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)
 */
              /*finally:*/ {
                __pyx_L8_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":2176
 *     with nogil:
 *         pix = pixRead(filename)
 *         if pix == NULL:             # <<<<<<<<<<<<<<
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')
 */
        }

        /* "tesserocr.pyx":2179
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)             # <<<<<<<<<<<<<<
 *         if text == NULL:
 *             with gil:
 */
        __pyx_v_text = __pyx_f_9tesserocr__image_to_text(__pyx_v_pix, __pyx_v_lang, __pyx_v_psm, __pyx_v_path);

        /* "tesserocr.pyx":2180
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:             # <<<<<<<<<<<<<<
 *             with gil:
 *                 raise RuntimeError('Failed recognize picture')
 */
        __pyx_t_1 = ((__pyx_v_text == NULL) != 0);
        if (__pyx_t_1) {

          /* "tesserocr.pyx":2181
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:
 *             with gil:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError('Failed recognize picture')
 * 
 */
          {
              #ifdef WITH_THREAD
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
              #endif
              /*try:*/ {

                /* "tesserocr.pyx":2182
 *         if text == NULL:
 *             with gil:
 *                 raise RuntimeError('Failed recognize picture')             # <<<<<<<<<<<<<<
 * 
 *     return _free_str(text)
 */
                __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__40, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2182; __pyx_clineno = __LINE__; goto __pyx_L12_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_Raise(__pyx_t_2, 0, 0, 0);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2182; __pyx_clineno = __LINE__; goto __pyx_L12_error;}
              }

              /* "tesserocr.pyx":2181
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:
 *             with gil:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError('Failed recognize picture')
 * 
 */
              /*finally:*/ {
                __pyx_L12_error: {
                  #ifdef WITH_THREAD
                  PyGILState_Release(__pyx_gilstate_save);
                  #endif
                  goto __pyx_L4_error;
                }
              }
          }

          /* "tesserocr.pyx":2180
 *                 raise RuntimeError('Failed to read picture')
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:             # <<<<<<<<<<<<<<
 *             with gil:
 *                 raise RuntimeError('Failed recognize picture')
 */
        }
      }

      /* "tesserocr.pyx":2174
 *         char *text
 * 
 *     with nogil:             # <<<<<<<<<<<<<<
 *         pix = pixRead(filename)
 *         if pix == NULL:
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "tesserocr.pyx":2184
 *                 raise RuntimeError('Failed recognize picture')
 * 
 *     return _free_str(text)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_f_9tesserocr__free_str(__pyx_v_text); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2150
 * 
 * 
 * def file_to_text(cchar_t *filename, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                  cchar_t *path=_DEFAULT_PATH):
 *     """Extract OCR text from an image file.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("tesserocr.file_to_text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2187
 * 
 * 
 * def tesseract_version():             # <<<<<<<<<<<<<<
 *     """Return tesseract-ocr and leptonica version info"""
 *     version_str = u"tesseract {}\n {}\n  {}"
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_11tesseract_version(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9tesserocr_10tesseract_version[] = "Return tesseract-ocr and leptonica version info";
static PyMethodDef __pyx_mdef_9tesserocr_11tesseract_version = {"tesseract_version", (PyCFunction)__pyx_pw_9tesserocr_11tesseract_version, METH_NOARGS, __pyx_doc_9tesserocr_10tesseract_version};
static PyObject *__pyx_pw_9tesserocr_11tesseract_version(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tesseract_version (wrapper)", 0);
  __pyx_r = __pyx_pf_9tesserocr_10tesseract_version(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_10tesseract_version(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_v_version_str = NULL;
  __pyx_t_9tesseract_cchar_t *__pyx_v_tess_v;
  PyObject *__pyx_v_lept_v = NULL;
  PyObject *__pyx_v_libs_v = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tesseract_version", 0);

  /* "tesserocr.pyx":2189
 * def tesseract_version():
 *     """Return tesseract-ocr and leptonica version info"""
 *     version_str = u"tesseract {}\n {}\n  {}"             # <<<<<<<<<<<<<<
 *     tess_v = TessBaseAPI.Version()
 *     lept_v = _free_str(getLeptonicaVersion())
 */
  __Pyx_INCREF(__pyx_kp_u_tesseract);
  __pyx_v_version_str = __pyx_kp_u_tesseract;

  /* "tesserocr.pyx":2190
 *     """Return tesseract-ocr and leptonica version info"""
 *     version_str = u"tesseract {}\n {}\n  {}"
 *     tess_v = TessBaseAPI.Version()             # <<<<<<<<<<<<<<
 *     lept_v = _free_str(getLeptonicaVersion())
 *     libs_v = _free_str(getImagelibVersions())
 */
  __pyx_v_tess_v = tesseract::TessBaseAPI::Version();

  /* "tesserocr.pyx":2191
 *     version_str = u"tesseract {}\n {}\n  {}"
 *     tess_v = TessBaseAPI.Version()
 *     lept_v = _free_str(getLeptonicaVersion())             # <<<<<<<<<<<<<<
 *     libs_v = _free_str(getImagelibVersions())
 *     return version_str.format(tess_v, lept_v, libs_v)
 */
  __pyx_t_1 = __pyx_f_9tesserocr__free_str(getLeptonicaVersion()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_lept_v = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":2192
 *     tess_v = TessBaseAPI.Version()
 *     lept_v = _free_str(getLeptonicaVersion())
 *     libs_v = _free_str(getImagelibVersions())             # <<<<<<<<<<<<<<
 *     return version_str.format(tess_v, lept_v, libs_v)
 * 
 */
  __pyx_t_1 = __pyx_f_9tesserocr__free_str(getImagelibVersions()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_libs_v = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":2193
 *     lept_v = _free_str(getLeptonicaVersion())
 *     libs_v = _free_str(getImagelibVersions())
 *     return version_str.format(tess_v, lept_v, libs_v)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_version_str, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_tess_v); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_5 = 1;
    }
  }
  __pyx_t_6 = PyTuple_New(3+__pyx_t_5); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  if (__pyx_t_4) {
    __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
  }
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_t_3);
  __Pyx_INCREF(__pyx_v_lept_v);
  __Pyx_GIVEREF(__pyx_v_lept_v);
  PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_lept_v);
  __Pyx_INCREF(__pyx_v_libs_v);
  __Pyx_GIVEREF(__pyx_v_libs_v);
  PyTuple_SET_ITEM(__pyx_t_6, 2+__pyx_t_5, __pyx_v_libs_v);
  __pyx_t_3 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2187
 * 
 * 
 * def tesseract_version():             # <<<<<<<<<<<<<<
 *     """Return tesseract-ocr and leptonica version info"""
 *     version_str = u"tesseract {}\n {}\n  {}"
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("tesserocr.tesseract_version", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_version_str);
  __Pyx_XDECREF(__pyx_v_lept_v);
  __Pyx_XDECREF(__pyx_v_libs_v);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "tesserocr.pyx":2196
 * 
 * 
 * def get_languages(cchar_t *path=_DEFAULT_PATH):             # <<<<<<<<<<<<<<
 *     """Return available languages in the given path.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9tesserocr_13get_languages(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9tesserocr_12get_languages[] = "Return available languages in the given path.\n\n    Args:\n        path (str): The name of the parent directory of tessdata.\n            Must end in /. Default tesseract-ocr datapath is used\n            if no path is provided.\n\n    Retruns\n        tuple: Tuple with two elements:\n            - path (str): tessdata parent directory path\n            - languages (list): list of available languages as ISO 639-3 strings.\n    ";
static PyMethodDef __pyx_mdef_9tesserocr_13get_languages = {"get_languages", (PyCFunction)__pyx_pw_9tesserocr_13get_languages, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_12get_languages};
static PyObject *__pyx_pw_9tesserocr_13get_languages(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_9tesseract_cchar_t *__pyx_v_path;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_languages (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_path,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_path);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_languages") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2196; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_path = __Pyx_PyObject_AsString(values[0]); if (unlikely((!__pyx_v_path) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2196; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_path = __pyx_k__41;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get_languages", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2196; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("tesserocr.get_languages", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9tesserocr_12get_languages(__pyx_self, __pyx_v_path);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9tesserocr_12get_languages(CYTHON_UNUSED PyObject *__pyx_self, __pyx_t_9tesseract_cchar_t *__pyx_v_path) {
  tesseract::TessBaseAPI __pyx_v_baseapi;
  GenericVector<STRING>  __pyx_v_v;
  int __pyx_v_i;
  PyObject *__pyx_v_langs = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get_languages", 0);

  /* "tesserocr.pyx":2213
 *         GenericVector[STRING] v
 *         int i
 *     baseapi.Init(path, NULL)             # <<<<<<<<<<<<<<
 *     path = baseapi.GetDatapath()
 *     baseapi.GetAvailableLanguagesAsVector(&v)
 */
  __pyx_v_baseapi.Init(__pyx_v_path, NULL);

  /* "tesserocr.pyx":2214
 *         int i
 *     baseapi.Init(path, NULL)
 *     path = baseapi.GetDatapath()             # <<<<<<<<<<<<<<
 *     baseapi.GetAvailableLanguagesAsVector(&v)
 *     langs = [v[i].string() for i in xrange(v.size())]
 */
  __pyx_v_path = __pyx_v_baseapi.GetDatapath();

  /* "tesserocr.pyx":2215
 *     baseapi.Init(path, NULL)
 *     path = baseapi.GetDatapath()
 *     baseapi.GetAvailableLanguagesAsVector(&v)             # <<<<<<<<<<<<<<
 *     langs = [v[i].string() for i in xrange(v.size())]
 *     baseapi.End()
 */
  __pyx_v_baseapi.GetAvailableLanguagesAsVector((&__pyx_v_v));

  /* "tesserocr.pyx":2216
 *     path = baseapi.GetDatapath()
 *     baseapi.GetAvailableLanguagesAsVector(&v)
 *     langs = [v[i].string() for i in xrange(v.size())]             # <<<<<<<<<<<<<<
 *     baseapi.End()
 *     return path, langs
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_v_v.size();
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
    __pyx_v_i = __pyx_t_3;
    __pyx_t_4 = __Pyx_PyUnicode_FromString((__pyx_v_v[__pyx_v_i]).string()); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_4))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __pyx_v_langs = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "tesserocr.pyx":2217
 *     baseapi.GetAvailableLanguagesAsVector(&v)
 *     langs = [v[i].string() for i in xrange(v.size())]
 *     baseapi.End()             # <<<<<<<<<<<<<<
 *     return path, langs
 */
  __pyx_v_baseapi.End();

  /* "tesserocr.pyx":2218
 *     langs = [v[i].string() for i in xrange(v.size())]
 *     baseapi.End()
 *     return path, langs             # <<<<<<<<<<<<<<
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_path); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
  __Pyx_INCREF(__pyx_v_langs);
  __Pyx_GIVEREF(__pyx_v_langs);
  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_langs);
  __pyx_t_1 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "tesserocr.pyx":2196
 * 
 * 
 * def get_languages(cchar_t *path=_DEFAULT_PATH):             # <<<<<<<<<<<<<<
 *     """Return available languages in the given path.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("tesserocr.get_languages", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_langs);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_tp_new_9tesserocr__Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  return o;
}

static void __pyx_tp_dealloc_9tesserocr__Enum(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9tesserocr__Enum[] = {
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9tesserocr__Enum = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr._Enum", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr__Enum), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9tesserocr__Enum, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr__Enum, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_OEM(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_OEM = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.OEM", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_OEM), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "An enum that defines avaialble OCR engine modes.", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_OEM, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_PSM(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_PSM = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.PSM", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_PSM), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "An enum that defines all available page segmentation modes.\n\n    Attributes:\n        OSD_ONLY: Orientation and script detection only.\n        AUTO_OSD: Automatic page segmentation with orientation and script detection. (OSD)\n        AUTO_ONLY: Automatic page segmentation, but no OSD, or OCR.\n        AUTO: Fully automatic page segmentation, but no OSD. (:mod:`tesserocr` default)\n        SINGLE_COLUMN: Assume a single column of text of variable sizes.\n        SINGLE_BLOCK_VERT_TEXT: Assume a single uniform block of vertically aligned text.\n        SINGLE_BLOCK: Assume a single uniform block of text.\n        SINGLE_LINE: Treat the image as a single text line.\n        SINGLE_WORD: Treat the image as a single word.\n        CIRCLE_WORD: Treat the image as a single word in a circle.\n        SINGLE_CHAR: Treat the image as a single character.\n        SPARSE_TEXT: Find as much text as possible in no particular order.\n        SPARSE_TEXT_OSD: Sparse text with orientation and script det.\n        RAW_LINE: Treat the image as a single text line, bypassing hacks that are Tesseract-specific.\n        COUNT: Number of enum entries.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_PSM, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_RIL(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_RIL = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.RIL", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_RIL), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "An enum that defines available Page Iterator levels.\n\n    Attributes:\n        BLOCK: of text/image/separator line.\n        PARAr: within a block.\n        TEXTLINE: within a paragraph.\n        WORD: within a textline.\n        SYMBOL: character within a word.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_RIL, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_PT(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_PT = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.PT", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_PT), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "An enum the defines avaialbe Poly Block types.\n\n    Attributes:\n        UNKNOWN: Type is not yet known. Keep as the first element.\n        FLOWING_TEXT: Text that lives inside a column.\n        HEADING_TEXT: Text that spans more than one column.\n        PULLOUT_TEXT: Text that is in a cross-column pull-out region.\n        EQUATION: Partition belonging to an equation region.\n        INLINE_EQUATION: Partition has inline equation.\n        TABLE: Partition belonging to a table region.\n        VERTICAL_TEXT: Text-line runs vertically.\n        CAPTION_TEXT: Text that belongs to an image.\n        FLOWING_IMAGE: Image that lives inside a column.\n        HEADING_IMAGE: Image that spans more than one column.\n        PULLOUT_IMAGE: Image that is in a cross-column pull-out region.\n        HORZ_LINE: Horizontal Line.\n        VERT_LINE: Vertical Line.\n        NOISE: Lies outside of any column.\n        COUNT: Count\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_PT, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_Orientation(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_Orientation = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.Orientation", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_Orientation), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Enum for orientation options.", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_Orientation, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_WritingDirection(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_WritingDirection = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.WritingDirection", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_WritingDirection), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Enum for writing direction options.", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_WritingDirection, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_TextlineOrder(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_TextlineOrder = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.TextlineOrder", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_TextlineOrder), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Enum for text line order options.", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_TextlineOrder, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_Justification(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_Justification = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.Justification", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_Justification), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Enum for justification options.", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_Justification, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_9tesserocr_DIR(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_9tesserocr__Enum(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static PyTypeObject __pyx_type_9tesserocr_DIR = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.DIR", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_DIR), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr__Enum, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Enum for strong text direction values.\n\n    Attributes:\n        NEUTRAL: Text contains only neutral characters.\n        LEFT_TO_RIGHT: Text contains no Right-to-Left characters.\n        RIGHT_TO_LEFT: Text contains no Left-to-Right characters.\n        MIX: Text contains a mixture of left-to-right and right-to-left characters.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_5_Enum_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_DIR, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9tesserocr_PyPageIterator __pyx_vtable_9tesserocr_PyPageIterator;

static PyObject *__pyx_tp_new_9tesserocr_PyPageIterator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9tesserocr_PyPageIterator *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9tesserocr_PyPageIterator *)o);
  p->__pyx_vtab = __pyx_vtabptr_9tesserocr_PyPageIterator;
  if (unlikely(__pyx_pw_9tesserocr_14PyPageIterator_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr_PyPageIterator(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_9tesserocr_14PyPageIterator_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9tesserocr_PyPageIterator[] = {
  {"Begin", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_7Begin, METH_NOARGS, __pyx_doc_9tesserocr_14PyPageIterator_6Begin},
  {"RestartParagraph", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_9RestartParagraph, METH_NOARGS, __pyx_doc_9tesserocr_14PyPageIterator_8RestartParagraph},
  {"IsWithinFirstTextlineOfParagraph", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_11IsWithinFirstTextlineOfParagraph, METH_NOARGS, __pyx_doc_9tesserocr_14PyPageIterator_10IsWithinFirstTextlineOfParagraph},
  {"RestartRow", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_13RestartRow, METH_NOARGS, __pyx_doc_9tesserocr_14PyPageIterator_12RestartRow},
  {"Next", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_15Next, METH_O, __pyx_doc_9tesserocr_14PyPageIterator_14Next},
  {"IsAtBeginningOf", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_17IsAtBeginningOf, METH_O, __pyx_doc_9tesserocr_14PyPageIterator_16IsAtBeginningOf},
  {"IsAtFinalElement", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_19IsAtFinalElement, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_14PyPageIterator_18IsAtFinalElement},
  {"SetBoundingBoxComponents", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_21SetBoundingBoxComponents, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_14PyPageIterator_20SetBoundingBoxComponents},
  {"BoundingBox", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_23BoundingBox, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_14PyPageIterator_22BoundingBox},
  {"BoundingBoxInternal", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_25BoundingBoxInternal, METH_O, __pyx_doc_9tesserocr_14PyPageIterator_24BoundingBoxInternal},
  {"Empty", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_27Empty, METH_O, __pyx_doc_9tesserocr_14PyPageIterator_26Empty},
  {"BlockType", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_29BlockType, METH_NOARGS, __pyx_doc_9tesserocr_14PyPageIterator_28BlockType},
  {"BlockPolygon", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_31BlockPolygon, METH_NOARGS, __pyx_doc_9tesserocr_14PyPageIterator_30BlockPolygon},
  {"GetBinaryImage", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_33GetBinaryImage, METH_O, __pyx_doc_9tesserocr_14PyPageIterator_32GetBinaryImage},
  {"GetImage", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_35GetImage, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_14PyPageIterator_34GetImage},
  {"Baseline", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_37Baseline, METH_O, __pyx_doc_9tesserocr_14PyPageIterator_36Baseline},
  {"Orientation", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_39Orientation, METH_NOARGS, __pyx_doc_9tesserocr_14PyPageIterator_38Orientation},
  {"ParagraphInfo", (PyCFunction)__pyx_pw_9tesserocr_14PyPageIterator_41ParagraphInfo, METH_NOARGS, __pyx_doc_9tesserocr_14PyPageIterator_40ParagraphInfo},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9tesserocr_PyPageIterator = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.PyPageIterator", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_PyPageIterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr_PyPageIterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Wrapper around Tesseract's ``PageIterator`` class.\n    Returned by :meth:`PyTessBaseAPI.AnalyseLayout`.\n\n    Instances of this class and its subclasses cannot be instantiated from Python.\n\n    Accessing data\n    ==============\n\n    Coordinate system:\n\n    Integer coordinates are at the cracks between the pixels.\n    The top-left corner of the top-left pixel in the image is at (0,0).\n    The bottom-right corner of the bottom-right pixel in the image is at\n    (width, height).\n\n    Every bounding box goes from the top-left of the top-left contained\n    pixel to the bottom-right of the bottom-right contained pixel, so\n    the bounding box of the single top-left pixel in the image is:\n    (0,0)->(1,1).\n\n    If an image rectangle has been set in the API, then returned coordinates\n    relate to the original (full) image, rather than the rectangle.\n\n    .. note::\n\n        You can iterate through the elements of a level using the :func:`iterate_level`\n        helper function:\n\n        >>> for e in iterate_level(api.AnalyseLayout(), RIL.WORD):\n            ...     word = e.GetUTF8Text()\n\n    .. warning::\n\n        This class points to data held within the :class:`PyTessBaseAPI`\n        instance, and therefore can only be used while the :class:`PyTessBaseAPI`\n        instance still exists and has not been subjected to a call of :meth:`Init`,\n        :meth:`SetImage`, :meth:`Recognize`, :meth:`Clear`, :meth:`End`,\n        or anything else that changes the internal `PAGE_RES`.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9tesserocr_PyPageIterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9tesserocr_14PyPageIterator_5__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_PyPageIterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9tesserocr_PyLTRResultIterator __pyx_vtable_9tesserocr_PyLTRResultIterator;

static PyObject *__pyx_tp_new_9tesserocr_PyLTRResultIterator(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9tesserocr_PyLTRResultIterator *p;
  PyObject *o = __pyx_tp_new_9tesserocr_PyPageIterator(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9tesserocr_PyLTRResultIterator *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_9tesserocr_PyPageIterator*)__pyx_vtabptr_9tesserocr_PyLTRResultIterator;
  if (unlikely(__pyx_pw_9tesserocr_19PyLTRResultIterator_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr_PyLTRResultIterator(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_9tesserocr_19PyLTRResultIterator_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  __pyx_tp_dealloc_9tesserocr_PyPageIterator(o);
}

static PyMethodDef __pyx_methods_9tesserocr_PyLTRResultIterator[] = {
  {"GetChoiceIterator", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_5GetChoiceIterator, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_4GetChoiceIterator},
  {"GetUTF8Text", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_7GetUTF8Text, METH_O, __pyx_doc_9tesserocr_19PyLTRResultIterator_6GetUTF8Text},
  {"SetLineSeparator", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_9SetLineSeparator, METH_O, __pyx_doc_9tesserocr_19PyLTRResultIterator_8SetLineSeparator},
  {"SetParagraphSeparator", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_11SetParagraphSeparator, METH_O, __pyx_doc_9tesserocr_19PyLTRResultIterator_10SetParagraphSeparator},
  {"Confidence", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_13Confidence, METH_O, __pyx_doc_9tesserocr_19PyLTRResultIterator_12Confidence},
  {"WordFontAttributes", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_15WordFontAttributes, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_14WordFontAttributes},
  {"WordRecognitionLanguage", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_17WordRecognitionLanguage, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_16WordRecognitionLanguage},
  {"WordDirection", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_19WordDirection, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_18WordDirection},
  {"WordIsFromDictionary", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_21WordIsFromDictionary, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_20WordIsFromDictionary},
  {"WordIsNumeric", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_23WordIsNumeric, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_22WordIsNumeric},
  {"HasBlamerInfo", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_25HasBlamerInfo, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_24HasBlamerInfo},
  {"GetBlamerDebug", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_27GetBlamerDebug, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_26GetBlamerDebug},
  {"GetBlamerMisadaptionDebug", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_29GetBlamerMisadaptionDebug, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_28GetBlamerMisadaptionDebug},
  {"HasTruthString", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_31HasTruthString, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_30HasTruthString},
  {"EquivalentToTruth", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_33EquivalentToTruth, METH_O, __pyx_doc_9tesserocr_19PyLTRResultIterator_32EquivalentToTruth},
  {"WordTruthUTF8Text", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_35WordTruthUTF8Text, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_34WordTruthUTF8Text},
  {"WordNormedUTF8Text", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_37WordNormedUTF8Text, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_36WordNormedUTF8Text},
  {"WordLattice", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_39WordLattice, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_38WordLattice},
  {"SymbolIsSuperscript", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_41SymbolIsSuperscript, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_40SymbolIsSuperscript},
  {"SymbolIsSubscript", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_43SymbolIsSubscript, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_42SymbolIsSubscript},
  {"SymbolIsDropcap", (PyCFunction)__pyx_pw_9tesserocr_19PyLTRResultIterator_45SymbolIsDropcap, METH_NOARGS, __pyx_doc_9tesserocr_19PyLTRResultIterator_44SymbolIsDropcap},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9tesserocr_PyLTRResultIterator = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.PyLTRResultIterator", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_PyLTRResultIterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr_PyLTRResultIterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9tesserocr_PyLTRResultIterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_14PyPageIterator_5__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_PyLTRResultIterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9tesserocr_PyResultIterator __pyx_vtable_9tesserocr_PyResultIterator;

static PyObject *__pyx_tp_new_9tesserocr_PyResultIterator(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9tesserocr_PyResultIterator *p;
  PyObject *o = __pyx_tp_new_9tesserocr_PyLTRResultIterator(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9tesserocr_PyResultIterator *)o);
  p->__pyx_base.__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_9tesserocr_PyPageIterator*)__pyx_vtabptr_9tesserocr_PyResultIterator;
  if (unlikely(__pyx_pw_9tesserocr_16PyResultIterator_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr_PyResultIterator(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_9tesserocr_16PyResultIterator_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  __pyx_tp_dealloc_9tesserocr_PyLTRResultIterator(o);
}

static PyMethodDef __pyx_methods_9tesserocr_PyResultIterator[] = {
  {"IsAtBeginningOf", (PyCFunction)__pyx_pw_9tesserocr_16PyResultIterator_5IsAtBeginningOf, METH_O, __pyx_doc_9tesserocr_16PyResultIterator_4IsAtBeginningOf},
  {"ParagraphIsLtr", (PyCFunction)__pyx_pw_9tesserocr_16PyResultIterator_7ParagraphIsLtr, METH_NOARGS, __pyx_doc_9tesserocr_16PyResultIterator_6ParagraphIsLtr},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9tesserocr_PyResultIterator = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.PyResultIterator", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_PyResultIterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr_PyResultIterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Wrapper around Tesseract's ``ResultIterator`` class.\n\n    See :class:`PyPageIterator` for more details.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9tesserocr_PyResultIterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9tesserocr_14PyPageIterator_5__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_PyResultIterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9tesserocr_PyChoiceIterator __pyx_vtable_9tesserocr_PyChoiceIterator;

static PyObject *__pyx_tp_new_9tesserocr_PyChoiceIterator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9tesserocr_PyChoiceIterator *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9tesserocr_PyChoiceIterator *)o);
  p->__pyx_vtab = __pyx_vtabptr_9tesserocr_PyChoiceIterator;
  if (unlikely(__pyx_pw_9tesserocr_16PyChoiceIterator_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr_PyChoiceIterator(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_9tesserocr_16PyChoiceIterator_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9tesserocr_PyChoiceIterator[] = {
  {"Next", (PyCFunction)__pyx_pw_9tesserocr_16PyChoiceIterator_9Next, METH_NOARGS, __pyx_doc_9tesserocr_16PyChoiceIterator_8Next},
  {"GetUTF8Text", (PyCFunction)__pyx_pw_9tesserocr_16PyChoiceIterator_11GetUTF8Text, METH_NOARGS, __pyx_doc_9tesserocr_16PyChoiceIterator_10GetUTF8Text},
  {"Confidence", (PyCFunction)__pyx_pw_9tesserocr_16PyChoiceIterator_13Confidence, METH_NOARGS, __pyx_doc_9tesserocr_16PyChoiceIterator_12Confidence},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9tesserocr_PyChoiceIterator = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.PyChoiceIterator", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_PyChoiceIterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr_PyChoiceIterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_9tesserocr_16PyChoiceIterator_7__iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9tesserocr_PyChoiceIterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9tesserocr_16PyChoiceIterator_5__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_PyChoiceIterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9tesserocr_PyTessBaseAPI __pyx_vtable_9tesserocr_PyTessBaseAPI;

static PyObject *__pyx_tp_new_9tesserocr_PyTessBaseAPI(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9tesserocr_PyTessBaseAPI *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9tesserocr_PyTessBaseAPI *)o);
  p->__pyx_vtab = __pyx_vtabptr_9tesserocr_PyTessBaseAPI;
  new((void*)&(p->_baseapi)) tesseract::TessBaseAPI();
  if (unlikely(__pyx_pw_9tesserocr_13PyTessBaseAPI_5__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr_PyTessBaseAPI(PyObject *o) {
  struct __pyx_obj_9tesserocr_PyTessBaseAPI *p = (struct __pyx_obj_9tesserocr_PyTessBaseAPI *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_9tesserocr_13PyTessBaseAPI_7__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  __Pyx_call_destructor(p->_baseapi);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9tesserocr_PyTessBaseAPI[] = {
  {"Version", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_1Version, METH_VARARGS|METH_KEYWORDS, 0},
  {"ClearPersistentCache", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_3ClearPersistentCache, METH_VARARGS|METH_KEYWORDS, 0},
  {"GetDatapath", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_9GetDatapath, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_8GetDatapath},
  {"SetOutputName", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_11SetOutputName, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_10SetOutputName},
  {"SetVariable", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_13SetVariable, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_12SetVariable},
  {"SetDebugVariable", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_15SetDebugVariable, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_14SetDebugVariable},
  {"GetIntVariable", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_17GetIntVariable, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_16GetIntVariable},
  {"GetBoolVariable", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_19GetBoolVariable, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_18GetBoolVariable},
  {"GetDoubleVariable", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_21GetDoubleVariable, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_20GetDoubleVariable},
  {"GetStringVariable", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_23GetStringVariable, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_22GetStringVariable},
  {"GetVariableAsString", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_25GetVariableAsString, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_24GetVariableAsString},
  {"InitFull", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_27InitFull, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_26InitFull},
  {"Init", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_29Init, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_28Init},
  {"GetInitLanguagesAsString", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_31GetInitLanguagesAsString, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_30GetInitLanguagesAsString},
  {"GetLoadedLanguages", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_33GetLoadedLanguages, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_32GetLoadedLanguages},
  {"GetAvailableLanguages", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_35GetAvailableLanguages, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_34GetAvailableLanguages},
  {"InitForAnalysePage", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_37InitForAnalysePage, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_36InitForAnalysePage},
  {"ReadConfigFile", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_39ReadConfigFile, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_38ReadConfigFile},
  {"SetPageSegMode", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_41SetPageSegMode, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_40SetPageSegMode},
  {"GetPageSegMode", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_43GetPageSegMode, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_42GetPageSegMode},
  {"TesseractRect", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_45TesseractRect, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_44TesseractRect},
  {"ClearAdaptiveClassifier", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_47ClearAdaptiveClassifier, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_46ClearAdaptiveClassifier},
  {"SetImageBytes", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_49SetImageBytes, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_48SetImageBytes},
  {"SetImage", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_51SetImage, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_50SetImage},
  {"SetImageFile", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_53SetImageFile, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_52SetImageFile},
  {"SetSourceResolution", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_55SetSourceResolution, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_54SetSourceResolution},
  {"SetRectangle", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_57SetRectangle, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_56SetRectangle},
  {"GetThresholdedImage", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_59GetThresholdedImage, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_58GetThresholdedImage},
  {"GetRegions", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_61GetRegions, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_60GetRegions},
  {"GetTextlines", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_63GetTextlines, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_62GetTextlines},
  {"GetStrips", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_65GetStrips, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_64GetStrips},
  {"GetWords", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_67GetWords, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_66GetWords},
  {"GetConnectedComponents", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_69GetConnectedComponents, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_68GetConnectedComponents},
  {"GetComponentImages", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_71GetComponentImages, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_70GetComponentImages},
  {"GetThresholdedImageScaleFactor", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_73GetThresholdedImageScaleFactor, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_72GetThresholdedImageScaleFactor},
  {"AnalyseLayout", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_75AnalyseLayout, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_74AnalyseLayout},
  {"Recognize", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_77Recognize, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_76Recognize},
  {"RecognizeForChopTest", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_79RecognizeForChopTest, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_78RecognizeForChopTest},
  {"ProcessPages", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_81ProcessPages, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_80ProcessPages},
  {"ProcessPage", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_83ProcessPage, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_82ProcessPage},
  {"GetIterator", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_85GetIterator, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_84GetIterator},
  {"GetUTF8Text", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_87GetUTF8Text, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_86GetUTF8Text},
  {"GetHOCRText", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_89GetHOCRText, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_88GetHOCRText},
  {"GetBoxText", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_91GetBoxText, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_90GetBoxText},
  {"GetUNLVText", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_93GetUNLVText, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_92GetUNLVText},
  {"MeanTextConf", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_95MeanTextConf, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_94MeanTextConf},
  {"AllWordConfidences", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_97AllWordConfidences, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_96AllWordConfidences},
  {"MapWordConfidences", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_99MapWordConfidences, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_98MapWordConfidences},
  {"AdaptToWordStr", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_101AdaptToWordStr, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9tesserocr_13PyTessBaseAPI_100AdaptToWordStr},
  {"Clear", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_103Clear, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_102Clear},
  {"End", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_105End, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_104End},
  {"IsValidCharacter", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_107IsValidCharacter, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_106IsValidCharacter},
  {"GetTextDirection", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_109GetTextDirection, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_108GetTextDirection},
  {"GetUnichar", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_111GetUnichar, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_110GetUnichar},
  {"oem", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_113oem, METH_NOARGS, __pyx_doc_9tesserocr_13PyTessBaseAPI_112oem},
  {"set_min_orientation_margin", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_115set_min_orientation_margin, METH_O, __pyx_doc_9tesserocr_13PyTessBaseAPI_114set_min_orientation_margin},
  {"__enter__", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_117__enter__, METH_NOARGS, 0},
  {"__exit__", (PyCFunction)__pyx_pw_9tesserocr_13PyTessBaseAPI_119__exit__, METH_VARARGS|METH_KEYWORDS, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9tesserocr_PyTessBaseAPI = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.PyTessBaseAPI", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr_PyTessBaseAPI), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr_PyTessBaseAPI, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Cython wrapper class around the C++ TessBaseAPI class.\n\n    Usage as a context manager:\n\n    >>> with PyTessBaseAPI(path='./', lang='eng') as tesseract:\n    ...     tesseract.SetImage(image)\n    ...     text = tesseract.GetUTF8Text()\n\n    Example with manual handling:\n\n    >>> tesseract = PyTessBaseAPI(path='./', lang='eng')\n    >>> try:\n    ...     tesseract.SetImage(image)\n    ...     text = tesseract.GetUTF8Text()\n    ... finally:\n    ...     tesseract.End()\n\n    Args:\n        path (str): The name of the parent directory of tessdata.\n            Must end in /.\n        lang (str): An ISO 639-3 language string. Defaults to 'eng'.\n            The language may be a string of the form [~]<lang>[+[~]<lang>]* indicating\n            that multiple languages are to be loaded. Eg hin+eng will load Hindi and\n            English. Languages may specify internally that they want to be loaded\n            with one or more other languages, so the ~ sign is available to override\n            that. Eg if hin were set to load eng by default, then hin+~eng would force\n            loading only hin. The number of loaded languages is limited only by\n            memory, with the caveat that loading additional languages will impact\n            both speed and accuracy, as there is more work to do to decide on the\n            applicable language, and there is more chance of hallucinating incorrect\n            words.\n        psm (int): Page segmentation mode. Defaults to :attr:`PSM.AUTO`.\n            See :class:`PSM` for avaialble psm values.\n        init (bool): If ``False``, :meth:`Init` will not be called and has to be called\n            after initialization.\n\n    Raises:\n        :exc:`RuntimeError`: If `init` is ``True`` and API initialization fails.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9tesserocr_PyTessBaseAPI, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr_PyTessBaseAPI, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list *__pyx_freelist_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list[8];
static int __pyx_freecount_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list = 0;

static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list)))) {
    o = (PyObject*)__pyx_freelist_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list[--__pyx_freecount_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list];
    memset(o, 0, sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list));
    (void) PyObject_INIT(o, t);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list(PyObject *o) {
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list)))) {
    __pyx_freelist_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list[__pyx_freecount_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list++] = ((struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static PyTypeObject __pyx_type_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.__pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *__pyx_freelist_9tesserocr___pyx_scope_struct_1_genexpr[8];
static int __pyx_freecount_9tesserocr___pyx_scope_struct_1_genexpr = 0;

static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_1_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9tesserocr___pyx_scope_struct_1_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9tesserocr___pyx_scope_struct_1_genexpr[--__pyx_freecount_9tesserocr___pyx_scope_struct_1_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_1_genexpr(PyObject *o) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9tesserocr___pyx_scope_struct_1_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr)))) {
    __pyx_freelist_9tesserocr___pyx_scope_struct_1_genexpr[__pyx_freecount_9tesserocr___pyx_scope_struct_1_genexpr++] = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9tesserocr___pyx_scope_struct_1_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject*)p->__pyx_outer_scope), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9tesserocr___pyx_scope_struct_1_genexpr(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr *)o;
  tmp = ((PyObject*)p->__pyx_outer_scope);
  p->__pyx_outer_scope = ((struct __pyx_obj_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9tesserocr___pyx_scope_struct_1_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.__pyx_scope_struct_1_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_1_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_1_genexpr, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9tesserocr___pyx_scope_struct_1_genexpr, /*tp_traverse*/
  __pyx_tp_clear_9tesserocr___pyx_scope_struct_1_genexpr, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr___pyx_scope_struct_1_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *__pyx_freelist_9tesserocr___pyx_scope_struct_2_BlockPolygon[8];
static int __pyx_freecount_9tesserocr___pyx_scope_struct_2_BlockPolygon = 0;

static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_2_BlockPolygon(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9tesserocr___pyx_scope_struct_2_BlockPolygon > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon)))) {
    o = (PyObject*)__pyx_freelist_9tesserocr___pyx_scope_struct_2_BlockPolygon[--__pyx_freecount_9tesserocr___pyx_scope_struct_2_BlockPolygon];
    memset(o, 0, sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon));
    (void) PyObject_INIT(o, t);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_2_BlockPolygon(PyObject *o) {
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9tesserocr___pyx_scope_struct_2_BlockPolygon < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon)))) {
    __pyx_freelist_9tesserocr___pyx_scope_struct_2_BlockPolygon[__pyx_freecount_9tesserocr___pyx_scope_struct_2_BlockPolygon++] = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static PyTypeObject __pyx_type_9tesserocr___pyx_scope_struct_2_BlockPolygon = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.__pyx_scope_struct_2_BlockPolygon", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_2_BlockPolygon, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr___pyx_scope_struct_2_BlockPolygon, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *__pyx_freelist_9tesserocr___pyx_scope_struct_3_genexpr[8];
static int __pyx_freecount_9tesserocr___pyx_scope_struct_3_genexpr = 0;

static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_3_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9tesserocr___pyx_scope_struct_3_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9tesserocr___pyx_scope_struct_3_genexpr[--__pyx_freecount_9tesserocr___pyx_scope_struct_3_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_3_genexpr(PyObject *o) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_x);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9tesserocr___pyx_scope_struct_3_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr)))) {
    __pyx_freelist_9tesserocr___pyx_scope_struct_3_genexpr[__pyx_freecount_9tesserocr___pyx_scope_struct_3_genexpr++] = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9tesserocr___pyx_scope_struct_3_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject*)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_x) {
    e = (*v)(p->__pyx_v_x, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9tesserocr___pyx_scope_struct_3_genexpr(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr *)o;
  tmp = ((PyObject*)p->__pyx_outer_scope);
  p->__pyx_outer_scope = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_x);
  p->__pyx_v_x = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9tesserocr___pyx_scope_struct_3_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.__pyx_scope_struct_3_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_3_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_3_genexpr, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9tesserocr___pyx_scope_struct_3_genexpr, /*tp_traverse*/
  __pyx_tp_clear_9tesserocr___pyx_scope_struct_3_genexpr, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr___pyx_scope_struct_3_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *__pyx_freelist_9tesserocr___pyx_scope_struct_4_genexpr[8];
static int __pyx_freecount_9tesserocr___pyx_scope_struct_4_genexpr = 0;

static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_4_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9tesserocr___pyx_scope_struct_4_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9tesserocr___pyx_scope_struct_4_genexpr[--__pyx_freecount_9tesserocr___pyx_scope_struct_4_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_4_genexpr(PyObject *o) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_y);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9tesserocr___pyx_scope_struct_4_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr)))) {
    __pyx_freelist_9tesserocr___pyx_scope_struct_4_genexpr[__pyx_freecount_9tesserocr___pyx_scope_struct_4_genexpr++] = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9tesserocr___pyx_scope_struct_4_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject*)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_y) {
    e = (*v)(p->__pyx_v_y, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9tesserocr___pyx_scope_struct_4_genexpr(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr *)o;
  tmp = ((PyObject*)p->__pyx_outer_scope);
  p->__pyx_outer_scope = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_2_BlockPolygon *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_y);
  p->__pyx_v_y = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9tesserocr___pyx_scope_struct_4_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.__pyx_scope_struct_4_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_4_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_4_genexpr, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9tesserocr___pyx_scope_struct_4_genexpr, /*tp_traverse*/
  __pyx_tp_clear_9tesserocr___pyx_scope_struct_4_genexpr, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr___pyx_scope_struct_4_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *__pyx_freelist_9tesserocr___pyx_scope_struct_5_iterate_choices[8];
static int __pyx_freecount_9tesserocr___pyx_scope_struct_5_iterate_choices = 0;

static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_5_iterate_choices(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9tesserocr___pyx_scope_struct_5_iterate_choices > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices)))) {
    o = (PyObject*)__pyx_freelist_9tesserocr___pyx_scope_struct_5_iterate_choices[--__pyx_freecount_9tesserocr___pyx_scope_struct_5_iterate_choices];
    memset(o, 0, sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_5_iterate_choices(PyObject *o) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_citerator);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9tesserocr___pyx_scope_struct_5_iterate_choices < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices)))) {
    __pyx_freelist_9tesserocr___pyx_scope_struct_5_iterate_choices[__pyx_freecount_9tesserocr___pyx_scope_struct_5_iterate_choices++] = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9tesserocr___pyx_scope_struct_5_iterate_choices(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *)o;
  if (p->__pyx_v_citerator) {
    e = (*v)(p->__pyx_v_citerator, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9tesserocr___pyx_scope_struct_5_iterate_choices(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices *)o;
  tmp = ((PyObject*)p->__pyx_v_citerator);
  p->__pyx_v_citerator = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9tesserocr___pyx_scope_struct_5_iterate_choices = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.__pyx_scope_struct_5_iterate_choices", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_5_iterate_choices), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_5_iterate_choices, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9tesserocr___pyx_scope_struct_5_iterate_choices, /*tp_traverse*/
  __pyx_tp_clear_9tesserocr___pyx_scope_struct_5_iterate_choices, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr___pyx_scope_struct_5_iterate_choices, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *__pyx_freelist_9tesserocr___pyx_scope_struct_6_iterate_level[8];
static int __pyx_freecount_9tesserocr___pyx_scope_struct_6_iterate_level = 0;

static PyObject *__pyx_tp_new_9tesserocr___pyx_scope_struct_6_iterate_level(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9tesserocr___pyx_scope_struct_6_iterate_level > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level)))) {
    o = (PyObject*)__pyx_freelist_9tesserocr___pyx_scope_struct_6_iterate_level[--__pyx_freecount_9tesserocr___pyx_scope_struct_6_iterate_level];
    memset(o, 0, sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_6_iterate_level(PyObject *o) {
  struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_iterator);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9tesserocr___pyx_scope_struct_6_iterate_level < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level)))) {
    __pyx_freelist_9tesserocr___pyx_scope_struct_6_iterate_level[__pyx_freecount_9tesserocr___pyx_scope_struct_6_iterate_level++] = ((struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9tesserocr___pyx_scope_struct_6_iterate_level(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *)o;
  if (p->__pyx_v_iterator) {
    e = (*v)(p->__pyx_v_iterator, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9tesserocr___pyx_scope_struct_6_iterate_level(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *p = (struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level *)o;
  tmp = ((PyObject*)p->__pyx_v_iterator);
  p->__pyx_v_iterator = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9tesserocr___pyx_scope_struct_6_iterate_level = {
  PyVarObject_HEAD_INIT(0, 0)
  "tesserocr.__pyx_scope_struct_6_iterate_level", /*tp_name*/
  sizeof(struct __pyx_obj_9tesserocr___pyx_scope_struct_6_iterate_level), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9tesserocr___pyx_scope_struct_6_iterate_level, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9tesserocr___pyx_scope_struct_6_iterate_level, /*tp_traverse*/
  __pyx_tp_clear_9tesserocr___pyx_scope_struct_6_iterate_level, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9tesserocr___pyx_scope_struct_6_iterate_level, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    "tesserocr",
    __pyx_k_Python_wrapper_around_the_Tesser, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_2_0_0, __pyx_k_2_0_0, sizeof(__pyx_k_2_0_0), 0, 0, 1, 0},
  {&__pyx_n_s_AUTO, __pyx_k_AUTO, sizeof(__pyx_k_AUTO), 0, 0, 1, 1},
  {&__pyx_n_s_AUTO_ONLY, __pyx_k_AUTO_ONLY, sizeof(__pyx_k_AUTO_ONLY), 0, 0, 1, 1},
  {&__pyx_n_s_AUTO_OSD, __pyx_k_AUTO_OSD, sizeof(__pyx_k_AUTO_OSD), 0, 0, 1, 1},
  {&__pyx_n_s_AllWordConfidences, __pyx_k_AllWordConfidences, sizeof(__pyx_k_AllWordConfidences), 0, 0, 1, 1},
  {&__pyx_n_s_BLOCK, __pyx_k_BLOCK, sizeof(__pyx_k_BLOCK), 0, 0, 1, 1},
  {&__pyx_n_s_BMP, __pyx_k_BMP, sizeof(__pyx_k_BMP), 0, 0, 1, 1},
  {&__pyx_n_s_BlockPolygon_locals_genexpr, __pyx_k_BlockPolygon_locals_genexpr, sizeof(__pyx_k_BlockPolygon_locals_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_CAPTION_TEXT, __pyx_k_CAPTION_TEXT, sizeof(__pyx_k_CAPTION_TEXT), 0, 0, 1, 1},
  {&__pyx_n_s_CENTER, __pyx_k_CENTER, sizeof(__pyx_k_CENTER), 0, 0, 1, 1},
  {&__pyx_n_s_CIRCLE_WORD, __pyx_k_CIRCLE_WORD, sizeof(__pyx_k_CIRCLE_WORD), 0, 0, 1, 1},
  {&__pyx_n_s_COUNT, __pyx_k_COUNT, sizeof(__pyx_k_COUNT), 0, 0, 1, 1},
  {&__pyx_n_s_CUBE_ONLY, __pyx_k_CUBE_ONLY, sizeof(__pyx_k_CUBE_ONLY), 0, 0, 1, 1},
  {&__pyx_kp_s_ChoiceIterator_cannot_be_instant, __pyx_k_ChoiceIterator_cannot_be_instant, sizeof(__pyx_k_ChoiceIterator_cannot_be_instant), 0, 0, 1, 0},
  {&__pyx_n_s_ClearPersistentCache, __pyx_k_ClearPersistentCache, sizeof(__pyx_k_ClearPersistentCache), 0, 0, 1, 1},
  {&__pyx_n_s_DEFAULT, __pyx_k_DEFAULT, sizeof(__pyx_k_DEFAULT), 0, 0, 1, 1},
  {&__pyx_n_s_EQUATION, __pyx_k_EQUATION, sizeof(__pyx_k_EQUATION), 0, 0, 1, 1},
  {&__pyx_kp_s_Error_reading_image, __pyx_k_Error_reading_image, sizeof(__pyx_k_Error_reading_image), 0, 0, 1, 0},
  {&__pyx_n_s_FLOWING_IMAGE, __pyx_k_FLOWING_IMAGE, sizeof(__pyx_k_FLOWING_IMAGE), 0, 0, 1, 1},
  {&__pyx_n_s_FLOWING_TEXT, __pyx_k_FLOWING_TEXT, sizeof(__pyx_k_FLOWING_TEXT), 0, 0, 1, 1},
  {&__pyx_kp_s_Failed_recognize_picture, __pyx_k_Failed_recognize_picture, sizeof(__pyx_k_Failed_recognize_picture), 0, 0, 1, 0},
  {&__pyx_kp_s_Failed_to_initialize_API, __pyx_k_Failed_to_initialize_API, sizeof(__pyx_k_Failed_to_initialize_API), 0, 0, 1, 0},
  {&__pyx_kp_s_Failed_to_read_image, __pyx_k_Failed_to_read_image, sizeof(__pyx_k_Failed_to_read_image), 0, 0, 1, 0},
  {&__pyx_kp_s_Failed_to_read_picture, __pyx_k_Failed_to_read_picture, sizeof(__pyx_k_Failed_to_read_picture), 0, 0, 1, 0},
  {&__pyx_kp_s_Failed_to_recognize_No_image_set, __pyx_k_Failed_to_recognize_No_image_set, sizeof(__pyx_k_Failed_to_recognize_No_image_set), 0, 0, 1, 0},
  {&__pyx_kp_s_Failed_to_recognize_image, __pyx_k_Failed_to_recognize_image, sizeof(__pyx_k_Failed_to_recognize_image), 0, 0, 1, 0},
  {&__pyx_n_s_GetUTF8Text, __pyx_k_GetUTF8Text, sizeof(__pyx_k_GetUTF8Text), 0, 0, 1, 1},
  {&__pyx_n_s_HEADING_IMAGE, __pyx_k_HEADING_IMAGE, sizeof(__pyx_k_HEADING_IMAGE), 0, 0, 1, 1},
  {&__pyx_n_s_HEADING_TEXT, __pyx_k_HEADING_TEXT, sizeof(__pyx_k_HEADING_TEXT), 0, 0, 1, 1},
  {&__pyx_n_s_HORZ_LINE, __pyx_k_HORZ_LINE, sizeof(__pyx_k_HORZ_LINE), 0, 0, 1, 1},
  {&__pyx_n_s_INLINE_EQUATION, __pyx_k_INLINE_EQUATION, sizeof(__pyx_k_INLINE_EQUATION), 0, 0, 1, 1},
  {&__pyx_n_s_Image, __pyx_k_Image, sizeof(__pyx_k_Image), 0, 0, 1, 1},
  {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
  {&__pyx_n_s_LEFT, __pyx_k_LEFT, sizeof(__pyx_k_LEFT), 0, 0, 1, 1},
  {&__pyx_n_s_LEFT_TO_RIGHT, __pyx_k_LEFT_TO_RIGHT, sizeof(__pyx_k_LEFT_TO_RIGHT), 0, 0, 1, 1},
  {&__pyx_n_s_MIX, __pyx_k_MIX, sizeof(__pyx_k_MIX), 0, 0, 1, 1},
  {&__pyx_n_s_NEUTRAL, __pyx_k_NEUTRAL, sizeof(__pyx_k_NEUTRAL), 0, 0, 1, 1},
  {&__pyx_n_s_NOISE, __pyx_k_NOISE, sizeof(__pyx_k_NOISE), 0, 0, 1, 1},
  {&__pyx_n_s_Next, __pyx_k_Next, sizeof(__pyx_k_Next), 0, 0, 1, 1},
  {&__pyx_kp_s_No_renderers_enabled, __pyx_k_No_renderers_enabled, sizeof(__pyx_k_No_renderers_enabled), 0, 0, 1, 0},
  {&__pyx_kp_s_No_text_returned, __pyx_k_No_text_returned, sizeof(__pyx_k_No_text_returned), 0, 0, 1, 0},
  {&__pyx_n_s_OSD_ONLY, __pyx_k_OSD_ONLY, sizeof(__pyx_k_OSD_ONLY), 0, 0, 1, 1},
  {&__pyx_n_s_PAGE_DOWN, __pyx_k_PAGE_DOWN, sizeof(__pyx_k_PAGE_DOWN), 0, 0, 1, 1},
  {&__pyx_n_s_PAGE_LEFT, __pyx_k_PAGE_LEFT, sizeof(__pyx_k_PAGE_LEFT), 0, 0, 1, 1},
  {&__pyx_n_s_PAGE_RIGHT, __pyx_k_PAGE_RIGHT, sizeof(__pyx_k_PAGE_RIGHT), 0, 0, 1, 1},
  {&__pyx_n_s_PAGE_UP, __pyx_k_PAGE_UP, sizeof(__pyx_k_PAGE_UP), 0, 0, 1, 1},
  {&__pyx_n_s_PARA, __pyx_k_PARA, sizeof(__pyx_k_PARA), 0, 0, 1, 1},
  {&__pyx_n_s_PIL, __pyx_k_PIL, sizeof(__pyx_k_PIL), 0, 0, 1, 1},
  {&__pyx_n_s_PULLOUT_IMAGE, __pyx_k_PULLOUT_IMAGE, sizeof(__pyx_k_PULLOUT_IMAGE), 0, 0, 1, 1},
  {&__pyx_n_s_PULLOUT_TEXT, __pyx_k_PULLOUT_TEXT, sizeof(__pyx_k_PULLOUT_TEXT), 0, 0, 1, 1},
  {&__pyx_n_s_RAW_LINE, __pyx_k_RAW_LINE, sizeof(__pyx_k_RAW_LINE), 0, 0, 1, 1},
  {&__pyx_n_s_RIGHT, __pyx_k_RIGHT, sizeof(__pyx_k_RIGHT), 0, 0, 1, 1},
  {&__pyx_n_s_RIGHT_TO_LEFT, __pyx_k_RIGHT_TO_LEFT, sizeof(__pyx_k_RIGHT_TO_LEFT), 0, 0, 1, 1},
  {&__pyx_n_s_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 0, 0, 1, 1},
  {&__pyx_n_s_SINGLE_BLOCK, __pyx_k_SINGLE_BLOCK, sizeof(__pyx_k_SINGLE_BLOCK), 0, 0, 1, 1},
  {&__pyx_n_s_SINGLE_BLOCK_VERT_TEXT, __pyx_k_SINGLE_BLOCK_VERT_TEXT, sizeof(__pyx_k_SINGLE_BLOCK_VERT_TEXT), 0, 0, 1, 1},
  {&__pyx_n_s_SINGLE_CHAR, __pyx_k_SINGLE_CHAR, sizeof(__pyx_k_SINGLE_CHAR), 0, 0, 1, 1},
  {&__pyx_n_s_SINGLE_COLUMN, __pyx_k_SINGLE_COLUMN, sizeof(__pyx_k_SINGLE_COLUMN), 0, 0, 1, 1},
  {&__pyx_n_s_SINGLE_LINE, __pyx_k_SINGLE_LINE, sizeof(__pyx_k_SINGLE_LINE), 0, 0, 1, 1},
  {&__pyx_n_s_SINGLE_WORD, __pyx_k_SINGLE_WORD, sizeof(__pyx_k_SINGLE_WORD), 0, 0, 1, 1},
  {&__pyx_n_s_SPARSE_TEXT, __pyx_k_SPARSE_TEXT, sizeof(__pyx_k_SPARSE_TEXT), 0, 0, 1, 1},
  {&__pyx_n_s_SPARSE_TEXT_OSD, __pyx_k_SPARSE_TEXT_OSD, sizeof(__pyx_k_SPARSE_TEXT_OSD), 0, 0, 1, 1},
  {&__pyx_n_s_SYMBOL, __pyx_k_SYMBOL, sizeof(__pyx_k_SYMBOL), 0, 0, 1, 1},
  {&__pyx_n_s_StringIO, __pyx_k_StringIO, sizeof(__pyx_k_StringIO), 0, 0, 1, 1},
  {&__pyx_n_s_TABLE, __pyx_k_TABLE, sizeof(__pyx_k_TABLE), 0, 0, 1, 1},
  {&__pyx_n_s_TESSERACT_CUBE_COMBINED, __pyx_k_TESSERACT_CUBE_COMBINED, sizeof(__pyx_k_TESSERACT_CUBE_COMBINED), 0, 0, 1, 1},
  {&__pyx_n_s_TESSERACT_ONLY, __pyx_k_TESSERACT_ONLY, sizeof(__pyx_k_TESSERACT_ONLY), 0, 0, 1, 1},
  {&__pyx_n_s_TEXTLINE, __pyx_k_TEXTLINE, sizeof(__pyx_k_TEXTLINE), 0, 0, 1, 1},
  {&__pyx_n_s_TOP_TO_BOTTOM, __pyx_k_TOP_TO_BOTTOM, sizeof(__pyx_k_TOP_TO_BOTTOM), 0, 0, 1, 1},
  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
  {&__pyx_n_s_UNKNOWN, __pyx_k_UNKNOWN, sizeof(__pyx_k_UNKNOWN), 0, 0, 1, 1},
  {&__pyx_n_s_VERTICAL_TEXT, __pyx_k_VERTICAL_TEXT, sizeof(__pyx_k_VERTICAL_TEXT), 0, 0, 1, 1},
  {&__pyx_n_s_VERT_LINE, __pyx_k_VERT_LINE, sizeof(__pyx_k_VERT_LINE), 0, 0, 1, 1},
  {&__pyx_n_s_Version, __pyx_k_Version, sizeof(__pyx_k_Version), 0, 0, 1, 1},
  {&__pyx_n_s_WORD, __pyx_k_WORD, sizeof(__pyx_k_WORD), 0, 0, 1, 1},
  {&__pyx_kp_s__29, __pyx_k__29, sizeof(__pyx_k__29), 0, 0, 1, 0},
  {&__pyx_n_s_abspath, __pyx_k_abspath, sizeof(__pyx_k_abspath), 0, 0, 1, 1},
  {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
  {&__pyx_n_s_baseapi, __pyx_k_baseapi, sizeof(__pyx_k_baseapi), 0, 0, 1, 1},
  {&__pyx_n_s_blockids, __pyx_k_blockids, sizeof(__pyx_k_blockids), 0, 0, 1, 1},
  {&__pyx_n_s_bold, __pyx_k_bold, sizeof(__pyx_k_bold), 0, 0, 1, 1},
  {&__pyx_n_s_buff, __pyx_k_buff, sizeof(__pyx_k_buff), 0, 0, 1, 1},
  {&__pyx_n_s_bytes_per_line, __pyx_k_bytes_per_line, sizeof(__pyx_k_bytes_per_line), 0, 0, 1, 1},
  {&__pyx_n_s_bytes_per_pixel, __pyx_k_bytes_per_pixel, sizeof(__pyx_k_bytes_per_pixel), 0, 0, 1, 1},
  {&__pyx_n_s_cStringIO, __pyx_k_cStringIO, sizeof(__pyx_k_cStringIO), 0, 0, 1, 1},
  {&__pyx_kp_s_cannot_be_instantiated_from_Pyt, __pyx_k_cannot_be_instantiated_from_Pyt, sizeof(__pyx_k_cannot_be_instantiated_from_Pyt), 0, 0, 1, 0},
  {&__pyx_n_s_citerator, __pyx_k_citerator, sizeof(__pyx_k_citerator), 0, 0, 1, 1},
  {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
  {&__pyx_n_s_closing, __pyx_k_closing, sizeof(__pyx_k_closing), 0, 0, 1, 1},
  {&__pyx_n_s_configs, __pyx_k_configs, sizeof(__pyx_k_configs), 0, 0, 1, 1},
  {&__pyx_n_s_contextlib, __pyx_k_contextlib, sizeof(__pyx_k_contextlib), 0, 0, 1, 1},
  {&__pyx_n_s_element, __pyx_k_element, sizeof(__pyx_k_element), 0, 0, 1, 1},
  {&__pyx_n_s_enter, __pyx_k_enter, sizeof(__pyx_k_enter), 0, 0, 1, 1},
  {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
  {&__pyx_n_s_exc_tb, __pyx_k_exc_tb, sizeof(__pyx_k_exc_tb), 0, 0, 1, 1},
  {&__pyx_n_s_exc_tp, __pyx_k_exc_tp, sizeof(__pyx_k_exc_tp), 0, 0, 1, 1},
  {&__pyx_n_s_exc_val, __pyx_k_exc_val, sizeof(__pyx_k_exc_val), 0, 0, 1, 1},
  {&__pyx_n_s_exit, __pyx_k_exit, sizeof(__pyx_k_exit), 0, 0, 1, 1},
  {&__pyx_n_s_file_to_text, __pyx_k_file_to_text, sizeof(__pyx_k_file_to_text), 0, 0, 1, 1},
  {&__pyx_n_s_filename, __pyx_k_filename, sizeof(__pyx_k_filename), 0, 0, 1, 1},
  {&__pyx_n_s_font_id, __pyx_k_font_id, sizeof(__pyx_k_font_id), 0, 0, 1, 1},
  {&__pyx_n_s_font_name, __pyx_k_font_name, sizeof(__pyx_k_font_name), 0, 0, 1, 1},
  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
  {&__pyx_n_s_fromat, __pyx_k_fromat, sizeof(__pyx_k_fromat), 0, 0, 1, 1},
  {&__pyx_n_s_genexpr, __pyx_k_genexpr, sizeof(__pyx_k_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_get_languages, __pyx_k_get_languages, sizeof(__pyx_k_get_languages), 0, 0, 1, 1},
  {&__pyx_n_s_getvalue, __pyx_k_getvalue, sizeof(__pyx_k_getvalue), 0, 0, 1, 1},
  {&__pyx_n_s_h, __pyx_k_h, sizeof(__pyx_k_h), 0, 0, 1, 1},
  {&__pyx_n_s_height, __pyx_k_height, sizeof(__pyx_k_height), 0, 0, 1, 1},
  {&__pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_k_home_fz_workspace_tesserocr_tes, sizeof(__pyx_k_home_fz_workspace_tesserocr_tes), 0, 0, 1, 0},
  {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
  {&__pyx_n_s_image, __pyx_k_image, sizeof(__pyx_k_image), 0, 0, 1, 1},
  {&__pyx_n_s_image_to_text, __pyx_k_image_to_text, sizeof(__pyx_k_image_to_text), 0, 0, 1, 1},
  {&__pyx_n_s_imagedata, __pyx_k_imagedata, sizeof(__pyx_k_imagedata), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_include_lower_dots, __pyx_k_include_lower_dots, sizeof(__pyx_k_include_lower_dots), 0, 0, 1, 1},
  {&__pyx_n_s_include_upper_dots, __pyx_k_include_upper_dots, sizeof(__pyx_k_include_upper_dots), 0, 0, 1, 1},
  {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
  {&__pyx_kp_s_is_an_enum_and_cannot_be_instan, __pyx_k_is_an_enum_and_cannot_be_instan, sizeof(__pyx_k_is_an_enum_and_cannot_be_instan), 0, 0, 1, 0},
  {&__pyx_n_s_italic, __pyx_k_italic, sizeof(__pyx_k_italic), 0, 0, 1, 1},
  {&__pyx_n_s_iterate_choices, __pyx_k_iterate_choices, sizeof(__pyx_k_iterate_choices), 0, 0, 1, 1},
  {&__pyx_n_s_iterate_level, __pyx_k_iterate_level, sizeof(__pyx_k_iterate_level), 0, 0, 1, 1},
  {&__pyx_n_s_iterator, __pyx_k_iterator, sizeof(__pyx_k_iterator), 0, 0, 1, 1},
  {&__pyx_n_s_iteritems, __pyx_k_iteritems, sizeof(__pyx_k_iteritems), 0, 0, 1, 1},
  {&__pyx_n_s_join, __pyx_k_join, sizeof(__pyx_k_join), 0, 0, 1, 1},
  {&__pyx_n_s_lang, __pyx_k_lang, sizeof(__pyx_k_lang), 0, 0, 1, 1},
  {&__pyx_n_s_langs, __pyx_k_langs, sizeof(__pyx_k_langs), 0, 0, 1, 1},
  {&__pyx_n_s_left, __pyx_k_left, sizeof(__pyx_k_left), 0, 0, 1, 1},
  {&__pyx_n_s_lept_v, __pyx_k_lept_v, sizeof(__pyx_k_lept_v), 0, 0, 1, 1},
  {&__pyx_n_s_level, __pyx_k_level, sizeof(__pyx_k_level), 0, 0, 1, 1},
  {&__pyx_n_s_libs_v, __pyx_k_libs_v, sizeof(__pyx_k_libs_v), 0, 0, 1, 1},
  {&__pyx_n_s_load, __pyx_k_load, sizeof(__pyx_k_load), 0, 0, 1, 1},
  {&__pyx_n_s_ltr_iterator, __pyx_k_ltr_iterator, sizeof(__pyx_k_ltr_iterator), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_merge_similar_words, __pyx_k_merge_similar_words, sizeof(__pyx_k_merge_similar_words), 0, 0, 1, 1},
  {&__pyx_n_s_monospace, __pyx_k_monospace, sizeof(__pyx_k_monospace), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
  {&__pyx_n_s_oem, __pyx_k_oem, sizeof(__pyx_k_oem), 0, 0, 1, 1},
  {&__pyx_n_s_open, __pyx_k_open, sizeof(__pyx_k_open), 0, 0, 1, 1},
  {&__pyx_n_s_original_image, __pyx_k_original_image, sizeof(__pyx_k_original_image), 0, 0, 1, 1},
  {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
  {&__pyx_n_s_os_path, __pyx_k_os_path, sizeof(__pyx_k_os_path), 0, 0, 1, 1},
  {&__pyx_n_s_outputbase, __pyx_k_outputbase, sizeof(__pyx_k_outputbase), 0, 0, 1, 1},
  {&__pyx_n_s_padding, __pyx_k_padding, sizeof(__pyx_k_padding), 0, 0, 1, 1},
  {&__pyx_n_s_page_index, __pyx_k_page_index, sizeof(__pyx_k_page_index), 0, 0, 1, 1},
  {&__pyx_n_s_paraids, __pyx_k_paraids, sizeof(__pyx_k_paraids), 0, 0, 1, 1},
  {&__pyx_n_s_pardir, __pyx_k_pardir, sizeof(__pyx_k_pardir), 0, 0, 1, 1},
  {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
  {&__pyx_n_s_pix, __pyx_k_pix, sizeof(__pyx_k_pix), 0, 0, 1, 1},
  {&__pyx_n_s_pixa_to_list_locals_genexpr, __pyx_k_pixa_to_list_locals_genexpr, sizeof(__pyx_k_pixa_to_list_locals_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_pointsize, __pyx_k_pointsize, sizeof(__pyx_k_pointsize), 0, 0, 1, 1},
  {&__pyx_n_s_psm, __pyx_k_psm, sizeof(__pyx_k_psm), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_raw, __pyx_k_raw, sizeof(__pyx_k_raw), 0, 0, 1, 1},
  {&__pyx_n_s_raw_image, __pyx_k_raw_image, sizeof(__pyx_k_raw_image), 0, 0, 1, 1},
  {&__pyx_n_s_raw_padding, __pyx_k_raw_padding, sizeof(__pyx_k_raw_padding), 0, 0, 1, 1},
  {&__pyx_n_s_retry_config, __pyx_k_retry_config, sizeof(__pyx_k_retry_config), 0, 0, 1, 1},
  {&__pyx_n_s_save, __pyx_k_save, sizeof(__pyx_k_save), 0, 0, 1, 1},
  {&__pyx_n_s_send, __pyx_k_send, sizeof(__pyx_k_send), 0, 0, 1, 1},
  {&__pyx_n_s_sep, __pyx_k_sep, sizeof(__pyx_k_sep), 0, 0, 1, 1},
  {&__pyx_n_s_serif, __pyx_k_serif, sizeof(__pyx_k_serif), 0, 0, 1, 1},
  {&__pyx_n_s_set_only_non_debug_params, __pyx_k_set_only_non_debug_params, sizeof(__pyx_k_set_only_non_debug_params), 0, 0, 1, 1},
  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
  {&__pyx_n_s_smallcaps, __pyx_k_smallcaps, sizeof(__pyx_k_smallcaps), 0, 0, 1, 1},
  {&__pyx_n_s_split, __pyx_k_split, sizeof(__pyx_k_split), 0, 0, 1, 1},
  {&__pyx_n_s_staticmethod, __pyx_k_staticmethod, sizeof(__pyx_k_staticmethod), 0, 0, 1, 1},
  {&__pyx_n_s_tess_v, __pyx_k_tess_v, sizeof(__pyx_k_tess_v), 0, 0, 1, 1},
  {&__pyx_kp_u_tesseract, __pyx_k_tesseract, sizeof(__pyx_k_tesseract), 0, 1, 0, 0},
  {&__pyx_n_s_tesseract_version, __pyx_k_tesseract_version, sizeof(__pyx_k_tesseract_version), 0, 0, 1, 1},
  {&__pyx_n_s_tesserocr, __pyx_k_tesserocr, sizeof(__pyx_k_tesserocr), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_text, __pyx_k_text, sizeof(__pyx_k_text), 0, 0, 1, 1},
  {&__pyx_n_s_text_only, __pyx_k_text_only, sizeof(__pyx_k_text_only), 0, 0, 1, 1},
  {&__pyx_n_s_throw, __pyx_k_throw, sizeof(__pyx_k_throw), 0, 0, 1, 1},
  {&__pyx_n_s_timeout, __pyx_k_timeout, sizeof(__pyx_k_timeout), 0, 0, 1, 1},
  {&__pyx_n_s_top, __pyx_k_top, sizeof(__pyx_k_top), 0, 0, 1, 1},
  {&__pyx_n_s_underlined, __pyx_k_underlined, sizeof(__pyx_k_underlined), 0, 0, 1, 1},
  {&__pyx_n_s_v, __pyx_k_v, sizeof(__pyx_k_v), 0, 0, 1, 1},
  {&__pyx_n_s_val, __pyx_k_val, sizeof(__pyx_k_val), 0, 0, 1, 1},
  {&__pyx_n_s_variables, __pyx_k_variables, sizeof(__pyx_k_variables), 0, 0, 1, 1},
  {&__pyx_n_s_version, __pyx_k_version, sizeof(__pyx_k_version), 0, 0, 1, 1},
  {&__pyx_n_s_version_str, __pyx_k_version_str, sizeof(__pyx_k_version_str), 0, 0, 1, 1},
  {&__pyx_n_s_w, __pyx_k_w, sizeof(__pyx_k_w), 0, 0, 1, 1},
  {&__pyx_n_s_width, __pyx_k_width, sizeof(__pyx_k_width), 0, 0, 1, 1},
  {&__pyx_n_s_word, __pyx_k_word, sizeof(__pyx_k_word), 0, 0, 1, 1},
  {&__pyx_n_s_x, __pyx_k_x, sizeof(__pyx_k_x), 0, 0, 1, 1},
  {&__pyx_n_s_xrange, __pyx_k_xrange, sizeof(__pyx_k_xrange), 0, 0, 1, 1},
  {&__pyx_n_s_y, __pyx_k_y, sizeof(__pyx_k_y), 0, 0, 1, 1},
  {&__pyx_n_s_zip, __pyx_k_zip, sizeof(__pyx_k_zip), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 29; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_staticmethod = __Pyx_GetBuiltinName(__pyx_n_s_staticmethod); if (!__pyx_builtin_staticmethod) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_zip = __Pyx_GetBuiltinName(__pyx_n_s_zip); if (!__pyx_builtin_zip) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 760; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION >= 3
  __pyx_builtin_xrange = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_xrange) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #else
  __pyx_builtin_xrange = __Pyx_GetBuiltinName(__pyx_n_s_xrange); if (!__pyx_builtin_xrange) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "tesserocr.pyx":293
 * cdef str _image_buffer(image):
 *     """Return raw bytes of a PIL Image"""
 *     with closing(StringIO()) as f:             # <<<<<<<<<<<<<<
 *         image.save(f, 'BMP')
 *         return f.getvalue()
 */
  __pyx_tuple_ = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple_)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);
  __pyx_tuple__2 = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple__2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "tesserocr.pyx":305
 *     pixWriteMemBmp(&buff, &size, pix)
 * 
 *     with closing(StringIO(<bytes>buff[:size])) as f:             # <<<<<<<<<<<<<<
 *         image = Image.open(f)
 *         image.load()
 */
  __pyx_tuple__3 = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple__3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "tesserocr.pyx":760
 *         cdef char *text = self._ltrriter.GetUTF8Text(level)
 *         if text == NULL:
 *             raise RuntimeError('No text returned')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_No_text_returned); if (unlikely(!__pyx_tuple__4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 760; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "tesserocr.pyx":978
 * 
 *     def __init__(self, ltr_iterator):
 *         raise TypeError('ChoiceIterator cannot be instantiated from Python')             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_ChoiceIterator_cannot_be_instant); if (unlikely(!__pyx_tuple__5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "tesserocr.pyx":1263
 *                                   set_only_non_debug_params, PSM_AUTO) == -1:
 *                     with gil:
 *                         raise RuntimeError('Failed to initialize API')             # <<<<<<<<<<<<<<
 *             finally:
 *                 free(configs_)
 */
  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_initialize_API); if (unlikely(!__pyx_tuple__14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);

  /* "tesserocr.pyx":1287
 *             if self._init_api(path, lang, oem, NULL, 0, NULL, NULL, False, PSM_AUTO) == -1:
 *                 with gil:
 *                     raise RuntimeError('Failed to initialize API')             # <<<<<<<<<<<<<<
 * 
 *     def GetInitLanguagesAsString(self):
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_initialize_API); if (unlikely(!__pyx_tuple__18)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);

  /* "tesserocr.pyx":1389
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize image')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_recognize_image); if (unlikely(!__pyx_tuple__19)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1389; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__19);
  __Pyx_GIVEREF(__pyx_tuple__19);

  /* "tesserocr.pyx":1453
 *             if self._pix == NULL:
 *                 with gil:
 *                     raise RuntimeError('Error reading image')             # <<<<<<<<<<<<<<
 *             self._baseapi.SetImage(self._pix)
 * 
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_Error_reading_image); if (unlikely(!__pyx_tuple__20)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "tesserocr.pyx":1471
 *             if self._pix == NULL:
 *                 with gil:
 *                     raise RuntimeError('Error reading image')             # <<<<<<<<<<<<<<
 *             self._baseapi.SetImage(self._pix)
 * 
 */
  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_Error_reading_image); if (unlikely(!__pyx_tuple__21)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "tesserocr.pyx":1872
 *             except:
 *                 del renderer
 *         raise RuntimeError('No renderers enabled')             # <<<<<<<<<<<<<<
 * 
 *     def ProcessPage(self, cchar_t *outputbase, image, int page_index, cchar_t *filename,
 */
  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_No_renderers_enabled); if (unlikely(!__pyx_tuple__22)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1872; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "tesserocr.pyx":1903
 *         pix = pixReadMemBmp(buff, size)
 *         if pix == NULL:
 *             raise RuntimeError('Failed to read image')             # <<<<<<<<<<<<<<
 *         if renderer != NULL:
 *             try:
 */
  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_read_image); if (unlikely(!__pyx_tuple__23)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1903; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__23);
  __Pyx_GIVEREF(__pyx_tuple__23);

  /* "tesserocr.pyx":1910
 *                 pixDestroy(&pix)
 *                 del renderer
 *         raise RuntimeError('No renderers enabled')             # <<<<<<<<<<<<<<
 * 
 *     def GetIterator(self):
 */
  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_No_renderers_enabled); if (unlikely(!__pyx_tuple__24)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__24);
  __Pyx_GIVEREF(__pyx_tuple__24);

  /* "tesserocr.pyx":1930
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_recognize_No_image_set); if (unlikely(!__pyx_tuple__25)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1930; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "tesserocr.pyx":1946
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_recognize_No_image_set); if (unlikely(!__pyx_tuple__26)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1946; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);

  /* "tesserocr.pyx":1965
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_recognize_No_image_set); if (unlikely(!__pyx_tuple__27)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "tesserocr.pyx":1978
 *             if text == NULL:
 *                 with gil:
 *                     raise RuntimeError('Failed to recognize. No image set?')             # <<<<<<<<<<<<<<
 *         return _free_str(text)
 * 
 */
  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_recognize_No_image_set); if (unlikely(!__pyx_tuple__28)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);

  /* "tesserocr.pyx":2006
 *     def MapWordConfidences(self):
 *         """Return list of word, confidence tuples"""
 *         return zip(self.GetUTF8Text().split(' '), self.AllWordConfidences())             # <<<<<<<<<<<<<<
 * 
 *     def AdaptToWordStr(self, PageSegMode psm, cchar_t *word):
 */
  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s__29); if (unlikely(!__pyx_tuple__30)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);

  /* "tesserocr.pyx":2141
 *         if pix == NULL:
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')             # <<<<<<<<<<<<<<
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:
 */
  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_read_picture); if (unlikely(!__pyx_tuple__34)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);

  /* "tesserocr.pyx":2145
 *         if text == NULL:
 *             with gil:
 *                 raise RuntimeError('Failed recognize picture')             # <<<<<<<<<<<<<<
 * 
 *     return _free_str(text)
 */
  __pyx_tuple__35 = PyTuple_Pack(1, __pyx_kp_s_Failed_recognize_picture); if (unlikely(!__pyx_tuple__35)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2145; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__35);
  __Pyx_GIVEREF(__pyx_tuple__35);

  /* "tesserocr.pyx":2178
 *         if pix == NULL:
 *             with gil:
 *                 raise RuntimeError('Failed to read picture')             # <<<<<<<<<<<<<<
 *         text = _image_to_text(pix, lang, psm, path)
 *         if text == NULL:
 */
  __pyx_tuple__39 = PyTuple_Pack(1, __pyx_kp_s_Failed_to_read_picture); if (unlikely(!__pyx_tuple__39)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__39);
  __Pyx_GIVEREF(__pyx_tuple__39);

  /* "tesserocr.pyx":2182
 *         if text == NULL:
 *             with gil:
 *                 raise RuntimeError('Failed recognize picture')             # <<<<<<<<<<<<<<
 * 
 *     return _free_str(text)
 */
  __pyx_tuple__40 = PyTuple_Pack(1, __pyx_kp_s_Failed_recognize_picture); if (unlikely(!__pyx_tuple__40)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__40);
  __Pyx_GIVEREF(__pyx_tuple__40);

  /* "tesserocr.pyx":1004
 * 
 * 
 * def iterate_choices(citerator):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate :class:`PyChoiceIterator`."""
 *     yield citerator
 */
  __pyx_tuple__42 = PyTuple_Pack(1, __pyx_n_s_citerator); if (unlikely(!__pyx_tuple__42)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__42);
  __Pyx_GIVEREF(__pyx_tuple__42);
  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__42, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_n_s_iterate_choices, 1004, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1011
 * 
 * 
 * def iterate_level(iterator, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate a :class:`PyPageIterator`
 *     level.
 */
  __pyx_tuple__44 = PyTuple_Pack(2, __pyx_n_s_iterator, __pyx_n_s_level); if (unlikely(!__pyx_tuple__44)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__44);
  __Pyx_GIVEREF(__pyx_tuple__44);
  __pyx_codeobj__45 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_n_s_iterate_level, 1011, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__45)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1066
 * 
 *     @staticmethod
 *     def Version():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.Version()
 * 
 */
  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_n_s_Version, 1066, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":1070
 * 
 *     @staticmethod
 *     def ClearPersistentCache():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 */
  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_n_s_ClearPersistentCache, 1070, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":2106
 * 
 * 
 * def image_to_text(image, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                    cchar_t *path=_DEFAULT_PATH):
 *     """Recognize OCR text from an image object.
 */
  __pyx_tuple__48 = PyTuple_Pack(9, __pyx_n_s_image, __pyx_n_s_lang, __pyx_n_s_psm, __pyx_n_s_path, __pyx_n_s_pix, __pyx_n_s_buff, __pyx_n_s_size, __pyx_n_s_text, __pyx_n_s_raw); if (unlikely(!__pyx_tuple__48)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__48);
  __Pyx_GIVEREF(__pyx_tuple__48);
  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(4, 0, 9, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_n_s_image_to_text, 2106, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":2150
 * 
 * 
 * def file_to_text(cchar_t *filename, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                  cchar_t *path=_DEFAULT_PATH):
 *     """Extract OCR text from an image file.
 */
  __pyx_tuple__50 = PyTuple_Pack(6, __pyx_n_s_filename, __pyx_n_s_lang, __pyx_n_s_psm, __pyx_n_s_path, __pyx_n_s_pix, __pyx_n_s_text); if (unlikely(!__pyx_tuple__50)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__50);
  __Pyx_GIVEREF(__pyx_tuple__50);
  __pyx_codeobj__51 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__50, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_n_s_file_to_text, 2150, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__51)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":2187
 * 
 * 
 * def tesseract_version():             # <<<<<<<<<<<<<<
 *     """Return tesseract-ocr and leptonica version info"""
 *     version_str = u"tesseract {}\n {}\n  {}"
 */
  __pyx_tuple__52 = PyTuple_Pack(4, __pyx_n_s_version_str, __pyx_n_s_tess_v, __pyx_n_s_lept_v, __pyx_n_s_libs_v); if (unlikely(!__pyx_tuple__52)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__52);
  __Pyx_GIVEREF(__pyx_tuple__52);
  __pyx_codeobj__53 = (PyObject*)__Pyx_PyCode_New(0, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__52, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_n_s_tesseract_version, 2187, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__53)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":2196
 * 
 * 
 * def get_languages(cchar_t *path=_DEFAULT_PATH):             # <<<<<<<<<<<<<<
 *     """Return available languages in the given path.
 * 
 */
  __pyx_tuple__54 = PyTuple_Pack(5, __pyx_n_s_path, __pyx_n_s_baseapi, __pyx_n_s_v, __pyx_n_s_i, __pyx_n_s_langs); if (unlikely(!__pyx_tuple__54)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__54);
  __Pyx_GIVEREF(__pyx_tuple__54);
  __pyx_codeobj__55 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__54, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_fz_workspace_tesserocr_tes, __pyx_n_s_get_languages, 2196, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__55)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC inittesserocr(void); /*proto*/
PyMODINIT_FUNC inittesserocr(void)
#else
PyMODINIT_FUNC PyInit_tesserocr(void); /*proto*/
PyMODINIT_FUNC PyInit_tesserocr(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  tesseract::TessBaseAPI __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  Py_ssize_t __pyx_t_13;
  PyObject *__pyx_t_14 = NULL;
  __pyx_t_9tesseract_cchar_t *__pyx_t_15;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_tesserocr(void)", 0);
  if (__Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("tesserocr", __pyx_methods, __pyx_k_Python_wrapper_around_the_Tesser, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  if (__pyx_module_is_main_tesserocr) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!PyDict_GetItemString(modules, "tesserocr")) {
      if (unlikely(PyDict_SetItemString(modules, "tesserocr", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  __pyx_v_9tesserocr__abs_path = ((PyObject*)Py_None); Py_INCREF(Py_None);
  __pyx_v_9tesserocr__lang_s = ((PyObject*)Py_None); Py_INCREF(Py_None);
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_9tesserocr__Enum) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr__Enum.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "_Enum", (PyObject *)&__pyx_type_9tesserocr__Enum) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr__Enum = &__pyx_type_9tesserocr__Enum;
  __pyx_type_9tesserocr_OEM.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_OEM) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_OEM.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "OEM", (PyObject *)&__pyx_type_9tesserocr_OEM) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_OEM = &__pyx_type_9tesserocr_OEM;
  __pyx_type_9tesserocr_PSM.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_PSM) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_PSM.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "PSM", (PyObject *)&__pyx_type_9tesserocr_PSM) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_PSM = &__pyx_type_9tesserocr_PSM;
  __pyx_type_9tesserocr_RIL.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_RIL) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_RIL.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "RIL", (PyObject *)&__pyx_type_9tesserocr_RIL) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_RIL = &__pyx_type_9tesserocr_RIL;
  __pyx_type_9tesserocr_PT.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_PT) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_PT.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "PT", (PyObject *)&__pyx_type_9tesserocr_PT) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_PT = &__pyx_type_9tesserocr_PT;
  __pyx_type_9tesserocr_Orientation.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_Orientation) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_Orientation.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "Orientation", (PyObject *)&__pyx_type_9tesserocr_Orientation) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_Orientation = &__pyx_type_9tesserocr_Orientation;
  __pyx_type_9tesserocr_WritingDirection.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_WritingDirection) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_WritingDirection.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "WritingDirection", (PyObject *)&__pyx_type_9tesserocr_WritingDirection) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_WritingDirection = &__pyx_type_9tesserocr_WritingDirection;
  __pyx_type_9tesserocr_TextlineOrder.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_TextlineOrder) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_TextlineOrder.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "TextlineOrder", (PyObject *)&__pyx_type_9tesserocr_TextlineOrder) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_TextlineOrder = &__pyx_type_9tesserocr_TextlineOrder;
  __pyx_type_9tesserocr_Justification.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_Justification) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_Justification.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "Justification", (PyObject *)&__pyx_type_9tesserocr_Justification) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_Justification = &__pyx_type_9tesserocr_Justification;
  __pyx_type_9tesserocr_DIR.tp_base = __pyx_ptype_9tesserocr__Enum;
  if (PyType_Ready(&__pyx_type_9tesserocr_DIR) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_DIR.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "DIR", (PyObject *)&__pyx_type_9tesserocr_DIR) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_DIR = &__pyx_type_9tesserocr_DIR;
  __pyx_vtabptr_9tesserocr_PyPageIterator = &__pyx_vtable_9tesserocr_PyPageIterator;
  __pyx_vtable_9tesserocr_PyPageIterator.createPageIterator = (struct __pyx_obj_9tesserocr_PyPageIterator *(*)(tesseract::PageIterator *))__pyx_f_9tesserocr_14PyPageIterator_createPageIterator;
  if (PyType_Ready(&__pyx_type_9tesserocr_PyPageIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_PyPageIterator.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9tesserocr_PyPageIterator.tp_dict, __pyx_vtabptr_9tesserocr_PyPageIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "PyPageIterator", (PyObject *)&__pyx_type_9tesserocr_PyPageIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_PyPageIterator = &__pyx_type_9tesserocr_PyPageIterator;
  __pyx_vtabptr_9tesserocr_PyLTRResultIterator = &__pyx_vtable_9tesserocr_PyLTRResultIterator;
  __pyx_vtable_9tesserocr_PyLTRResultIterator.__pyx_base = *__pyx_vtabptr_9tesserocr_PyPageIterator;
  __pyx_type_9tesserocr_PyLTRResultIterator.tp_base = __pyx_ptype_9tesserocr_PyPageIterator;
  if (PyType_Ready(&__pyx_type_9tesserocr_PyLTRResultIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_PyLTRResultIterator.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9tesserocr_PyLTRResultIterator.tp_dict, __pyx_vtabptr_9tesserocr_PyLTRResultIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "PyLTRResultIterator", (PyObject *)&__pyx_type_9tesserocr_PyLTRResultIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_PyLTRResultIterator = &__pyx_type_9tesserocr_PyLTRResultIterator;
  __pyx_vtabptr_9tesserocr_PyResultIterator = &__pyx_vtable_9tesserocr_PyResultIterator;
  __pyx_vtable_9tesserocr_PyResultIterator.__pyx_base = *__pyx_vtabptr_9tesserocr_PyLTRResultIterator;
  __pyx_vtable_9tesserocr_PyResultIterator.createResultIterator = (struct __pyx_obj_9tesserocr_PyResultIterator *(*)(tesseract::ResultIterator *))__pyx_f_9tesserocr_16PyResultIterator_createResultIterator;
  __pyx_type_9tesserocr_PyResultIterator.tp_base = __pyx_ptype_9tesserocr_PyLTRResultIterator;
  if (PyType_Ready(&__pyx_type_9tesserocr_PyResultIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 918; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_PyResultIterator.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9tesserocr_PyResultIterator.tp_dict, __pyx_vtabptr_9tesserocr_PyResultIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 918; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "PyResultIterator", (PyObject *)&__pyx_type_9tesserocr_PyResultIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 918; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_PyResultIterator = &__pyx_type_9tesserocr_PyResultIterator;
  __pyx_vtabptr_9tesserocr_PyChoiceIterator = &__pyx_vtable_9tesserocr_PyChoiceIterator;
  __pyx_vtable_9tesserocr_PyChoiceIterator.create = (struct __pyx_obj_9tesserocr_PyChoiceIterator *(*)(tesseract::ChoiceIterator *))__pyx_f_9tesserocr_16PyChoiceIterator_create;
  if (PyType_Ready(&__pyx_type_9tesserocr_PyChoiceIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_PyChoiceIterator.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9tesserocr_PyChoiceIterator.tp_dict, __pyx_vtabptr_9tesserocr_PyChoiceIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "PyChoiceIterator", (PyObject *)&__pyx_type_9tesserocr_PyChoiceIterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_PyChoiceIterator = &__pyx_type_9tesserocr_PyChoiceIterator;
  __pyx_vtabptr_9tesserocr_PyTessBaseAPI = &__pyx_vtable_9tesserocr_PyTessBaseAPI;
  __pyx_vtable_9tesserocr_PyTessBaseAPI._init_api = (int (*)(struct __pyx_obj_9tesserocr_PyTessBaseAPI *, __pyx_t_9tesseract_cchar_t *, __pyx_t_9tesseract_cchar_t *, enum tesseract::OcrEngineMode, char **, int, GenericVector<STRING>  const *, GenericVector<STRING>  const *, bool, enum tesseract::PageSegMode))__pyx_f_9tesserocr_13PyTessBaseAPI__init_api;
  __pyx_vtable_9tesserocr_PyTessBaseAPI._end_api = (void (*)(struct __pyx_obj_9tesserocr_PyTessBaseAPI *))__pyx_f_9tesserocr_13PyTessBaseAPI__end_api;
  __pyx_vtable_9tesserocr_PyTessBaseAPI._destroy_pix = (void (*)(struct __pyx_obj_9tesserocr_PyTessBaseAPI *))__pyx_f_9tesserocr_13PyTessBaseAPI__destroy_pix;
  __pyx_vtable_9tesserocr_PyTessBaseAPI._get_renderer = (tesseract::TessResultRenderer *(*)(struct __pyx_obj_9tesserocr_PyTessBaseAPI *, __pyx_t_9tesseract_cchar_t *))__pyx_f_9tesserocr_13PyTessBaseAPI__get_renderer;
  if (PyType_Ready(&__pyx_type_9tesserocr_PyTessBaseAPI) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1020; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr_PyTessBaseAPI.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9tesserocr_PyTessBaseAPI.tp_dict, __pyx_vtabptr_9tesserocr_PyTessBaseAPI) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1020; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "PyTessBaseAPI", (PyObject *)&__pyx_type_9tesserocr_PyTessBaseAPI) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1020; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9tesserocr_PyTessBaseAPI = &__pyx_type_9tesserocr_PyTessBaseAPI;
  if (PyType_Ready(&__pyx_type_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list.tp_print = 0;
  __pyx_ptype_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list = &__pyx_type_9tesserocr___pyx_scope_struct____pyx_f_9tesserocr_pixa_to_list;
  if (PyType_Ready(&__pyx_type_9tesserocr___pyx_scope_struct_1_genexpr) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr___pyx_scope_struct_1_genexpr.tp_print = 0;
  __pyx_ptype_9tesserocr___pyx_scope_struct_1_genexpr = &__pyx_type_9tesserocr___pyx_scope_struct_1_genexpr;
  if (PyType_Ready(&__pyx_type_9tesserocr___pyx_scope_struct_2_BlockPolygon) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr___pyx_scope_struct_2_BlockPolygon.tp_print = 0;
  __pyx_ptype_9tesserocr___pyx_scope_struct_2_BlockPolygon = &__pyx_type_9tesserocr___pyx_scope_struct_2_BlockPolygon;
  if (PyType_Ready(&__pyx_type_9tesserocr___pyx_scope_struct_3_genexpr) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr___pyx_scope_struct_3_genexpr.tp_print = 0;
  __pyx_ptype_9tesserocr___pyx_scope_struct_3_genexpr = &__pyx_type_9tesserocr___pyx_scope_struct_3_genexpr;
  if (PyType_Ready(&__pyx_type_9tesserocr___pyx_scope_struct_4_genexpr) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr___pyx_scope_struct_4_genexpr.tp_print = 0;
  __pyx_ptype_9tesserocr___pyx_scope_struct_4_genexpr = &__pyx_type_9tesserocr___pyx_scope_struct_4_genexpr;
  if (PyType_Ready(&__pyx_type_9tesserocr___pyx_scope_struct_5_iterate_choices) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr___pyx_scope_struct_5_iterate_choices.tp_print = 0;
  __pyx_ptype_9tesserocr___pyx_scope_struct_5_iterate_choices = &__pyx_type_9tesserocr___pyx_scope_struct_5_iterate_choices;
  if (PyType_Ready(&__pyx_type_9tesserocr___pyx_scope_struct_6_iterate_level) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_9tesserocr___pyx_scope_struct_6_iterate_level.tp_print = 0;
  __pyx_ptype_9tesserocr___pyx_scope_struct_6_iterate_level = &__pyx_type_9tesserocr___pyx_scope_struct_6_iterate_level;
  /*--- Type import code ---*/
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif

  /* "tesserocr.pyx":21
 * """
 * 
 * __version__ = '2.0.0'             # <<<<<<<<<<<<<<
 * 
 * import os
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_version, __pyx_kp_s_2_0_0) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "tesserocr.pyx":23
 * __version__ = '2.0.0'
 * 
 * import os             # <<<<<<<<<<<<<<
 * from cStringIO import StringIO
 * from contextlib import closing
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_os, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 23; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_os, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 23; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "tesserocr.pyx":24
 * 
 * import os
 * from cStringIO import StringIO             # <<<<<<<<<<<<<<
 * from contextlib import closing
 * from os.path import abspath, join
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_StringIO);
  __Pyx_GIVEREF(__pyx_n_s_StringIO);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_StringIO);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_cStringIO, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_StringIO); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_StringIO, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":25
 * import os
 * from cStringIO import StringIO
 * from contextlib import closing             # <<<<<<<<<<<<<<
 * from os.path import abspath, join
 * try:
 */
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_closing);
  __Pyx_GIVEREF(__pyx_n_s_closing);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_closing);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_contextlib, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_closing); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_closing, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "tesserocr.pyx":26
 * from cStringIO import StringIO
 * from contextlib import closing
 * from os.path import abspath, join             # <<<<<<<<<<<<<<
 * try:
 *     from PIL import Image
 */
  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_abspath);
  __Pyx_GIVEREF(__pyx_n_s_abspath);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_abspath);
  __Pyx_INCREF(__pyx_n_s_join);
  __Pyx_GIVEREF(__pyx_n_s_join);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_join);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_os_path, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_abspath); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_abspath, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_join); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_join, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":27
 * from contextlib import closing
 * from os.path import abspath, join
 * try:             # <<<<<<<<<<<<<<
 *     from PIL import Image
 * except ImportError:
 */
  {
    __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
    __Pyx_XGOTREF(__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_4);
    __Pyx_XGOTREF(__pyx_t_5);
    /*try:*/ {

      /* "tesserocr.pyx":28
 * from os.path import abspath, join
 * try:
 *     from PIL import Image             # <<<<<<<<<<<<<<
 * except ImportError:
 *     # PIL.Image won't be supported
 */
      __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_INCREF(__pyx_n_s_Image);
      __Pyx_GIVEREF(__pyx_n_s_Image);
      PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Image);
      __pyx_t_1 = __Pyx_Import(__pyx_n_s_PIL, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Image); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
      __Pyx_GOTREF(__pyx_t_2);
      if (PyDict_SetItem(__pyx_d, __pyx_n_s_Image, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "tesserocr.pyx":27
 * from contextlib import closing
 * from os.path import abspath, join
 * try:             # <<<<<<<<<<<<<<
 *     from PIL import Image
 * except ImportError:
 */
    }
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    goto __pyx_L9_try_end;
    __pyx_L2_error:;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "tesserocr.pyx":29
 * try:
 *     from PIL import Image
 * except ImportError:             # <<<<<<<<<<<<<<
 *     # PIL.Image won't be supported
 *     pass
 */
    __pyx_t_6 = PyErr_ExceptionMatches(__pyx_builtin_ImportError);
    if (__pyx_t_6) {
      PyErr_Restore(0,0,0);
      goto __pyx_L3_exception_handled;
    }
    goto __pyx_L4_except_error;
    __pyx_L4_except_error:;

    /* "tesserocr.pyx":27
 * from contextlib import closing
 * from os.path import abspath, join
 * try:             # <<<<<<<<<<<<<<
 *     from PIL import Image
 * except ImportError:
 */
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_XGIVEREF(__pyx_t_4);
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
    goto __pyx_L1_error;
    __pyx_L3_exception_handled:;
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_XGIVEREF(__pyx_t_4);
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
    __pyx_L9_try_end:;
  }

  /* "tesserocr.pyx":38
 * 
 * # default parameters
 * setMsgSeverity(L_SEVERITY_NONE)  # suppress leptonica error messages             # <<<<<<<<<<<<<<
 * cdef TessBaseAPI _api = TessBaseAPI()
 * _api.SetVariable('debug_file', '/dev/null')  # suppress tesseract debug messages
 */
  setMsgSeverity(L_SEVERITY_NONE);

  /* "tesserocr.pyx":39
 * # default parameters
 * setMsgSeverity(L_SEVERITY_NONE)  # suppress leptonica error messages
 * cdef TessBaseAPI _api = TessBaseAPI()             # <<<<<<<<<<<<<<
 * _api.SetVariable('debug_file', '/dev/null')  # suppress tesseract debug messages
 * _api.Init(NULL, NULL)
 */
  try {
    __pyx_t_7 = tesseract::TessBaseAPI();
  } catch(...) {
    __Pyx_CppExn2PyErr();
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_v_9tesserocr__api = __pyx_t_7;

  /* "tesserocr.pyx":40
 * setMsgSeverity(L_SEVERITY_NONE)  # suppress leptonica error messages
 * cdef TessBaseAPI _api = TessBaseAPI()
 * _api.SetVariable('debug_file', '/dev/null')  # suppress tesseract debug messages             # <<<<<<<<<<<<<<
 * _api.Init(NULL, NULL)
 * cdef unicode _abs_path = abspath(join(_api.GetDatapath(), os.pardir)) + os.sep
 */
  __pyx_v_9tesserocr__api.SetVariable(__pyx_k_debug_file, __pyx_k_dev_null);

  /* "tesserocr.pyx":41
 * cdef TessBaseAPI _api = TessBaseAPI()
 * _api.SetVariable('debug_file', '/dev/null')  # suppress tesseract debug messages
 * _api.Init(NULL, NULL)             # <<<<<<<<<<<<<<
 * cdef unicode _abs_path = abspath(join(_api.GetDatapath(), os.pardir)) + os.sep
 * cdef unicode _lang_s = _api.GetInitLanguagesAsString()
 */
  __pyx_v_9tesserocr__api.Init(NULL, NULL);

  /* "tesserocr.pyx":42
 * _api.SetVariable('debug_file', '/dev/null')  # suppress tesseract debug messages
 * _api.Init(NULL, NULL)
 * cdef unicode _abs_path = abspath(join(_api.GetDatapath(), os.pardir)) + os.sep             # <<<<<<<<<<<<<<
 * cdef unicode _lang_s = _api.GetInitLanguagesAsString()
 * cdef cchar_t *_DEFAULT_PATH = _abs_path
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_abspath); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_9 = __Pyx_GetModuleGlobalName(__pyx_n_s_join); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_10 = __Pyx_PyUnicode_FromString(__pyx_v_9tesserocr__api.GetDatapath()); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_10);
  __pyx_t_11 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_11);
  __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_11, __pyx_n_s_pardir); if (unlikely(!__pyx_t_12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_12);
  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
  __pyx_t_11 = NULL;
  __pyx_t_13 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_9))) {
    __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_9);
    if (likely(__pyx_t_11)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
      __Pyx_INCREF(__pyx_t_11);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_9, function);
      __pyx_t_13 = 1;
    }
  }
  __pyx_t_14 = PyTuple_New(2+__pyx_t_13); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_14);
  if (__pyx_t_11) {
    __Pyx_GIVEREF(__pyx_t_11); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_11); __pyx_t_11 = NULL;
  }
  __Pyx_GIVEREF(__pyx_t_10);
  PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_13, __pyx_t_10);
  __Pyx_GIVEREF(__pyx_t_12);
  PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_13, __pyx_t_12);
  __pyx_t_10 = 0;
  __pyx_t_12 = 0;
  __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_14, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  __pyx_t_9 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_9)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_9);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_9) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_8); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_14 = PyTuple_New(1+1); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_14);
    __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_9); __pyx_t_9 = NULL;
    __Pyx_GIVEREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_14, 0+1, __pyx_t_8);
    __pyx_t_8 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_14, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_sep); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_14);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyNumber_Add(__pyx_t_1, __pyx_t_14); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
  if (!(likely(PyUnicode_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "unicode", Py_TYPE(__pyx_t_2)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_XGOTREF(__pyx_v_9tesserocr__abs_path);
  __Pyx_DECREF_SET(__pyx_v_9tesserocr__abs_path, ((PyObject*)__pyx_t_2));
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;

  /* "tesserocr.pyx":43
 * _api.Init(NULL, NULL)
 * cdef unicode _abs_path = abspath(join(_api.GetDatapath(), os.pardir)) + os.sep
 * cdef unicode _lang_s = _api.GetInitLanguagesAsString()             # <<<<<<<<<<<<<<
 * cdef cchar_t *_DEFAULT_PATH = _abs_path
 * cdef cchar_t *_DEFAULT_LANG = _lang_s
 */
  __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_9tesserocr__api.GetInitLanguagesAsString()); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_XGOTREF(__pyx_v_9tesserocr__lang_s);
  __Pyx_DECREF_SET(__pyx_v_9tesserocr__lang_s, ((PyObject*)__pyx_t_2));
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;

  /* "tesserocr.pyx":44
 * cdef unicode _abs_path = abspath(join(_api.GetDatapath(), os.pardir)) + os.sep
 * cdef unicode _lang_s = _api.GetInitLanguagesAsString()
 * cdef cchar_t *_DEFAULT_PATH = _abs_path             # <<<<<<<<<<<<<<
 * cdef cchar_t *_DEFAULT_LANG = _lang_s
 * _api.End()
 */
  __pyx_t_15 = __Pyx_PyObject_AsString(__pyx_v_9tesserocr__abs_path); if (unlikely((!__pyx_t_15) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_9tesserocr__DEFAULT_PATH = __pyx_t_15;

  /* "tesserocr.pyx":45
 * cdef unicode _lang_s = _api.GetInitLanguagesAsString()
 * cdef cchar_t *_DEFAULT_PATH = _abs_path
 * cdef cchar_t *_DEFAULT_LANG = _lang_s             # <<<<<<<<<<<<<<
 * _api.End()
 * TessBaseAPI.ClearPersistentCache()
 */
  __pyx_t_15 = __Pyx_PyObject_AsString(__pyx_v_9tesserocr__lang_s); if (unlikely((!__pyx_t_15) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 45; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_9tesserocr__DEFAULT_LANG = __pyx_t_15;

  /* "tesserocr.pyx":46
 * cdef cchar_t *_DEFAULT_PATH = _abs_path
 * cdef cchar_t *_DEFAULT_LANG = _lang_s
 * _api.End()             # <<<<<<<<<<<<<<
 * TessBaseAPI.ClearPersistentCache()
 * 
 */
  __pyx_v_9tesserocr__api.End();

  /* "tesserocr.pyx":47
 * cdef cchar_t *_DEFAULT_LANG = _lang_s
 * _api.End()
 * TessBaseAPI.ClearPersistentCache()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  tesseract::TessBaseAPI::ClearPersistentCache();

  /* "tesserocr.pyx":58
 *     """An enum that defines avaialble OCR engine modes."""
 * 
 *     TESSERACT_ONLY = OEM_TESSERACT_ONLY             # <<<<<<<<<<<<<<
 *     CUBE_ONLY = OEM_CUBE_ONLY
 *     TESSERACT_CUBE_COMBINED = OEM_TESSERACT_CUBE_COMBINED
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_OcrEngineMode(tesseract::OEM_TESSERACT_ONLY); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_OEM->tp_dict, __pyx_n_s_TESSERACT_ONLY, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_OEM);

  /* "tesserocr.pyx":59
 * 
 *     TESSERACT_ONLY = OEM_TESSERACT_ONLY
 *     CUBE_ONLY = OEM_CUBE_ONLY             # <<<<<<<<<<<<<<
 *     TESSERACT_CUBE_COMBINED = OEM_TESSERACT_CUBE_COMBINED
 *     DEFAULT = OEM_DEFAULT
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_OcrEngineMode(tesseract::OEM_CUBE_ONLY); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_OEM->tp_dict, __pyx_n_s_CUBE_ONLY, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_OEM);

  /* "tesserocr.pyx":60
 *     TESSERACT_ONLY = OEM_TESSERACT_ONLY
 *     CUBE_ONLY = OEM_CUBE_ONLY
 *     TESSERACT_CUBE_COMBINED = OEM_TESSERACT_CUBE_COMBINED             # <<<<<<<<<<<<<<
 *     DEFAULT = OEM_DEFAULT
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_OcrEngineMode(tesseract::OEM_TESSERACT_CUBE_COMBINED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_OEM->tp_dict, __pyx_n_s_TESSERACT_CUBE_COMBINED, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_OEM);

  /* "tesserocr.pyx":61
 *     CUBE_ONLY = OEM_CUBE_ONLY
 *     TESSERACT_CUBE_COMBINED = OEM_TESSERACT_CUBE_COMBINED
 *     DEFAULT = OEM_DEFAULT             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_OcrEngineMode(tesseract::OEM_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_OEM->tp_dict, __pyx_n_s_DEFAULT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_OEM);

  /* "tesserocr.pyx":85
 *     """
 * 
 *     OSD_ONLY = PSM_OSD_ONLY             # <<<<<<<<<<<<<<
 *     """Orientation and script detection only."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_OSD_ONLY); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_OSD_ONLY, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":88
 *     """Orientation and script detection only."""
 * 
 *     AUTO_OSD = PSM_AUTO_OSD             # <<<<<<<<<<<<<<
 *     """Automatic page segmentation with orientation and script detection. (OSD)"""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_AUTO_OSD); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_AUTO_OSD, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":91
 *     """Automatic page segmentation with orientation and script detection. (OSD)"""
 * 
 *     AUTO_ONLY = PSM_AUTO_ONLY             # <<<<<<<<<<<<<<
 *     """Automatic page segmentation, but no OSD, or OCR."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_AUTO_ONLY); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 91; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_AUTO_ONLY, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 91; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":94
 *     """Automatic page segmentation, but no OSD, or OCR."""
 * 
 *     AUTO = PSM_AUTO             # <<<<<<<<<<<<<<
 *     """Fully automatic page segmentation, but no OSD. (tesserocr default)"""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_AUTO); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_AUTO, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":97
 *     """Fully automatic page segmentation, but no OSD. (tesserocr default)"""
 * 
 *     SINGLE_COLUMN = PSM_SINGLE_COLUMN             # <<<<<<<<<<<<<<
 *     """Assume a single column of text of variable sizes."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_SINGLE_COLUMN); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_SINGLE_COLUMN, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":100
 *     """Assume a single column of text of variable sizes."""
 * 
 *     SINGLE_BLOCK_VERT_TEXT = PSM_SINGLE_BLOCK_VERT_TEXT             # <<<<<<<<<<<<<<
 *     """Assume a single uniform block of vertically aligned text."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_SINGLE_BLOCK_VERT_TEXT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_SINGLE_BLOCK_VERT_TEXT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":103
 *     """Assume a single uniform block of vertically aligned text."""
 * 
 *     SINGLE_BLOCK = PSM_SINGLE_BLOCK             # <<<<<<<<<<<<<<
 *     """Assume a single uniform block of text. (Default.)"""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_SINGLE_BLOCK); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_SINGLE_BLOCK, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":106
 *     """Assume a single uniform block of text. (Default.)"""
 * 
 *     SINGLE_LINE = PSM_SINGLE_LINE             # <<<<<<<<<<<<<<
 *     """Treat the image as a single text line."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_SINGLE_LINE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_SINGLE_LINE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":109
 *     """Treat the image as a single text line."""
 * 
 *     SINGLE_WORD = PSM_SINGLE_WORD             # <<<<<<<<<<<<<<
 *     """Treat the image as a single word."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_SINGLE_WORD); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_SINGLE_WORD, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":112
 *     """Treat the image as a single word."""
 * 
 *     CIRCLE_WORD = PSM_CIRCLE_WORD             # <<<<<<<<<<<<<<
 *     """Treat the image as a single word in a circle."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_CIRCLE_WORD); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_CIRCLE_WORD, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":115
 *     """Treat the image as a single word in a circle."""
 * 
 *     SINGLE_CHAR = PSM_SINGLE_CHAR             # <<<<<<<<<<<<<<
 *     """Treat the image as a single character."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_SINGLE_CHAR); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_SINGLE_CHAR, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":118
 *     """Treat the image as a single character."""
 * 
 *     SPARSE_TEXT = PSM_SPARSE_TEXT             # <<<<<<<<<<<<<<
 *     """Find as much text as possible in no particular order."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_SPARSE_TEXT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_SPARSE_TEXT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":121
 *     """Find as much text as possible in no particular order."""
 * 
 *     SPARSE_TEXT_OSD = PSM_SPARSE_TEXT_OSD             # <<<<<<<<<<<<<<
 *     """Sparse text with orientation and script det."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_SPARSE_TEXT_OSD); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_SPARSE_TEXT_OSD, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":124
 *     """Sparse text with orientation and script det."""
 * 
 *     RAW_LINE = PSM_RAW_LINE             # <<<<<<<<<<<<<<
 *     """Treat the image as a single text line, bypassing hacks that are Tesseract-specific."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_RAW_LINE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_RAW_LINE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":127
 *     """Treat the image as a single text line, bypassing hacks that are Tesseract-specific."""
 * 
 *     COUNT = PSM_COUNT             # <<<<<<<<<<<<<<
 *     """Number of enum entries."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(tesseract::PSM_COUNT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PSM->tp_dict, __pyx_n_s_COUNT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PSM);

  /* "tesserocr.pyx":142
 *     """
 * 
 *     BLOCK = RIL_BLOCK             # <<<<<<<<<<<<<<
 *     """of text/image/separator line."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageIteratorLevel(tesseract::RIL_BLOCK); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 142; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_RIL->tp_dict, __pyx_n_s_BLOCK, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 142; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_RIL);

  /* "tesserocr.pyx":145
 *     """of text/image/separator line."""
 * 
 *     PARA = RIL_PARA             # <<<<<<<<<<<<<<
 *     """within a block."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageIteratorLevel(tesseract::RIL_PARA); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 145; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_RIL->tp_dict, __pyx_n_s_PARA, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 145; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_RIL);

  /* "tesserocr.pyx":148
 *     """within a block."""
 * 
 *     TEXTLINE = RIL_TEXTLINE             # <<<<<<<<<<<<<<
 *     """within a paragraph."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageIteratorLevel(tesseract::RIL_TEXTLINE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_RIL->tp_dict, __pyx_n_s_TEXTLINE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_RIL);

  /* "tesserocr.pyx":151
 *     """within a paragraph."""
 * 
 *     WORD = RIL_WORD             # <<<<<<<<<<<<<<
 *     """within a textline."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageIteratorLevel(tesseract::RIL_WORD); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_RIL->tp_dict, __pyx_n_s_WORD, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_RIL);

  /* "tesserocr.pyx":154
 *     """within a textline."""
 * 
 *     SYMBOL = RIL_SYMBOL             # <<<<<<<<<<<<<<
 *     """character within a word."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_PageIteratorLevel(tesseract::RIL_SYMBOL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_RIL->tp_dict, __pyx_n_s_SYMBOL, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_RIL);

  /* "tesserocr.pyx":180
 *     """
 * 
 *     UNKNOWN = PT_UNKNOWN             # <<<<<<<<<<<<<<
 *     """Type is not yet known. Keep as the first element."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_UNKNOWN); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_UNKNOWN, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":183
 *     """Type is not yet known. Keep as the first element."""
 * 
 *     FLOWING_TEXT = PT_FLOWING_TEXT             # <<<<<<<<<<<<<<
 *     """Text that lives inside a column."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_FLOWING_TEXT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_FLOWING_TEXT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":186
 *     """Text that lives inside a column."""
 * 
 *     HEADING_TEXT = PT_HEADING_TEXT             # <<<<<<<<<<<<<<
 *     """Text that spans more than one column."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_HEADING_TEXT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_HEADING_TEXT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":189
 *     """Text that spans more than one column."""
 * 
 *     PULLOUT_TEXT = PT_PULLOUT_TEXT             # <<<<<<<<<<<<<<
 *     """Text that is in a cross-column pull-out region."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_PULLOUT_TEXT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_PULLOUT_TEXT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":192
 *     """Text that is in a cross-column pull-out region."""
 * 
 *     EQUATION = PT_EQUATION             # <<<<<<<<<<<<<<
 *     """Partition belonging to an equation region."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_EQUATION); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_EQUATION, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":195
 *     """Partition belonging to an equation region."""
 * 
 *     INLINE_EQUATION = PT_INLINE_EQUATION             # <<<<<<<<<<<<<<
 *     """Partition has inline equation."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_INLINE_EQUATION); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 195; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_INLINE_EQUATION, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 195; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":198
 *     """Partition has inline equation."""
 * 
 *     TABLE = PT_TABLE             # <<<<<<<<<<<<<<
 *     """Partition belonging to a table region."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_TABLE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 198; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_TABLE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 198; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":201
 *     """Partition belonging to a table region."""
 * 
 *     VERTICAL_TEXT = PT_VERTICAL_TEXT             # <<<<<<<<<<<<<<
 *     """Text-line runs vertically."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_VERTICAL_TEXT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_VERTICAL_TEXT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":204
 *     """Text-line runs vertically."""
 * 
 *     CAPTION_TEXT = PT_CAPTION_TEXT             # <<<<<<<<<<<<<<
 *     """Text that belongs to an image."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_CAPTION_TEXT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_CAPTION_TEXT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":207
 *     """Text that belongs to an image."""
 * 
 *     FLOWING_IMAGE = PT_FLOWING_IMAGE             # <<<<<<<<<<<<<<
 *     """Image that lives inside a column."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_FLOWING_IMAGE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_FLOWING_IMAGE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":210
 *     """Image that lives inside a column."""
 * 
 *     HEADING_IMAGE = PT_HEADING_IMAGE             # <<<<<<<<<<<<<<
 *     """Image that spans more than one column."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_HEADING_IMAGE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_HEADING_IMAGE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":213
 *     """Image that spans more than one column."""
 * 
 *     PULLOUT_IMAGE = PT_PULLOUT_IMAGE             # <<<<<<<<<<<<<<
 *     """Image that is in a cross-column pull-out region."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_PULLOUT_IMAGE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_PULLOUT_IMAGE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":216
 *     """Image that is in a cross-column pull-out region."""
 * 
 *     HORZ_LINE = PT_HORZ_LINE             # <<<<<<<<<<<<<<
 *     """Horizontal Line."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_HORZ_LINE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_HORZ_LINE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":219
 *     """Horizontal Line."""
 * 
 *     VERT_LINE = PT_VERT_LINE             # <<<<<<<<<<<<<<
 *     """Vertical Line."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_VERT_LINE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_VERT_LINE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":222
 *     """Vertical Line."""
 * 
 *     NOISE = PT_NOISE             # <<<<<<<<<<<<<<
 *     """Lies outside of any column."""
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_NOISE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_NOISE, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":225
 *     """Lies outside of any column."""
 * 
 *     COUNT = PT_COUNT             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__PolyBlockType(PT_COUNT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PT->tp_dict, __pyx_n_s_COUNT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PT);

  /* "tesserocr.pyx":231
 *     """Enum for orientation options."""
 * 
 *     PAGE_UP = ORIENTATION_PAGE_UP             # <<<<<<<<<<<<<<
 *     PAGE_RIGHT = ORIENTATION_PAGE_RIGHT
 *     PAGE_DOWN = ORIENTATION_PAGE_DOWN
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_Orientation(tesseract::ORIENTATION_PAGE_UP); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_Orientation->tp_dict, __pyx_n_s_PAGE_UP, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_Orientation);

  /* "tesserocr.pyx":232
 * 
 *     PAGE_UP = ORIENTATION_PAGE_UP
 *     PAGE_RIGHT = ORIENTATION_PAGE_RIGHT             # <<<<<<<<<<<<<<
 *     PAGE_DOWN = ORIENTATION_PAGE_DOWN
 *     PAGE_LEFT = ORIENTATION_PAGE_LEFT
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_Orientation(tesseract::ORIENTATION_PAGE_RIGHT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_Orientation->tp_dict, __pyx_n_s_PAGE_RIGHT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_Orientation);

  /* "tesserocr.pyx":233
 *     PAGE_UP = ORIENTATION_PAGE_UP
 *     PAGE_RIGHT = ORIENTATION_PAGE_RIGHT
 *     PAGE_DOWN = ORIENTATION_PAGE_DOWN             # <<<<<<<<<<<<<<
 *     PAGE_LEFT = ORIENTATION_PAGE_LEFT
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_Orientation(tesseract::ORIENTATION_PAGE_DOWN); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_Orientation->tp_dict, __pyx_n_s_PAGE_DOWN, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_Orientation);

  /* "tesserocr.pyx":234
 *     PAGE_RIGHT = ORIENTATION_PAGE_RIGHT
 *     PAGE_DOWN = ORIENTATION_PAGE_DOWN
 *     PAGE_LEFT = ORIENTATION_PAGE_LEFT             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_Orientation(tesseract::ORIENTATION_PAGE_LEFT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_Orientation->tp_dict, __pyx_n_s_PAGE_LEFT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_Orientation);

  /* "tesserocr.pyx":240
 *     """Enum for writing direction options."""
 * 
 *     LEFT_TO_RIGHT = WRITING_DIRECTION_LEFT_TO_RIGHT             # <<<<<<<<<<<<<<
 *     RIGHT_TO_LEFT = WRITING_DIRECTION_RIGHT_TO_LEFT
 *     TOP_TO_BOTTOM = WRITING_DIRECTION_TOP_TO_BOTTOM
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_WritingDirection(tesseract::WRITING_DIRECTION_LEFT_TO_RIGHT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_WritingDirection->tp_dict, __pyx_n_s_LEFT_TO_RIGHT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_WritingDirection);

  /* "tesserocr.pyx":241
 * 
 *     LEFT_TO_RIGHT = WRITING_DIRECTION_LEFT_TO_RIGHT
 *     RIGHT_TO_LEFT = WRITING_DIRECTION_RIGHT_TO_LEFT             # <<<<<<<<<<<<<<
 *     TOP_TO_BOTTOM = WRITING_DIRECTION_TOP_TO_BOTTOM
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_WritingDirection(tesseract::WRITING_DIRECTION_RIGHT_TO_LEFT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_WritingDirection->tp_dict, __pyx_n_s_RIGHT_TO_LEFT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_WritingDirection);

  /* "tesserocr.pyx":242
 *     LEFT_TO_RIGHT = WRITING_DIRECTION_LEFT_TO_RIGHT
 *     RIGHT_TO_LEFT = WRITING_DIRECTION_RIGHT_TO_LEFT
 *     TOP_TO_BOTTOM = WRITING_DIRECTION_TOP_TO_BOTTOM             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_WritingDirection(tesseract::WRITING_DIRECTION_TOP_TO_BOTTOM); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_WritingDirection->tp_dict, __pyx_n_s_TOP_TO_BOTTOM, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_WritingDirection);

  /* "tesserocr.pyx":248
 *     """Enum for text line order options."""
 * 
 *     LEFT_TO_RIGHT = TEXTLINE_ORDER_LEFT_TO_RIGHT             # <<<<<<<<<<<<<<
 *     RIGHT_TO_LEFT = TEXTLINE_ORDER_RIGHT_TO_LEFT
 *     TOP_TO_BOTTOM = TEXTLINE_ORDER_TOP_TO_BOTTOM
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_TextlineOrder(tesseract::TEXTLINE_ORDER_LEFT_TO_RIGHT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_TextlineOrder->tp_dict, __pyx_n_s_LEFT_TO_RIGHT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_TextlineOrder);

  /* "tesserocr.pyx":249
 * 
 *     LEFT_TO_RIGHT = TEXTLINE_ORDER_LEFT_TO_RIGHT
 *     RIGHT_TO_LEFT = TEXTLINE_ORDER_RIGHT_TO_LEFT             # <<<<<<<<<<<<<<
 *     TOP_TO_BOTTOM = TEXTLINE_ORDER_TOP_TO_BOTTOM
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_TextlineOrder(tesseract::TEXTLINE_ORDER_RIGHT_TO_LEFT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_TextlineOrder->tp_dict, __pyx_n_s_RIGHT_TO_LEFT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_TextlineOrder);

  /* "tesserocr.pyx":250
 *     LEFT_TO_RIGHT = TEXTLINE_ORDER_LEFT_TO_RIGHT
 *     RIGHT_TO_LEFT = TEXTLINE_ORDER_RIGHT_TO_LEFT
 *     TOP_TO_BOTTOM = TEXTLINE_ORDER_TOP_TO_BOTTOM             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_TextlineOrder(tesseract::TEXTLINE_ORDER_TOP_TO_BOTTOM); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_TextlineOrder->tp_dict, __pyx_n_s_TOP_TO_BOTTOM, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_TextlineOrder);

  /* "tesserocr.pyx":256
 *     """Enum for justification options."""
 * 
 *     UNKNOWN = JUSTIFICATION_UNKNOWN             # <<<<<<<<<<<<<<
 *     LEFT = JUSTIFICATION_LEFT
 *     CENTER = JUSTIFICATION_CENTER
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_ParagraphJustification(tesseract::JUSTIFICATION_UNKNOWN); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_Justification->tp_dict, __pyx_n_s_UNKNOWN, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_Justification);

  /* "tesserocr.pyx":257
 * 
 *     UNKNOWN = JUSTIFICATION_UNKNOWN
 *     LEFT = JUSTIFICATION_LEFT             # <<<<<<<<<<<<<<
 *     CENTER = JUSTIFICATION_CENTER
 *     RIGHT = JUSTIFICATION_RIGHT
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_ParagraphJustification(tesseract::JUSTIFICATION_LEFT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_Justification->tp_dict, __pyx_n_s_LEFT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_Justification);

  /* "tesserocr.pyx":258
 *     UNKNOWN = JUSTIFICATION_UNKNOWN
 *     LEFT = JUSTIFICATION_LEFT
 *     CENTER = JUSTIFICATION_CENTER             # <<<<<<<<<<<<<<
 *     RIGHT = JUSTIFICATION_RIGHT
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_ParagraphJustification(tesseract::JUSTIFICATION_CENTER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 258; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_Justification->tp_dict, __pyx_n_s_CENTER, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 258; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_Justification);

  /* "tesserocr.pyx":259
 *     LEFT = JUSTIFICATION_LEFT
 *     CENTER = JUSTIFICATION_CENTER
 *     RIGHT = JUSTIFICATION_RIGHT             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__tesseract_3a__3a_ParagraphJustification(tesseract::JUSTIFICATION_RIGHT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_Justification->tp_dict, __pyx_n_s_RIGHT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_Justification);

  /* "tesserocr.pyx":272
 *     """
 * 
 *     NEUTRAL = DIR_NEUTRAL             # <<<<<<<<<<<<<<
 *     """Text contains only neutral characters."""
 *     LEFT_TO_RIGHT = DIR_LEFT_TO_RIGHT
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__StrongScriptDirection(DIR_NEUTRAL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_DIR->tp_dict, __pyx_n_s_NEUTRAL, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_DIR);

  /* "tesserocr.pyx":274
 *     NEUTRAL = DIR_NEUTRAL
 *     """Text contains only neutral characters."""
 *     LEFT_TO_RIGHT = DIR_LEFT_TO_RIGHT             # <<<<<<<<<<<<<<
 *     """Text contains no Right-to-Left characters."""
 *     RIGHT_TO_LEFT = DIR_RIGHT_TO_LEFT
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__StrongScriptDirection(DIR_LEFT_TO_RIGHT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_DIR->tp_dict, __pyx_n_s_LEFT_TO_RIGHT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_DIR);

  /* "tesserocr.pyx":276
 *     LEFT_TO_RIGHT = DIR_LEFT_TO_RIGHT
 *     """Text contains no Right-to-Left characters."""
 *     RIGHT_TO_LEFT = DIR_RIGHT_TO_LEFT             # <<<<<<<<<<<<<<
 *     """Text contains no Left-to-Right characters."""
 *     MIX = DIR_MIX
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__StrongScriptDirection(DIR_RIGHT_TO_LEFT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_DIR->tp_dict, __pyx_n_s_RIGHT_TO_LEFT, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_DIR);

  /* "tesserocr.pyx":278
 *     RIGHT_TO_LEFT = DIR_RIGHT_TO_LEFT
 *     """Text contains no Left-to-Right characters."""
 *     MIX = DIR_MIX             # <<<<<<<<<<<<<<
 *     """Text contains a mixture of left-to-right
 *     and right-to-left characters."""
 */
  __pyx_t_2 = __Pyx_PyInt_From_enum__StrongScriptDirection(DIR_MIX); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_DIR->tp_dict, __pyx_n_s_MIX, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_DIR);

  /* "tesserocr.pyx":1004
 * 
 * 
 * def iterate_choices(citerator):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate :class:`PyChoiceIterator`."""
 *     yield citerator
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9tesserocr_1iterate_choices, NULL, __pyx_n_s_tesserocr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_iterate_choices, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":1011
 * 
 * 
 * def iterate_level(iterator, PageIteratorLevel level):             # <<<<<<<<<<<<<<
 *     """Helper generator function to iterate a :class:`PyPageIterator`
 *     level.
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9tesserocr_4iterate_level, NULL, __pyx_n_s_tesserocr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_iterate_level, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":1066
 * 
 *     @staticmethod
 *     def Version():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.Version()
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9tesserocr_13PyTessBaseAPI_1Version, NULL, __pyx_n_s_tesserocr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);

  /* "tesserocr.pyx":1065
 *         Pix *_pix
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def Version():
 *         return TessBaseAPI.Version()
 */
  __pyx_t_14 = PyTuple_New(1); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_14);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_staticmethod, __pyx_t_14, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PyTessBaseAPI->tp_dict, __pyx_n_s_Version, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PyTessBaseAPI);

  /* "tesserocr.pyx":1066
 * 
 *     @staticmethod
 *     def Version():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.Version()
 * 
 */
  __pyx_t_2 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9tesserocr_PyTessBaseAPI, __pyx_n_s_Version); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);

  /* "tesserocr.pyx":1065
 *         Pix *_pix
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def Version():
 *         return TessBaseAPI.Version()
 */
  __pyx_t_14 = PyTuple_New(1); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_14);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_staticmethod, __pyx_t_14, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PyTessBaseAPI->tp_dict, __pyx_n_s_Version, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PyTessBaseAPI);

  /* "tesserocr.pyx":1070
 * 
 *     @staticmethod
 *     def ClearPersistentCache():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9tesserocr_13PyTessBaseAPI_3ClearPersistentCache, NULL, __pyx_n_s_tesserocr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);

  /* "tesserocr.pyx":1069
 *         return TessBaseAPI.Version()
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def ClearPersistentCache():
 *         return TessBaseAPI.ClearPersistentCache()
 */
  __pyx_t_14 = PyTuple_New(1); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_14);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_staticmethod, __pyx_t_14, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PyTessBaseAPI->tp_dict, __pyx_n_s_ClearPersistentCache, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PyTessBaseAPI);

  /* "tesserocr.pyx":1070
 * 
 *     @staticmethod
 *     def ClearPersistentCache():             # <<<<<<<<<<<<<<
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 */
  __pyx_t_2 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9tesserocr_PyTessBaseAPI, __pyx_n_s_ClearPersistentCache); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);

  /* "tesserocr.pyx":1069
 *         return TessBaseAPI.Version()
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def ClearPersistentCache():
 *         return TessBaseAPI.ClearPersistentCache()
 */
  __pyx_t_14 = PyTuple_New(1); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_14);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_staticmethod, __pyx_t_14, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9tesserocr_PyTessBaseAPI->tp_dict, __pyx_n_s_ClearPersistentCache, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9tesserocr_PyTessBaseAPI);

  /* "tesserocr.pyx":1073
 *         return TessBaseAPI.ClearPersistentCache()
 * 
 *     def __cinit__(self, cchar_t *path=_DEFAULT_PATH,             # <<<<<<<<<<<<<<
 *                   cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                   bool init=True):
 */
  __pyx_k__6 = __pyx_v_9tesserocr__DEFAULT_PATH;

  /* "tesserocr.pyx":1074
 * 
 *     def __cinit__(self, cchar_t *path=_DEFAULT_PATH,
 *                   cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                   bool init=True):
 *         with nogil:
 */
  __pyx_k__7 = __pyx_v_9tesserocr__DEFAULT_LANG;
  __pyx_k__8 = tesseract::PSM_AUTO;

  /* "tesserocr.pyx":1204
 *         return None
 * 
 *     def InitFull(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,             # <<<<<<<<<<<<<<
 *              OcrEngineMode oem=OEM_DEFAULT, list configs=[], dict variables={},
 *              bool set_only_non_debug_params=False):
 */
  __pyx_k__11 = __pyx_v_9tesserocr__DEFAULT_PATH;
  __pyx_k__12 = __pyx_v_9tesserocr__DEFAULT_LANG;

  /* "tesserocr.pyx":1205
 * 
 *     def InitFull(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,
 *              OcrEngineMode oem=OEM_DEFAULT, list configs=[], dict variables={},             # <<<<<<<<<<<<<<
 *              bool set_only_non_debug_params=False):
 *         """Initialize the API with the given parameters (advanced).
 */
  __pyx_k__13 = tesseract::OEM_DEFAULT;
  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k__9 = ((PyObject*)__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k__10 = ((PyObject*)__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;

  /* "tesserocr.pyx":1267
 *                 free(configs_)
 * 
 *     def Init(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,             # <<<<<<<<<<<<<<
 *              OcrEngineMode oem=OEM_DEFAULT):
 *         """Initialize the API with the given data path, language and OCR engine mode.
 */
  __pyx_k__15 = __pyx_v_9tesserocr__DEFAULT_PATH;
  __pyx_k__16 = __pyx_v_9tesserocr__DEFAULT_LANG;

  /* "tesserocr.pyx":1268
 * 
 *     def Init(self, cchar_t *path=_DEFAULT_PATH, cchar_t *lang=_DEFAULT_LANG,
 *              OcrEngineMode oem=OEM_DEFAULT):             # <<<<<<<<<<<<<<
 *         """Initialize the API with the given data path, language and OCR engine mode.
 * 
 */
  __pyx_k__17 = tesseract::OEM_DEFAULT;

  /* "tesserocr.pyx":2106
 * 
 * 
 * def image_to_text(image, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                    cchar_t *path=_DEFAULT_PATH):
 *     """Recognize OCR text from an image object.
 */
  __pyx_k__31 = __pyx_v_9tesserocr__DEFAULT_LANG;
  __pyx_k__32 = tesseract::PSM_AUTO;

  /* "tesserocr.pyx":2107
 * 
 * def image_to_text(image, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                    cchar_t *path=_DEFAULT_PATH):             # <<<<<<<<<<<<<<
 *     """Recognize OCR text from an image object.
 * 
 */
  __pyx_k__33 = __pyx_v_9tesserocr__DEFAULT_PATH;

  /* "tesserocr.pyx":2106
 * 
 * 
 * def image_to_text(image, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                    cchar_t *path=_DEFAULT_PATH):
 *     """Recognize OCR text from an image object.
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9tesserocr_7image_to_text, NULL, __pyx_n_s_tesserocr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_image_to_text, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":2150
 * 
 * 
 * def file_to_text(cchar_t *filename, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                  cchar_t *path=_DEFAULT_PATH):
 *     """Extract OCR text from an image file.
 */
  __pyx_k__36 = __pyx_v_9tesserocr__DEFAULT_LANG;
  __pyx_k__37 = tesseract::PSM_AUTO;

  /* "tesserocr.pyx":2151
 * 
 * def file_to_text(cchar_t *filename, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,
 *                  cchar_t *path=_DEFAULT_PATH):             # <<<<<<<<<<<<<<
 *     """Extract OCR text from an image file.
 * 
 */
  __pyx_k__38 = __pyx_v_9tesserocr__DEFAULT_PATH;

  /* "tesserocr.pyx":2150
 * 
 * 
 * def file_to_text(cchar_t *filename, cchar_t *lang=_DEFAULT_LANG, PageSegMode psm=PSM_AUTO,             # <<<<<<<<<<<<<<
 *                  cchar_t *path=_DEFAULT_PATH):
 *     """Extract OCR text from an image file.
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9tesserocr_9file_to_text, NULL, __pyx_n_s_tesserocr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_file_to_text, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":2187
 * 
 * 
 * def tesseract_version():             # <<<<<<<<<<<<<<
 *     """Return tesseract-ocr and leptonica version info"""
 *     version_str = u"tesseract {}\n {}\n  {}"
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9tesserocr_11tesseract_version, NULL, __pyx_n_s_tesserocr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tesseract_version, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":2196
 * 
 * 
 * def get_languages(cchar_t *path=_DEFAULT_PATH):             # <<<<<<<<<<<<<<
 *     """Return available languages in the given path.
 * 
 */
  __pyx_k__41 = __pyx_v_9tesserocr__DEFAULT_PATH;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9tesserocr_13get_languages, NULL, __pyx_n_s_tesserocr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_languages, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "tesserocr.pyx":1
 * #!python             # <<<<<<<<<<<<<<
 * #cython: c_string_type=unicode, c_string_encoding=utf-8
 * """Python wrapper around the Tesseract-OCR 3.02+ C++ API
 */
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_XDECREF(__pyx_t_14);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init tesserocr", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init tesserocr");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* --- Runtime support code --- */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_Restore(type, value, tb);
#endif
}
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(type, value, tb);
#endif
}

#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_COMPILING_IN_CPYTHON
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
#else
    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
    PyErr_SetExcInfo(*type, *value, *tb);
#endif
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}

static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
#else
    PyErr_GetExcInfo(type, value, tb);
#endif
}
static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(type, value, tb);
#endif
}

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
    PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
}

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

static void __Pyx_RaiseArgumentTypeInvalid(const char* name, PyObject *obj, PyTypeObject *type) {
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
}
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (likely(Py_TYPE(obj) == type)) return 1;
        #if PY_MAJOR_VERSION == 2
        else if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(PyObject_TypeCheck(obj, type))) return 1;
    }
    __Pyx_RaiseArgumentTypeInvalid(name, obj, type);
    return 0;
}

static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(exc_type == PyExc_StopIteration) || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
    PyObject *method, *result = NULL;
    method = __Pyx_PyObject_GetAttrStr(obj, method_name);
    if (unlikely(!method)) goto bad;
#if CYTHON_COMPILING_IN_CPYTHON
    if (likely(PyMethod_Check(method))) {
        PyObject *self = PyMethod_GET_SELF(method);
        if (likely(self)) {
            PyObject *function = PyMethod_GET_FUNCTION(method);
            result = __Pyx_PyObject_CallOneArg(function, self);
            Py_DECREF(method);
            return result;
        }
    }
#endif
    result = __Pyx_PyObject_CallNoArg(method);
    Py_DECREF(method);
bad:
    return result;
}

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    } else {
        return __Pyx_IterFinish();
    }
    return 0;
}

static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
}

static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
    if (t == Py_None) {
      __Pyx_RaiseNoneNotIterableError();
    } else if (PyTuple_GET_SIZE(t) < index) {
      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
    } else {
      __Pyx_RaiseTooManyValuesError(index);
    }
}

static CYTHON_INLINE int __Pyx_unpack_tuple2(PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2,
                                             int is_tuple, int has_known_size, int decref_tuple) {
    Py_ssize_t index;
    PyObject *value1 = NULL, *value2 = NULL, *iter = NULL;
    if (!is_tuple && unlikely(!PyTuple_Check(tuple))) {
        iternextfunc iternext;
        iter = PyObject_GetIter(tuple);
        if (unlikely(!iter)) goto bad;
        if (decref_tuple) { Py_DECREF(tuple); tuple = NULL; }
        iternext = Py_TYPE(iter)->tp_iternext;
        value1 = iternext(iter); if (unlikely(!value1)) { index = 0; goto unpacking_failed; }
        value2 = iternext(iter); if (unlikely(!value2)) { index = 1; goto unpacking_failed; }
        if (!has_known_size && unlikely(__Pyx_IternextUnpackEndCheck(iternext(iter), 2))) goto bad;
        Py_DECREF(iter);
    } else {
        if (!has_known_size && unlikely(PyTuple_GET_SIZE(tuple) != 2)) {
            __Pyx_UnpackTupleError(tuple, 2);
            goto bad;
        }
#if CYTHON_COMPILING_IN_PYPY
        value1 = PySequence_ITEM(tuple, 0);
        if (unlikely(!value1)) goto bad;
        value2 = PySequence_ITEM(tuple, 1);
        if (unlikely(!value2)) goto bad;
#else
        value1 = PyTuple_GET_ITEM(tuple, 0);
        value2 = PyTuple_GET_ITEM(tuple, 1);
        Py_INCREF(value1);
        Py_INCREF(value2);
#endif
        if (decref_tuple) { Py_DECREF(tuple); }
    }
    *pvalue1 = value1;
    *pvalue2 = value2;
    return 0;
unpacking_failed:
    if (!has_known_size && __Pyx_IterFinish() == 0)
        __Pyx_RaiseNeedMoreValuesError(index);
bad:
    Py_XDECREF(iter);
    Py_XDECREF(value1);
    Py_XDECREF(value2);
    if (decref_tuple) { Py_XDECREF(tuple); }
    return -1;
}

static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* iterable, int is_dict, PyObject* method_name,
                                                   Py_ssize_t* p_orig_length, int* p_source_is_dict) {
    is_dict = is_dict || likely(PyDict_CheckExact(iterable));
    *p_source_is_dict = is_dict;
#if !CYTHON_COMPILING_IN_PYPY
    if (is_dict) {
        *p_orig_length = PyDict_Size(iterable);
        Py_INCREF(iterable);
        return iterable;
    }
#endif
    *p_orig_length = 0;
    if (method_name) {
        PyObject* iter;
        iterable = __Pyx_PyObject_CallMethod0(iterable, method_name);
        if (!iterable)
            return NULL;
#if !CYTHON_COMPILING_IN_PYPY
        if (PyTuple_CheckExact(iterable) || PyList_CheckExact(iterable))
            return iterable;
#endif
        iter = PyObject_GetIter(iterable);
        Py_DECREF(iterable);
        return iter;
    }
    return PyObject_GetIter(iterable);
}
static CYTHON_INLINE int __Pyx_dict_iter_next(
        PyObject* iter_obj, CYTHON_NCP_UNUSED Py_ssize_t orig_length, CYTHON_NCP_UNUSED Py_ssize_t* ppos,
        PyObject** pkey, PyObject** pvalue, PyObject** pitem, int source_is_dict) {
    PyObject* next_item;
#if !CYTHON_COMPILING_IN_PYPY
    if (source_is_dict) {
        PyObject *key, *value;
        if (unlikely(orig_length != PyDict_Size(iter_obj))) {
            PyErr_SetString(PyExc_RuntimeError, "dictionary changed size during iteration");
            return -1;
        }
        if (unlikely(!PyDict_Next(iter_obj, ppos, &key, &value))) {
            return 0;
        }
        if (pitem) {
            PyObject* tuple = PyTuple_New(2);
            if (unlikely(!tuple)) {
                return -1;
            }
            Py_INCREF(key);
            Py_INCREF(value);
            PyTuple_SET_ITEM(tuple, 0, key);
            PyTuple_SET_ITEM(tuple, 1, value);
            *pitem = tuple;
        } else {
            if (pkey) {
                Py_INCREF(key);
                *pkey = key;
            }
            if (pvalue) {
                Py_INCREF(value);
                *pvalue = value;
            }
        }
        return 1;
    } else if (PyTuple_CheckExact(iter_obj)) {
        Py_ssize_t pos = *ppos;
        if (unlikely(pos >= PyTuple_GET_SIZE(iter_obj))) return 0;
        *ppos = pos + 1;
        next_item = PyTuple_GET_ITEM(iter_obj, pos);
        Py_INCREF(next_item);
    } else if (PyList_CheckExact(iter_obj)) {
        Py_ssize_t pos = *ppos;
        if (unlikely(pos >= PyList_GET_SIZE(iter_obj))) return 0;
        *ppos = pos + 1;
        next_item = PyList_GET_ITEM(iter_obj, pos);
        Py_INCREF(next_item);
    } else
#endif
    {
        next_item = PyIter_Next(iter_obj);
        if (unlikely(!next_item)) {
            return __Pyx_IterFinish();
        }
    }
    if (pitem) {
        *pitem = next_item;
    } else if (pkey && pvalue) {
        if (__Pyx_unpack_tuple2(next_item, pkey, pvalue, source_is_dict, source_is_dict, 1))
            return -1;
    } else if (pkey) {
        *pkey = next_item;
    } else {
        *pvalue = next_item;
    }
    return 1;
}

#if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long x;
        long a = PyInt_AS_LONG(op1);
            x = (long)((unsigned long)a + b);
            if (likely((x^a) >= 0 || (x^b) >= 0))
                return PyInt_FromLong(x);
            return PyLong_Type.tp_as_number->nb_add(op1, op2);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS && PY_MAJOR_VERSION >= 3
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
            }
        }
                x = a + b;
            return PyLong_FromLong(x);
        long_long:
                llx = lla + llb;
            return PyLong_FromLongLong(llx);
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            double result;
            PyFPE_START_PROTECT("add", return NULL)
            result = ((double)a) + (double)b;
            PyFPE_END_PROTECT(result)
            return PyFloat_FromDouble(result);
    }
    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
}
#endif

static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback, CYTHON_UNUSED int nogil) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
#ifdef WITH_THREAD
    PyGILState_STATE state;
    if (nogil)
        state = PyGILState_Ensure();
#endif
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
#ifdef WITH_THREAD
    if (nogil)
        PyGILState_Release(state);
#endif
}

static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name) {
    PyObject *result;
    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
    if (!result)
        result = __Pyx_GetModuleGlobalName(name);
    return result;
}

static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        __pyx_d,      /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_OcrEngineMode(enum tesseract::OcrEngineMode value) {
    const enum tesseract::OcrEngineMode neg_one = (enum tesseract::OcrEngineMode) -1, const_zero = (enum tesseract::OcrEngineMode) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum tesseract::OcrEngineMode) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::OcrEngineMode) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum tesseract::OcrEngineMode) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum tesseract::OcrEngineMode) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::OcrEngineMode) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum tesseract::OcrEngineMode),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_PageSegMode(enum tesseract::PageSegMode value) {
    const enum tesseract::PageSegMode neg_one = (enum tesseract::PageSegMode) -1, const_zero = (enum tesseract::PageSegMode) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum tesseract::PageSegMode) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::PageSegMode) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum tesseract::PageSegMode) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum tesseract::PageSegMode) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::PageSegMode) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum tesseract::PageSegMode),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_PageIteratorLevel(enum tesseract::PageIteratorLevel value) {
    const enum tesseract::PageIteratorLevel neg_one = (enum tesseract::PageIteratorLevel) -1, const_zero = (enum tesseract::PageIteratorLevel) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum tesseract::PageIteratorLevel) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::PageIteratorLevel) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum tesseract::PageIteratorLevel) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum tesseract::PageIteratorLevel) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::PageIteratorLevel) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum tesseract::PageIteratorLevel),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__PolyBlockType(enum PolyBlockType value) {
    const enum PolyBlockType neg_one = (enum PolyBlockType) -1, const_zero = (enum PolyBlockType) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum PolyBlockType) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum PolyBlockType) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum PolyBlockType) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum PolyBlockType) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum PolyBlockType) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum PolyBlockType),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_Orientation(enum tesseract::Orientation value) {
    const enum tesseract::Orientation neg_one = (enum tesseract::Orientation) -1, const_zero = (enum tesseract::Orientation) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum tesseract::Orientation) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::Orientation) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum tesseract::Orientation) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum tesseract::Orientation) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::Orientation) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum tesseract::Orientation),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_WritingDirection(enum tesseract::WritingDirection value) {
    const enum tesseract::WritingDirection neg_one = (enum tesseract::WritingDirection) -1, const_zero = (enum tesseract::WritingDirection) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum tesseract::WritingDirection) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::WritingDirection) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum tesseract::WritingDirection) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum tesseract::WritingDirection) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::WritingDirection) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum tesseract::WritingDirection),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_TextlineOrder(enum tesseract::TextlineOrder value) {
    const enum tesseract::TextlineOrder neg_one = (enum tesseract::TextlineOrder) -1, const_zero = (enum tesseract::TextlineOrder) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum tesseract::TextlineOrder) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::TextlineOrder) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum tesseract::TextlineOrder) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum tesseract::TextlineOrder) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::TextlineOrder) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum tesseract::TextlineOrder),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__tesseract_3a__3a_ParagraphJustification(enum tesseract::ParagraphJustification value) {
    const enum tesseract::ParagraphJustification neg_one = (enum tesseract::ParagraphJustification) -1, const_zero = (enum tesseract::ParagraphJustification) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum tesseract::ParagraphJustification) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::ParagraphJustification) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum tesseract::ParagraphJustification) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum tesseract::ParagraphJustification) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum tesseract::ParagraphJustification) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum tesseract::ParagraphJustification),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__StrongScriptDirection(enum StrongScriptDirection value) {
    const enum StrongScriptDirection neg_one = (enum StrongScriptDirection) -1, const_zero = (enum StrongScriptDirection) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum StrongScriptDirection) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum StrongScriptDirection) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(enum StrongScriptDirection) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(enum StrongScriptDirection) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum StrongScriptDirection) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum StrongScriptDirection),
                                     little, !is_unsigned);
    }
}

#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

static CYTHON_INLINE enum tesseract::PageIteratorLevel __Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(PyObject *x) {
    const enum tesseract::PageIteratorLevel neg_one = (enum tesseract::PageIteratorLevel) -1, const_zero = (enum tesseract::PageIteratorLevel) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum tesseract::PageIteratorLevel) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum tesseract::PageIteratorLevel) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum tesseract::PageIteratorLevel) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) >= 2 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) (((((enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) >= 3 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) (((((((enum tesseract::PageIteratorLevel)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) >= 4 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) (((((((((enum tesseract::PageIteratorLevel)digits[3]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum tesseract::PageIteratorLevel) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum tesseract::PageIteratorLevel) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::PageIteratorLevel, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(enum tesseract::PageIteratorLevel) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::PageIteratorLevel, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum tesseract::PageIteratorLevel) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, sdigit, -(sdigit) digits[0])
                case  1: __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 2 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) (((enum tesseract::PageIteratorLevel)-1)*(((((enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 2 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) ((((((enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 3 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) (((enum tesseract::PageIteratorLevel)-1)*(((((((enum tesseract::PageIteratorLevel)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 3 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) ((((((((enum tesseract::PageIteratorLevel)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 4 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) (((enum tesseract::PageIteratorLevel)-1)*(((((((((enum tesseract::PageIteratorLevel)digits[3]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum tesseract::PageIteratorLevel) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageIteratorLevel, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageIteratorLevel) - 1 > 4 * PyLong_SHIFT) {
                            return (enum tesseract::PageIteratorLevel) ((((((((((enum tesseract::PageIteratorLevel)digits[3]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageIteratorLevel)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum tesseract::PageIteratorLevel) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::PageIteratorLevel, long, PyLong_AsLong(x))
            } else if (sizeof(enum tesseract::PageIteratorLevel) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::PageIteratorLevel, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum tesseract::PageIteratorLevel val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum tesseract::PageIteratorLevel) -1;
        }
    } else {
        enum tesseract::PageIteratorLevel val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (enum tesseract::PageIteratorLevel) -1;
        val = __Pyx_PyInt_As_enum__tesseract_3a__3a_PageIteratorLevel(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum tesseract::PageIteratorLevel");
    return (enum tesseract::PageIteratorLevel) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum tesseract::PageIteratorLevel");
    return (enum tesseract::PageIteratorLevel) -1;
}

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, -(sdigit) digits[0])
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

static CYTHON_INLINE enum tesseract::PageSegMode __Pyx_PyInt_As_enum__tesseract_3a__3a_PageSegMode(PyObject *x) {
    const enum tesseract::PageSegMode neg_one = (enum tesseract::PageSegMode) -1, const_zero = (enum tesseract::PageSegMode) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum tesseract::PageSegMode) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum tesseract::PageSegMode) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum tesseract::PageSegMode) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum tesseract::PageSegMode) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) >= 2 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) (((((enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum tesseract::PageSegMode) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) >= 3 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) (((((((enum tesseract::PageSegMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum tesseract::PageSegMode) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) >= 4 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) (((((((((enum tesseract::PageSegMode)digits[3]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum tesseract::PageSegMode) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum tesseract::PageSegMode) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::PageSegMode, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(enum tesseract::PageSegMode) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::PageSegMode, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum tesseract::PageSegMode) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, sdigit, -(sdigit) digits[0])
                case  1: __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 2 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) (((enum tesseract::PageSegMode)-1)*(((((enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum tesseract::PageSegMode) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 2 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) ((((((enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 3 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) (((enum tesseract::PageSegMode)-1)*(((((((enum tesseract::PageSegMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum tesseract::PageSegMode) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 3 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) ((((((((enum tesseract::PageSegMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 4 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) (((enum tesseract::PageSegMode)-1)*(((((((((enum tesseract::PageSegMode)digits[3]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum tesseract::PageSegMode) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::PageSegMode, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::PageSegMode) - 1 > 4 * PyLong_SHIFT) {
                            return (enum tesseract::PageSegMode) ((((((((((enum tesseract::PageSegMode)digits[3]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::PageSegMode)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum tesseract::PageSegMode) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::PageSegMode, long, PyLong_AsLong(x))
            } else if (sizeof(enum tesseract::PageSegMode) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::PageSegMode, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum tesseract::PageSegMode val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum tesseract::PageSegMode) -1;
        }
    } else {
        enum tesseract::PageSegMode val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (enum tesseract::PageSegMode) -1;
        val = __Pyx_PyInt_As_enum__tesseract_3a__3a_PageSegMode(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum tesseract::PageSegMode");
    return (enum tesseract::PageSegMode) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum tesseract::PageSegMode");
    return (enum tesseract::PageSegMode) -1;
}

static CYTHON_INLINE enum tesseract::OcrEngineMode __Pyx_PyInt_As_enum__tesseract_3a__3a_OcrEngineMode(PyObject *x) {
    const enum tesseract::OcrEngineMode neg_one = (enum tesseract::OcrEngineMode) -1, const_zero = (enum tesseract::OcrEngineMode) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum tesseract::OcrEngineMode) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum tesseract::OcrEngineMode) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum tesseract::OcrEngineMode) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) >= 2 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) (((((enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) >= 3 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) (((((((enum tesseract::OcrEngineMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) >= 4 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) (((((((((enum tesseract::OcrEngineMode)digits[3]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum tesseract::OcrEngineMode) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum tesseract::OcrEngineMode) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::OcrEngineMode, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(enum tesseract::OcrEngineMode) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::OcrEngineMode, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum tesseract::OcrEngineMode) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, sdigit, -(sdigit) digits[0])
                case  1: __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 2 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) (((enum tesseract::OcrEngineMode)-1)*(((((enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 2 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) ((((((enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 3 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) (((enum tesseract::OcrEngineMode)-1)*(((((((enum tesseract::OcrEngineMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 3 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) ((((((((enum tesseract::OcrEngineMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 4 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) (((enum tesseract::OcrEngineMode)-1)*(((((((((enum tesseract::OcrEngineMode)digits[3]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum tesseract::OcrEngineMode) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum tesseract::OcrEngineMode, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum tesseract::OcrEngineMode) - 1 > 4 * PyLong_SHIFT) {
                            return (enum tesseract::OcrEngineMode) ((((((((((enum tesseract::OcrEngineMode)digits[3]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[2]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[1]) << PyLong_SHIFT) | (enum tesseract::OcrEngineMode)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum tesseract::OcrEngineMode) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::OcrEngineMode, long, PyLong_AsLong(x))
            } else if (sizeof(enum tesseract::OcrEngineMode) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum tesseract::OcrEngineMode, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum tesseract::OcrEngineMode val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum tesseract::OcrEngineMode) -1;
        }
    } else {
        enum tesseract::OcrEngineMode val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (enum tesseract::OcrEngineMode) -1;
        val = __Pyx_PyInt_As_enum__tesseract_3a__3a_OcrEngineMode(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum tesseract::OcrEngineMode");
    return (enum tesseract::OcrEngineMode) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum tesseract::OcrEngineMode");
    return (enum tesseract::OcrEngineMode) -1;
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

static PyObject* __pyx_convert__to_py_Box(struct Box s) {
          PyObject* res;
          PyObject* member;
          res = PyDict_New(); if (res == NULL) return NULL;
          member = __Pyx_PyInt_From_int(s.x); if (member == NULL) goto bad;
          if (PyDict_SetItem(res, __pyx_n_s_x, member) < 0) goto bad;
          Py_DECREF(member);
          member = __Pyx_PyInt_From_int(s.y); if (member == NULL) goto bad;
          if (PyDict_SetItem(res, __pyx_n_s_y, member) < 0) goto bad;
          Py_DECREF(member);
          member = __Pyx_PyInt_From_int(s.w); if (member == NULL) goto bad;
          if (PyDict_SetItem(res, __pyx_n_s_w, member) < 0) goto bad;
          Py_DECREF(member);
          member = __Pyx_PyInt_From_int(s.h); if (member == NULL) goto bad;
          if (PyDict_SetItem(res, __pyx_n_s_h, member) < 0) goto bad;
          Py_DECREF(member);
          return res;
          bad:
          Py_XDECREF(member);
          Py_DECREF(res);
          return NULL;
        }
        static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, -(sdigit) digits[0])
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
    PyObject* fake_module;
    PyTypeObject* cached_type = NULL;
    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
    if (!fake_module) return NULL;
    Py_INCREF(fake_module);
    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
    if (cached_type) {
        if (!PyType_Check((PyObject*)cached_type)) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s is not a type object",
                type->tp_name);
            goto bad;
        }
        if (cached_type->tp_basicsize != type->tp_basicsize) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s has the wrong size, try recompiling",
                type->tp_name);
            goto bad;
        }
    } else {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        if (PyType_Ready(type) < 0) goto bad;
        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
            goto bad;
        Py_INCREF(type);
        cached_type = type;
    }
done:
    Py_DECREF(fake_module);
    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}

static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
    PyObject *method, *result = NULL;
    method = __Pyx_PyObject_GetAttrStr(obj, method_name);
    if (unlikely(!method)) goto bad;
#if CYTHON_COMPILING_IN_CPYTHON
    if (likely(PyMethod_Check(method))) {
        PyObject *self = PyMethod_GET_SELF(method);
        if (likely(self)) {
            PyObject *args;
            PyObject *function = PyMethod_GET_FUNCTION(method);
            args = PyTuple_New(2);
            if (unlikely(!args)) goto bad;
            Py_INCREF(self);
            PyTuple_SET_ITEM(args, 0, self);
            Py_INCREF(arg);
            PyTuple_SET_ITEM(args, 1, arg);
            Py_INCREF(function);
            Py_DECREF(method); method = NULL;
            result = __Pyx_PyObject_Call(function, args, NULL);
            Py_DECREF(args);
            Py_DECREF(function);
            return result;
        }
    }
#endif
    result = __Pyx_PyObject_CallOneArg(method, arg);
bad:
    Py_XDECREF(method);
    return result;
}

#include <structmember.h>
#include <frameobject.h>
static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value);
static PyObject *__Pyx_Coroutine_Close(PyObject *self);
static PyObject *__Pyx_Coroutine_Throw(PyObject *gen, PyObject *args);
#define __Pyx_Coroutine_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
#if 1 || PY_VERSION_HEX < 0x030300B0
static int __Pyx_PyGen_FetchStopIterationValue(PyObject **pvalue) {
    PyObject *et, *ev, *tb;
    PyObject *value = NULL;
    __Pyx_ErrFetch(&et, &ev, &tb);
    if (!et) {
        Py_XDECREF(tb);
        Py_XDECREF(ev);
        Py_INCREF(Py_None);
        *pvalue = Py_None;
        return 0;
    }
    if (likely(et == PyExc_StopIteration)) {
#if PY_VERSION_HEX >= 0x030300A0
        if (ev && Py_TYPE(ev) == (PyTypeObject*)PyExc_StopIteration) {
            value = ((PyStopIterationObject *)ev)->value;
            Py_INCREF(value);
            Py_DECREF(ev);
            Py_XDECREF(tb);
            Py_DECREF(et);
            *pvalue = value;
            return 0;
        }
#endif
        if (!ev || !PyObject_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration)) {
            if (!ev) {
                Py_INCREF(Py_None);
                ev = Py_None;
            } else if (PyTuple_Check(ev)) {
                if (PyTuple_GET_SIZE(ev) >= 1) {
                    PyObject *value;
#if CYTHON_COMPILING_IN_CPYTHON
                    value = PySequence_ITEM(ev, 0);
#else
                    value = PyTuple_GET_ITEM(ev, 0);
                    Py_INCREF(value);
#endif
                    Py_DECREF(ev);
                    ev = value;
                } else {
                    Py_INCREF(Py_None);
                    Py_DECREF(ev);
                    ev = Py_None;
                }
            }
            Py_XDECREF(tb);
            Py_DECREF(et);
            *pvalue = ev;
            return 0;
        }
    } else if (!PyErr_GivenExceptionMatches(et, PyExc_StopIteration)) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    PyErr_NormalizeException(&et, &ev, &tb);
    if (unlikely(!PyObject_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration))) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    Py_XDECREF(tb);
    Py_DECREF(et);
#if PY_VERSION_HEX >= 0x030300A0
    value = ((PyStopIterationObject *)ev)->value;
    Py_INCREF(value);
    Py_DECREF(ev);
#else
    {
        PyObject* args = __Pyx_PyObject_GetAttrStr(ev, __pyx_n_s_args);
        Py_DECREF(ev);
        if (likely(args)) {
            value = PySequence_GetItem(args, 0);
            Py_DECREF(args);
        }
        if (unlikely(!value)) {
            __Pyx_ErrRestore(NULL, NULL, NULL);
            Py_INCREF(Py_None);
            value = Py_None;
        }
    }
#endif
    *pvalue = value;
    return 0;
}
#endif
static CYTHON_INLINE
void __Pyx_Coroutine_ExceptionClear(__pyx_CoroutineObject *self) {
    PyObject *exc_type = self->exc_type;
    PyObject *exc_value = self->exc_value;
    PyObject *exc_traceback = self->exc_traceback;
    self->exc_type = NULL;
    self->exc_value = NULL;
    self->exc_traceback = NULL;
    Py_XDECREF(exc_type);
    Py_XDECREF(exc_value);
    Py_XDECREF(exc_traceback);
}
static CYTHON_INLINE
int __Pyx_Coroutine_CheckRunning(__pyx_CoroutineObject *gen) {
    if (unlikely(gen->is_running)) {
        PyErr_SetString(PyExc_ValueError,
                        "generator already executing");
        return 1;
    }
    return 0;
}
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_SendEx(__pyx_CoroutineObject *self, PyObject *value) {
    PyObject *retval;
    assert(!self->is_running);
    if (unlikely(self->resume_label == 0)) {
        if (unlikely(value && value != Py_None)) {
            PyErr_SetString(PyExc_TypeError,
                            "can't send non-None value to a "
                            "just-started generator");
            return NULL;
        }
    }
    if (unlikely(self->resume_label == -1)) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    if (value) {
#if CYTHON_COMPILING_IN_PYPY
#else
        if (self->exc_traceback) {
            PyThreadState *tstate = PyThreadState_GET();
            PyTracebackObject *tb = (PyTracebackObject *) self->exc_traceback;
            PyFrameObject *f = tb->tb_frame;
            Py_XINCREF(tstate->frame);
            assert(f->f_back == NULL);
            f->f_back = tstate->frame;
        }
#endif
        __Pyx_ExceptionSwap(&self->exc_type, &self->exc_value,
                            &self->exc_traceback);
    } else {
        __Pyx_Coroutine_ExceptionClear(self);
    }
    self->is_running = 1;
    retval = self->body((PyObject *) self, value);
    self->is_running = 0;
    if (retval) {
        __Pyx_ExceptionSwap(&self->exc_type, &self->exc_value,
                            &self->exc_traceback);
#if CYTHON_COMPILING_IN_PYPY
#else
        if (self->exc_traceback) {
            PyTracebackObject *tb = (PyTracebackObject *) self->exc_traceback;
            PyFrameObject *f = tb->tb_frame;
            Py_CLEAR(f->f_back);
        }
#endif
    } else {
        __Pyx_Coroutine_ExceptionClear(self);
    }
    return retval;
}
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_MethodReturn(PyObject *retval) {
    if (unlikely(!retval && !PyErr_Occurred())) {
        PyErr_SetNone(PyExc_StopIteration);
    }
    return retval;
}
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_FinishDelegation(__pyx_CoroutineObject *gen) {
    PyObject *ret;
    PyObject *val = NULL;
    __Pyx_Coroutine_Undelegate(gen);
    __Pyx_PyGen_FetchStopIterationValue(&val);
    ret = __Pyx_Coroutine_SendEx(gen, val);
    Py_XDECREF(val);
    return ret;
}
static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value) {
    PyObject *retval;
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(__Pyx_Coroutine_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Send(yf, value);
        } else
        #endif
        #ifdef __Pyx_Coroutine_USED
        if (__Pyx_Coroutine_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Send(yf, value);
        } else
        #endif
        {
            if (value == Py_None)
                ret = PyIter_Next(yf);
            else
                ret = __Pyx_PyObject_CallMethod1(yf, __pyx_n_s_send, value);
        }
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        retval = __Pyx_Coroutine_FinishDelegation(gen);
    } else {
        retval = __Pyx_Coroutine_SendEx(gen, value);
    }
    return __Pyx_Coroutine_MethodReturn(retval);
}
static int __Pyx_Coroutine_CloseIter(__pyx_CoroutineObject *gen, PyObject *yf) {
    PyObject *retval = NULL;
    int err = 0;
    #ifdef __Pyx_Generator_USED
    if (__Pyx_Generator_CheckExact(yf)) {
        retval = __Pyx_Coroutine_Close(yf);
        if (!retval)
            return -1;
    } else
    #endif
    #ifdef __Pyx_Coroutine_USED
    if (__Pyx_Coroutine_CheckExact(yf)) {
        retval = __Pyx_Coroutine_Close(yf);
        if (!retval)
            return -1;
    } else
    #endif
    {
        PyObject *meth;
        gen->is_running = 1;
        meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_close);
        if (unlikely(!meth)) {
            if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                PyErr_WriteUnraisable(yf);
            }
            PyErr_Clear();
        } else {
            retval = PyObject_CallFunction(meth, NULL);
            Py_DECREF(meth);
            if (!retval)
                err = -1;
        }
        gen->is_running = 0;
    }
    Py_XDECREF(retval);
    return err;
}
static PyObject *__Pyx_Generator_Next(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(__Pyx_Coroutine_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        ret = Py_TYPE(yf)->tp_iternext(yf);
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        return __Pyx_Coroutine_FinishDelegation(gen);
    }
    return __Pyx_Coroutine_SendEx(gen, Py_None);
}
static PyObject *__Pyx_Coroutine_Close(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject *retval, *raised_exception;
    PyObject *yf = gen->yieldfrom;
    int err = 0;
    if (unlikely(__Pyx_Coroutine_CheckRunning(gen)))
        return NULL;
    if (yf) {
        Py_INCREF(yf);
        err = __Pyx_Coroutine_CloseIter(gen, yf);
        __Pyx_Coroutine_Undelegate(gen);
        Py_DECREF(yf);
    }
    if (err == 0)
        PyErr_SetNone(PyExc_GeneratorExit);
    retval = __Pyx_Coroutine_SendEx(gen, NULL);
    if (retval) {
        Py_DECREF(retval);
        PyErr_SetString(PyExc_RuntimeError,
                        "generator ignored GeneratorExit");
        return NULL;
    }
    raised_exception = PyErr_Occurred();
    if (!raised_exception
        || raised_exception == PyExc_StopIteration
        || raised_exception == PyExc_GeneratorExit
        || PyErr_GivenExceptionMatches(raised_exception, PyExc_GeneratorExit)
        || PyErr_GivenExceptionMatches(raised_exception, PyExc_StopIteration))
    {
        if (raised_exception) PyErr_Clear();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}
static PyObject *__Pyx_Coroutine_Throw(PyObject *self, PyObject *args) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject *typ;
    PyObject *tb = NULL;
    PyObject *val = NULL;
    PyObject *yf = gen->yieldfrom;
    if (!PyArg_UnpackTuple(args, (char *)"throw", 1, 3, &typ, &val, &tb))
        return NULL;
    if (unlikely(__Pyx_Coroutine_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        Py_INCREF(yf);
        if (PyErr_GivenExceptionMatches(typ, PyExc_GeneratorExit)) {
            int err = __Pyx_Coroutine_CloseIter(gen, yf);
            Py_DECREF(yf);
            __Pyx_Coroutine_Undelegate(gen);
            if (err < 0)
                return __Pyx_Coroutine_MethodReturn(__Pyx_Coroutine_SendEx(gen, NULL));
            goto throw_here;
        }
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Throw(yf, args);
        } else
        #endif
        #ifdef __Pyx_Coroutine_USED
        if (__Pyx_Coroutine_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Throw(yf, args);
        } else
        #endif
        {
            PyObject *meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_throw);
            if (unlikely(!meth)) {
                Py_DECREF(yf);
                if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                    gen->is_running = 0;
                    return NULL;
                }
                PyErr_Clear();
                __Pyx_Coroutine_Undelegate(gen);
                gen->is_running = 0;
                goto throw_here;
            }
            ret = PyObject_CallObject(meth, args);
            Py_DECREF(meth);
        }
        gen->is_running = 0;
        Py_DECREF(yf);
        if (!ret) {
            ret = __Pyx_Coroutine_FinishDelegation(gen);
        }
        return __Pyx_Coroutine_MethodReturn(ret);
    }
throw_here:
    __Pyx_Raise(typ, val, tb, NULL);
    return __Pyx_Coroutine_MethodReturn(__Pyx_Coroutine_SendEx(gen, NULL));
}
static int __Pyx_Coroutine_traverse(PyObject *self, visitproc visit, void *arg) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    Py_VISIT(gen->closure);
    Py_VISIT(gen->classobj);
    Py_VISIT(gen->yieldfrom);
    Py_VISIT(gen->exc_type);
    Py_VISIT(gen->exc_value);
    Py_VISIT(gen->exc_traceback);
    return 0;
}
static int __Pyx_Coroutine_clear(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    Py_CLEAR(gen->closure);
    Py_CLEAR(gen->classobj);
    Py_CLEAR(gen->yieldfrom);
    Py_CLEAR(gen->exc_type);
    Py_CLEAR(gen->exc_value);
    Py_CLEAR(gen->exc_traceback);
    Py_CLEAR(gen->gi_name);
    Py_CLEAR(gen->gi_qualname);
    return 0;
}
static void __Pyx_Coroutine_dealloc(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject_GC_UnTrack(gen);
    if (gen->gi_weakreflist != NULL)
        PyObject_ClearWeakRefs(self);
    if (gen->resume_label > 0) {
        PyObject_GC_Track(self);
#if PY_VERSION_HEX >= 0x030400a1
        if (PyObject_CallFinalizerFromDealloc(self))
#else
        Py_TYPE(gen)->tp_del(self);
        if (self->ob_refcnt > 0)
#endif
        {
            return;
        }
        PyObject_GC_UnTrack(self);
    }
    __Pyx_Coroutine_clear(self);
    PyObject_GC_Del(gen);
}
static void __Pyx_Coroutine_del(PyObject *self) {
    PyObject *res;
    PyObject *error_type, *error_value, *error_traceback;
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    if (gen->resume_label <= 0)
        return ;
#if PY_VERSION_HEX < 0x030400a1
    assert(self->ob_refcnt == 0);
    self->ob_refcnt = 1;
#endif
    __Pyx_ErrFetch(&error_type, &error_value, &error_traceback);
    res = __Pyx_Coroutine_Close(self);
    if (res == NULL)
        PyErr_WriteUnraisable(self);
    else
        Py_DECREF(res);
    __Pyx_ErrRestore(error_type, error_value, error_traceback);
#if PY_VERSION_HEX < 0x030400a1
    assert(self->ob_refcnt > 0);
    if (--self->ob_refcnt == 0) {
        return;
    }
    {
        Py_ssize_t refcnt = self->ob_refcnt;
        _Py_NewReference(self);
        self->ob_refcnt = refcnt;
    }
#if CYTHON_COMPILING_IN_CPYTHON
    assert(PyType_IS_GC(self->ob_type) &&
           _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
    _Py_DEC_REFTOTAL;
#endif
#ifdef COUNT_ALLOCS
    --Py_TYPE(self)->tp_frees;
    --Py_TYPE(self)->tp_allocs;
#endif
#endif
}
static PyObject *
__Pyx_Coroutine_get_name(__pyx_CoroutineObject *self)
{
    Py_INCREF(self->gi_name);
    return self->gi_name;
}
static int
__Pyx_Coroutine_set_name(__pyx_CoroutineObject *self, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_name;
    Py_INCREF(value);
    self->gi_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_Coroutine_get_qualname(__pyx_CoroutineObject *self)
{
    Py_INCREF(self->gi_qualname);
    return self->gi_qualname;
}
static int
__Pyx_Coroutine_set_qualname(__pyx_CoroutineObject *self, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_qualname;
    Py_INCREF(value);
    self->gi_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static __pyx_CoroutineObject *__Pyx__Coroutine_New(PyTypeObject* type, __pyx_coroutine_body_t body,
                                                   PyObject *closure, PyObject *name, PyObject *qualname) {
    __pyx_CoroutineObject *gen = PyObject_GC_New(__pyx_CoroutineObject, type);
    if (gen == NULL)
        return NULL;
    gen->body = body;
    gen->closure = closure;
    Py_XINCREF(closure);
    gen->is_running = 0;
    gen->resume_label = 0;
    gen->classobj = NULL;
    gen->yieldfrom = NULL;
    gen->exc_type = NULL;
    gen->exc_value = NULL;
    gen->exc_traceback = NULL;
    gen->gi_weakreflist = NULL;
    Py_XINCREF(qualname);
    gen->gi_qualname = qualname;
    Py_XINCREF(name);
    gen->gi_name = name;
    PyObject_GC_Track(gen);
    return gen;
}

static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code) {
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
    int result;
    PyObject *globals, *result_obj;
    globals = PyDict_New();  if (unlikely(!globals)) goto ignore;
    result = PyDict_SetItemString(globals, "_cython_coroutine_type",
    #ifdef __Pyx_Coroutine_USED
        (PyObject*)__pyx_CoroutineType);
    #else
        Py_None);
    #endif
    if (unlikely(result < 0)) goto ignore;
    result = PyDict_SetItemString(globals, "_cython_generator_type",
    #ifdef __Pyx_Generator_USED
        (PyObject*)__pyx_GeneratorType);
    #else
        Py_None);
    #endif
    if (unlikely(result < 0)) goto ignore;
    if (unlikely(PyDict_SetItemString(globals, "_module", module) < 0)) goto ignore;
    if (unlikely(PyDict_SetItemString(globals, "__builtins__", __pyx_b) < 0)) goto ignore;
    result_obj = PyRun_String(py_code, Py_file_input, globals, globals);
    if (unlikely(!result_obj)) goto ignore;
    Py_DECREF(result_obj);
    Py_DECREF(globals);
    return module;
ignore:
    Py_XDECREF(globals);
    PyErr_WriteUnraisable(module);
    if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, "Cython module failed to patch module with custom type", 1) < 0)) {
        Py_DECREF(module);
        module = NULL;
    }
#else
    py_code++;
#endif
    return module;
}

#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
static PyObject* __Pyx_patch_abc_module(PyObject *module);
static PyObject* __Pyx_patch_abc_module(PyObject *module) {
    module = __Pyx_Coroutine_patch_module(
        module, ""
"if _cython_generator_type is not None:\n"
"    try: Generator = _module.Generator\n"
"    except AttributeError: pass\n"
"    else: Generator.register(_cython_generator_type)\n"
"if _cython_coroutine_type is not None:\n"
"    try: Coroutine = _module.Coroutine\n"
"    except AttributeError: pass\n"
"    else: Coroutine.register(_cython_coroutine_type)\n"
    );
    return module;
}
#endif
static int __Pyx_patch_abc(void) {
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
    static int abc_patched = 0;
    if (!abc_patched) {
        PyObject *module;
        module = PyImport_ImportModule((PY_VERSION_HEX >= 0x03030000) ? "collections.abc" : "collections");
        if (!module) {
            PyErr_WriteUnraisable(NULL);
            if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning,
                    ((PY_VERSION_HEX >= 0x03030000) ?
                        "Cython module failed to register with collections.abc module" :
                        "Cython module failed to register with collections module"), 1) < 0)) {
                return -1;
            }
        } else {
            module = __Pyx_patch_abc_module(module);
            abc_patched = 1;
            if (unlikely(!module))
                return -1;
            Py_DECREF(module);
        }
        module = PyImport_ImportModule("backports_abc");
        if (module) {
            module = __Pyx_patch_abc_module(module);
            Py_XDECREF(module);
        }
        if (!module) {
            PyErr_Clear();
        }
    }
#else
    if (0) __Pyx_Coroutine_patch_module(NULL, NULL);
#endif
    return 0;
}

static PyMethodDef __pyx_Generator_methods[] = {
    {"send", (PyCFunction) __Pyx_Coroutine_Send, METH_O,
     (char*) PyDoc_STR("send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration.")},
    {"throw", (PyCFunction) __Pyx_Coroutine_Throw, METH_VARARGS,
     (char*) PyDoc_STR("throw(typ[,val[,tb]]) -> raise exception in generator,\nreturn next yielded value or raise StopIteration.")},
    {"close", (PyCFunction) __Pyx_Coroutine_Close, METH_NOARGS,
     (char*) PyDoc_STR("close() -> raise GeneratorExit inside generator.")},
    {0, 0, 0, 0}
};
static PyMemberDef __pyx_Generator_memberlist[] = {
    {(char *) "gi_running", T_BOOL, offsetof(__pyx_CoroutineObject, is_running), READONLY, NULL},
    {(char*) "gi_yieldfrom", T_OBJECT, offsetof(__pyx_CoroutineObject, yieldfrom), READONLY,
     (char*) PyDoc_STR("object being iterated by 'yield from', or None")},
    {0, 0, 0, 0, 0}
};
static PyGetSetDef __pyx_Generator_getsets[] = {
    {(char *) "__name__", (getter)__Pyx_Coroutine_get_name, (setter)__Pyx_Coroutine_set_name,
     (char*) PyDoc_STR("name of the generator"), 0},
    {(char *) "__qualname__", (getter)__Pyx_Coroutine_get_qualname, (setter)__Pyx_Coroutine_set_qualname,
     (char*) PyDoc_STR("qualified name of the generator"), 0},
    {0, 0, 0, 0, 0}
};
static PyTypeObject __pyx_GeneratorType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "generator",
    sizeof(__pyx_CoroutineObject),
    0,
    (destructor) __Pyx_Coroutine_dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
    0,
    (traverseproc) __Pyx_Coroutine_traverse,
    0,
    0,
    offsetof(__pyx_CoroutineObject, gi_weakreflist),
    0,
    (iternextfunc) __Pyx_Generator_Next,
    __pyx_Generator_methods,
    __pyx_Generator_memberlist,
    __pyx_Generator_getsets,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#else
    __Pyx_Coroutine_del,
#endif
    0,
#if PY_VERSION_HEX >= 0x030400a1
    __Pyx_Coroutine_del,
#endif
};
static int __pyx_Generator_init(void) {
    __pyx_GeneratorType_type.tp_getattro = PyObject_GenericGetAttr;
    __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
    __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
    if (unlikely(!__pyx_GeneratorType)) {
        return -1;
    }
    return 0;
}

static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if CYTHON_COMPILING_IN_CPYTHON && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else
        if (__Pyx_PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_LENGTH(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else
        return PyUnicode_AsUTF8AndSize(o, length);
#endif
#endif
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return __Pyx_NewRef(x);
  m = Py_TYPE(x)->tp_as_number;
#if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(x);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
